# Спецификация: Метрики синхронной обработки входящих сообщений

## Обзор

Добавление сбора статистики (длительность, успешность) для синхронно обрабатываемых входящих потоков данных. Сейчас при `АсинхроннаяОбработка = Ложь` сообщение обрабатывается напрямую без записи в очередь, без трекинга статуса и **без записи статистики** — это означает полное отсутствие наблюдаемости для синхронного пути.

## Проблема

### Текущее поведение

```
ОбработкаВходящегоСообщенияПоПотоку()
├── АсинхроннаяОбработка = Истина
│   └── ЗарегистрироватьСообщение() → очередь → обработка → ЗаписатьСтатистикуОбработкиВходящего() ✅
│
└── АсинхроннаяОбработка = Ложь
    └── ОбработатьВходящееСообщениеПоПотоку() → ??? (нет статистики) ❌
```

Метрики Prometheus (`pde_incoming_duration_seconds`, `pde_error_count`, `pde_messages_per_minute`) получают данные из `инт_СтатистикаОбработкиСообщений`. Для синхронных сообщений этот регистр пуст — метрики их не видят.

### Влияние

- Невозможно отследить время обработки синхронных входящих потоков
- Невозможно увидеть ошибки обработки в метриках
- Dashboard-ы Prometheus показывают неполную картину
- В `инт_ПотокиДанных.ОбработатьВходящееСообщениеПоПотоку` есть закомментированный TODO на замер времени

## Решение

### Изменение модуля `инт_ОбработкаВходящихПотоков`

В ветке `Иначе` (синхронная обработка) добавить:
1. Замер времени начала обработки
2. Генерацию `ИдентификаторСообщения`, если он не передан
3. Вызов `ЗаписатьСтатистикуОбработкиВходящего()` после обработки (и при успехе, и при ошибке)
4. Пробрасывание исключения дальше после записи статистики при ошибке

### Целевой код

```bsl
Если ПотокДанных.АсинхроннаяОбработка Тогда
    РегистрыСведений.инт_ОчередьВходящихСообщений.ЗарегистрироватьСообщение(Сообщение, ПотокДанных, ИдентификаторСообщения);
Иначе
    // Синхронная обработка с записью статистики
    Если ИдентификаторСообщения = Неопределено Тогда
        ИдентификаторСообщения = Новый УникальныйИдентификатор;
    КонецЕсли;
    
    ВремяНачала = ТекущаяУниверсальнаяДатаВМиллисекундах();
    Попытка
        Справочники.инт_ПотокиДанных.ОбработатьВходящееСообщениеПоПотоку(Сообщение, ПотокДанных);
        ДлительностьМс = ТекущаяУниверсальнаяДатаВМиллисекундах() - ВремяНачала;
        РегистрыСведений.инт_СтатистикаОбработкиСообщений.ЗаписатьСтатистикуОбработкиВходящего(
            ИдентификаторСообщения, ПотокДанных, ДлительностьМс, Истина);
    Исключение
        ДлительностьМс = ТекущаяУниверсальнаяДатаВМиллисекундах() - ВремяНачала;
        РегистрыСведений.инт_СтатистикаОбработкиСообщений.ЗаписатьСтатистикуОбработкиВходящего(
            ИдентификаторСообщения, ПотокДанных, ДлительностьМс, Ложь);
        ВызватьИсключение;
    КонецПопытки;
КонецЕсли;
```

### Паттерн аналогичен async-пути

Подход повторяет паттерн из `инт_ОчередьВходящихСообщений.ОбработатьСообщениеПоИдентификатору()`:
- Замер `ВремяНачала` перед обработкой
- `ЗаписатьСтатистикуОбработкиВходящего()` в обоих ветках (успех/ошибка)
- При ошибке — ещё пробрасывание исключения (в отличие от async, где оно логируется)

### Что не меняется

- Синхронный путь **по-прежнему не пишет в очередь** и **не трекает статус** — это осознанное решение (очередь нужна только для retry и отложенной обработки)
- Метрики Prometheus не требуют изменений — они уже читают из `инт_СтатистикаОбработкиСообщений`

## Тестирование

### Новые тесты

1. **СинхроннаяОбработкаЗаписываетСтатистикуУспеха** — проверяет, что при успешной синхронной обработке вызывается `ЗаписатьСтатистикуОбработкиВходящего` с `Успешно = Истина`
2. **СинхроннаяОбработкаЗаписываетСтатистикуОшибки** — проверяет, что при ошибке обработки вызывается `ЗаписатьСтатистикуОбработкиВходящего` с `Успешно = Ложь` и исключение пробрасывается дальше

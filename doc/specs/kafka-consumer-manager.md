# Kafka Consumer Manager для входящих потоков

## Статус: В разработке

## Обзор

Реализация менеджера входящих потоков с новым справочником `инт_Подписки` для настройки консьюмеров Kafka. Менеджер запускается раз в 30 секунд, группирует потоки по режиму обработки:

- **Асинхронные потоки** → единая группа консьюмеров, сообщения записываются в `инт_ОчередьВходящихСообщений`
- **Синхронные потоки** → отдельные ФЗ на каждую подписку, немедленная обработка с отправкой в DLQ при ошибках

## Архитектура

```
┌─────────────────────────────────────────────────────────────────────┐
│                    РЗ: инт_МенеджерВходящихПотоков                  │
│                         (каждые 30 сек)                             │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    ▼                               ▼
        ┌───────────────────────┐       ┌───────────────────────┐
        │  Асинхронные потоки   │       │  Синхронные потоки    │
        │  (АсинхроннаяОбработка│       │  (АсинхроннаяОбработка│
        │   = Истина)           │       │   = Ложь)             │
        └───────────────────────┘       └───────────────────────┘
                    │                               │
                    ▼                               ▼
        ┌───────────────────────┐       ┌───────────────────────┐
        │  1 ФЗ на все потоки   │       │  1 ФЗ на каждую       │
        │  ConsumerGroup:       │       │  подписку             │
        │  {GUID_ИБ}_async      │       │  ConsumerGroup:       │
        │                       │       │  из настроек подписки │
        └───────────────────────┘       └───────────────────────┘
                    │                               │
                    ▼                               ▼
        ┌───────────────────────┐       ┌───────────────────────┐
        │  Сообщение →          │       │  Сообщение →          │
        │  инт_ОчередьВходящих  │       │  Немедленная обработка│
        │  Сообщений            │       │  Ошибка → DLQ топик   │
        └───────────────────────┘       └───────────────────────┘
```

## Компоненты

### 1. Определяемый тип `инт_Подписка`

Полиморфный тип для подписчиков, требующих активного получения сообщений (консьюмеры).

```xml
<Type>
    <v8:Type>cfg:CatalogRef.инт_ПодписчикиKafka</v8:Type>
    <v8:Type>cfg:CatalogRef.инт_ПодписчикиRabbitMQ</v8:Type>
</Type>
```

### 2. Доработка справочника `инт_ПодписчикиKafka`

Добавить новый реквизит в область "Параметры консьюмера":

| Реквизит | Тип | Описание |
|----------|-----|----------|
| `ИмяDLQТопика` | String(255) | Топик для "мёртвых" сообщений (Dead Letter Queue) |

**Consumer Group ID** генерируется автоматически: `{GUID_ИБ}_{Код подписчика}`

### 3. Табличная часть `ПодпискиНаВходящиеСообщения` в `инт_ПотокиДанных`

| Колонка | Тип | Описание |
|---------|-----|----------|
| `Подписка` | DefinedType.инт_Подписка | Ссылка на подписчика (Kafka/RabbitMQ) |

**Условная видимость**: ТЧ видима только когда `НаправлениеПотока = Входящий`

### 4. Константа `инт_ТаймаутОжиданияКонсьюмера`

- **Тип**: Number
- **Значение по умолчанию**: 5000 (мс)
- **Назначение**: Таймаут ожидания сообщений в методе `ПрочитатьСообщение()`

### 5. Регламентное задание `инт_МенеджерВходящихПотоков`

- **Расписание**: каждые 30 секунд
- **Метод**: `инт_МенеджерВходящихПотоков.ЗапуститьМенеджер()`
- **Назначение**: Мониторинг и запуск фоновых заданий консьюмеров

### 6. Общий модуль `инт_МенеджерВходящихПотоков`

#### Экспортные методы

```bsl
// Точка входа регламентного задания
Процедура ЗапуститьМенеджер() Экспорт

// Запуск консьюмера для асинхронных потоков (одно ФЗ на все)
Процедура ЗапуститьАсинхронныйКонсьюмер(МассивПодписок) Экспорт

// Запуск консьюмера для синхронного потока (отдельное ФЗ)
Процедура ЗапуститьСинхронныйКонсьюмер(Подписка, ПотокДанных) Экспорт
```

#### Алгоритм `ЗапуститьМенеджер()`

1. Получить активные входящие потоки с заполненными подписками
2. Разделить на 2 группы по флагу `АсинхроннаяОбработка`
3. Для асинхронной группы:
   - Проверить, запущено ли ФЗ `инт_КонсьюмерАсинхронныйГрупповой`
   - Если нет или завершено — запустить новое
4. Для синхронной группы:
   - По каждой подписке проверить наличие активного ФЗ
   - Если нет — запустить `инт_КонсьюмерСинхронный`

### 7. Консьюмер-логика в `инт_РаботаСКафка`

#### Новые методы

```bsl
// Создание и инициализация консьюмера
// Возврат: Компонента (внешняя компонента simpleKafka1C)
Функция СоздатьКонсьюмер(Брокеры, ГруппаКонсьюмеров, МассивТопиков) Экспорт

// Цикл чтения сообщений для асинхронного режима
// Сообщения записываются в инт_ОчередьВходящихСообщений
Процедура ЧитатьСообщенияАсинхронно(Компонента, СоответствиеТопикПоток) Экспорт

// Цикл чтения сообщений для синхронного режима
// Сообщения обрабатываются сразу, ошибки → DLQ
Процедура ЧитатьСообщенияСинхронно(Компонента, Подписка, ПотокДанных) Экспорт

// Отправка сообщения в Dead Letter Queue
Процедура ОтправитьВDLQ(Компонента, DLQТопик, ИсходноеСообщение, ОшибкаОбработки, КоличествоПопыток) Экспорт
```

### 8. Регистр сведений `инт_АктивныеКонсьюмеры`

Мониторинг состояния фоновых заданий консьюмеров.

| Тип | Имя | Тип данных | Описание |
|-----|-----|------------|----------|
| Измерение | `ИдентификаторЗадания` | UUID | ID фонового задания |
| Ресурс | `ПотокДанных` | CatalogRef.инт_ПотокиДанных | Связанный поток (для sync) |
| Ресурс | `Подписка` | DefinedType.инт_Подписка | Связанный подписчик (Kafka/RabbitMQ) |
| Ресурс | `РежимОбработки` | String(20) | "Асинхронный" / "Синхронный" |
| Ресурс | `ВремяЗапуска` | DateTime | Время старта ФЗ |
| Ресурс | `ПоследняяАктивность` | DateTime | Время последнего heartbeat |

## Формат DLQ-сообщения

```json
{
  "original_topic": "orders.incoming",
  "original_partition": 0,
  "original_offset": 12345,
  "original_payload": "{...исходные данные...}",
  "error_message": "Ошибка валидации: поле 'amount' обязательно",
  "retry_count": 3,
  "failed_at": "2026-02-02T14:30:00Z"
}
```

## Consumer Group Strategy

Consumer Group ID генерируется автоматически:

- **Асинхронные потоки**: `{GUID_ИБ}_async_incoming` — единая группа для всех async-потоков
- **Синхронные потоки**: `{GUID_ИБ}_{Код подписчика}` — отдельная группа для каждого подписчика

GUID информационной базы получается через `ПараметрыСеанса.ИдентификаторИБ` или `РегистрыСведений.инт_ПараметрыИнтеграции`.

## Цикл чтения сообщений

```bsl
Пока РазрешеноСлушать Цикл
    РезультатЧтения = Компонента.ПрочитатьСообщение();
    
    Если НЕ РезультатЧтения Тогда
        // Проверка флага Активен подписки
        РазрешеноСлушать = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Подписка, "Активен");
        Если Не РазрешеноСлушать Тогда
            Прервать;
        Иначе
            Продолжить;
        КонецЕсли;
    КонецЕсли;
    
    ДанныеСообщения = Компонента.ПолучитьДанныеСообщения();
    ТопикСообщения = Компонента.ПолучитьТопикСообщения();
    СмещениеСообщения = Компонента.ПолучитьСмещениеСообщения();
    
    // Обработка в зависимости от режима...
    
    // Фиксация смещения
    НовоеСмещение = Число(СмещениеСообщения) + 1;
    Компонента.ЗафиксироватьСмещение(ТопикСообщения, НовоеСмещение, РазделСообщения);
КонецЦикла;
```

## Drain подписки (остановка отдельного консьюмера)

### Назначение

Возможность перевести подписку в статус `Drained` для проведения сервисных работ (например, изменение офсета, перенастройка параметров). При drain'е подписки все консьюмеры, читающие её топик, останавливаются и перезапускаются **без** этого топика.

### Механизм

1. Вызов `инт_МенеджерВходящихПотоков.DrainПодписку(Подписка)`:
   - Устанавливает `СтатусАктивности = "Drained"` в `инт_АктивныеКонсьюмеры` по подписке
   - Если записи нет (консьюмер не запущен), создаёт запись с пустым `ИдентификаторФоновогоЗадания` и статусом `"Drained"`
2. Цикл чтения `ЦиклЧтенияСообщений` при следующем poll-е вызывает `ПроверитьСтатусКонсьюмера()`:
   - Проверяет регистр `инт_АктивныеКонсьюмеры` на наличие статусов `"Drained"` или `"GracefulStop"` для любой подписки из текущей группы
   - Если найден `"Drained"` или `"GracefulStop"` → `РазрешеноСлушать = Ложь` → консьюмер завершает цикл
3. Менеджер при очередном тике (каждые 30 сек):
   - `ПолучитьАктивныеПодписки()` — из результата **исключаются** подписки со статусом `"Drained"` в регистре
   - Перезапускает консьюмер для оставшихся подписок эндпоинта
4. Восстановление: `инт_МенеджерВходящихПотоков.ВосстановитьПодписку(Подписка)`:
   - Удаляет запись со статусом `"Drained"` из `инт_АктивныеКонсьюмеры`
   - При следующем тике менеджер включит подписку обратно в консьюмер-группу

### Жизненный цикл drain

```
   [Активна] ──DrainПодписку()──► [Drained]
       ▲                              │
       │                              ▼
       │                     Консьюмер видит "Drained"
       │                     → останавливает цикл
       │                              │
       │                              ▼
       │                     Менеджер перезапускает
       │                     консьюмер БЕЗ этого топика
       │                              │
  ВосстановитьПодписку() ◄────────────┘
       │
       ▼
  Менеджер включает подписку
  обратно при следующем тике
```

### API

```bsl
// Перевести подписку в режим drain
// Консьюмер, читающий топик этой подписки, будет остановлен и перезапущен без неё
инт_МенеджерВходящихПотоков.DrainПодписку(Подписка) Экспорт

// Восстановить подписку после drain
// При следующем тике менеджера подписка будет включена обратно в консьюмер-группу
инт_МенеджерВходящихПотоков.ВосстановитьПодписку(Подписка) Экспорт

// Получить список drained подписок
// Возвращает массив структур с полями Подписка, ДатаDrain
инт_МенеджерВходящихПотоков.ПолучитьОстановленныеПодписки() Экспорт
```

## Graceful Stop всех консьюмеров

### Назначение

Корректная остановка **всех** консьюмеров (например, перед обновлением ИБ). В отличие от `ОстановитьВсеКонсьюмеры()` (force cancel), graceful stop:
- Дожидается завершения обработки текущего сообщения
- Корректно фиксирует offset
- Корректно закрывает соединения с Kafka

### Механизм

1. Вызов `инт_МенеджерВходящихПотоков.ГрейсфулСтопВсехКонсьюмеров()`:
   - Устанавливает константу `инт_ОстановитьВсеКонсьюмеры = Истина`
   - Устанавливает `СтатусАктивности = "GracefulStop"` для **всех** записей в `инт_АктивныеКонсьюмеры`
2. Все консьюмеры при следующем poll-е:
   - `ПроверитьСтатусКонсьюмера()` видит `"GracefulStop"` → `РазрешеноСлушать = Ложь`
   - Консьюмер завершает цикл, фиксирует offset, закрывает connection
3. Менеджер при очередном тике:
   - Проверяет `Константы.инт_ОстановитьВсеКонсьюмеры` → `Истина` → **не запускает** новые консьюмеры
4. Возобновление: `инт_МенеджерВходящихПотоков.ВозобновитьВсеКонсьюмеры()`:
   - Устанавливает `Константы.инт_ОстановитьВсеКонсьюмеры = Ложь`
   - Очищает записи со статусом `"GracefulStop"` из `инт_АктивныеКонсьюмеры`
   - При следующем тике менеджер запустит все активные консьюмеры

### Жизненный цикл graceful stop

```
   [Работают] ──ГрейсфулСтоп()──► [GracefulStop]
       ▲                               │
       │                               ▼
       │                      Все консьюмеры видят
       │                      "GracefulStop" → останавливаются
       │                               │
       │                               ▼
       │                      Менеджер НЕ запускает
       │                      новые (константа = Истина)
       │                               │
  ВозобновитьВсе() ◄──────────────────┘
       │
       ▼
  Константа = Ложь
  Менеджер запускает консьюмеры
```

### API

```bsl
// Грейсфул-стоп всех консьюмеров
// Все активные консьюмеры корректно завершат работу при следующем poll-е
инт_МенеджерВходящихПотоков.ГрейсфулСтопВсехКонсьюмеров() Экспорт

// Возобновить работу всех консьюмеров после graceful stop
инт_МенеджерВходящихПотоков.ВозобновитьВсеКонсьюмеры() Экспорт

// Проверяет, активен ли режим graceful stop
// Возврат: Булево
инт_МенеджерВходящихПотоков.РежимGracefulStop() Экспорт
```

## Новая константа: `инт_ОстановитьВсеКонсьюмеры`

| Параметр | Значение |
|----------|----------|
| Тип | Boolean |
| По умолчанию | False |
| Назначение | Глобальный флаг graceful stop — блокирует запуск новых консьюмеров |

## Изменения в `инт_АктивныеКонсьюмеры`

### Новые значения `СтатусАктивности`

| Значение | Описание |
|----------|----------|
| `"Kafka"` (существующее) | Консьюмер активно работает |
| `"Drained"` | Подписка остановлена для сервисных работ |
| `"GracefulStop"` | Глобальная остановка всех консьюмеров |

### Новые API методы регистра

```bsl
// Установить статус Drained для подписки
Процедура УстановитьСтатусDrained(Подписка) Экспорт

// Установить GracefulStop для всех записей
Процедура УстановитьГрейсфулСтоп() Экспорт

// Проверить, есть ли запрос на остановку для любой из переданных подписок
// Возврат: Структура с полями НужнаОстановка (Булево) и Причина (Строка)
Функция ПроверитьЗапросНаОстановку(МассивПодписок) Экспорт

// Удалить запись о drained подписке
Процедура СнятьСтатусDrained(Подписка) Экспорт

// Очистить все записи со статусом GracefulStop
Процедура ОчиститьGracefulStop() Экспорт

// Получить drained подписки
Функция ПолучитьDrainedПодписки() Экспорт
```

## Изменения в `инт_КонсьюмерОчередей`

### `ЦиклЧтенияСообщений` — добавлена проверка drain/stop

В основном цикле `Пока РазрешеноСлушать` добавляется проверка:

```bsl
// При каждом poll без сообщения:
РезультатПроверки = РегистрыСведений.инт_АктивныеКонсьюмеры.ПроверитьЗапросНаОстановку(МассивПодписокСсылки);

Если РезультатПроверки.НужнаОстановка Тогда
    РазрешеноСлушать = Ложь;
    ЗаписьЖурналаРегистрации(..., "Остановка по запросу: " + РезультатПроверки.Причина);
КонецЕсли;
```

### `ПроверитьАктивностьПодписок` → расширяется

Функция теперь также проверяет register status (drain/graceful stop) помимо флага `Активен` подписки.

## Ссылки

- [Kafka в 1С: Exactly-Once и DLQ](https://infostart.ru/1c/articles/2575918/)
- [Simple Kafka Connector 1C](https://github.com/NuclearAPK/Simple-Kafka_Adapter)
- Пример консьюмера: [examples/consumer.bsl](../../examples/consumer.bsl)

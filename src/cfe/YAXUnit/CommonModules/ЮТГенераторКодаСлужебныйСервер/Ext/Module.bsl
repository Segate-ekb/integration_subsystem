//©///////////////////////////////////////////////////////////////////////////©//
//
//  Copyright 2021-2025 BIA-Technologies Limited Liability Company
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
//©///////////////////////////////////////////////////////////////////////////©//

#Область СлужебныйПрограммныйИнтерфейс

// Формирует код движений документа по регистрам в формате конструктора движений YAxUnit.
//
// Параметры:
//  Документ - ДокументСсылка - ссылка на документ, движения которого необходимо сформировать.
//  ДанныеДвижений - Соответствие - данные движений по регистрам:
//    * Ключ - Строка - имя регистра.
//    * Значение - ТаблицаЗначений - таблица движений по регистру.
//
// Возвращаемое значение:
//  Строка - код на языке 1С для создания движений документа с использованием конструктора объекта YAxUnit.
//
// Пример:
//  Код = ЮТГенераторКодаСлужебныйСервер.СформироватьКодДвиженийВФорматеКонструктора(ДокументСсылка, ДанныеДвижений);
//
Функция СформироватьКодДвиженийВФорматеКонструктора(Документ, ДанныеДвижений) Экспорт
	
	Конструктор = ЮТРаботаСТекстом.КонструкторТекста();
	ШагСоздатьДокумент(Конструктор, Документ, "ДокументСсылка");
	ШагДвиженияДокументаПоРегистру(Конструктор, ДанныеДвижений, "ДокументСсылка");
	
	Возврат Конструктор.Текст();
	
КонецФункции

// Формирует код движений документа по регистрам в формате таблицы Markdown для YAxUnit.
//
// Параметры:
//  Документ - ДокументСсылка - ссылка на документ, движения которого необходимо сформировать.
//  ДанныеДвижений - Соответствие - данные движений по регистрам:
//    * Ключ - Строка - имя регистра.
//    * Значение - ТаблицаЗначений - таблица движений по регистру.
//
// Возвращаемое значение:
//  Строка - код на языке 1С для создания движений документа с использованием макетов в формате Markdown.
//
// Пример:
//  Код = ЮТГенераторКодаСлужебныйСервер.СформироватьКодДвиженийВФорматеMarkdown(ДокументСсылка, ДанныеДвижений);
//
Функция СформироватьКодДвиженийВФорматеMarkdown(Документ, ДанныеДвижений) Экспорт
	
	Конструктор = ЮТРаботаСТекстом.КонструкторТекста();
	Конструктор.НоваяСтрока("ПараметрыЗагрузки = ЮТест.Данные().ПараметрыЗагрузкиМакетов();");
	ШагСоздатьДокумент(Конструктор, Документ, "ДокументСсылка");
	
	Для Каждого Запись Из ДанныеДвижений Цикл
		
		Конструктор.ПереносСтроки()
			.НоваяСтрока("// Движения по регистру " + Запись.Ключ);
		
		СериализоватьТаблицуВMarkdown(Конструктор, Запись.Значение, "ДанныеТаблицы");
		
		Конструктор.НоваяСтрокаПоШаблону(
			"ЮТест.Данные().ЗагрузитьДвиженияИзМакета(ДокументСсылка, ""%1"", ДанныеТаблицы, ,ПараметрыЗагрузки);",
			Запись.Ключ);
		
	КонецЦикла;
	
	Возврат Конструктор.Текст();
	
КонецФункции

// Формирует код создания объектов по массиву ссылок.
//
// Параметры:
//  СсылкиНаОбъекты - Массив из СправочникСсылка
//                   - Массив из ДокументСсылка
//                   - Массив из ПланВидовХарактеристикСсылка
//                   - Массив из ЗадачаСсылка - массив ссылок на объекты, для которых необходимо сформировать код.
//  НастройкиГенерации - см. ЮТГенераторКода.ПараметрыГенерацииКода
//
// Возвращаемое значение:
//  Строка - код на языке 1С для создания объектов с использованием конструктора объекта YAxUnit.
//
// Пример:
//  Код = ЮТГенераторКодаСлужебныйСервер.СформироватьКодПоСсылкамНаОбъекты(МассивСсылок, НастройкиФормирования);
//
Функция СформироватьКодПоСсылкамНаОбъекты(СсылкиНаОбъекты, Знач НастройкиГенерации) Экспорт
	
	НастройкиГенерации = ПодготовленныеНастройкиГенерации(НастройкиГенерации);
	ПодготовленныеДанные = ПодготовитьДанныеПоСсылкам(СсылкиНаОбъекты, НастройкиГенерации);
	
	Конструктор = ЮТРаботаСТекстом.КонструкторТекста();
	Контекст = КонтекстГенерации(Конструктор, НастройкиГенерации, ПодготовленныеДанные);
	
	ГенерацияПеременных(Контекст);
	
	// Генерируем код создания объектов в определенном порядке
	Для Каждого Ссылка Из ПодготовленныеДанные.УпорядоченныеСсылки Цикл
		
		Объект = ПодготовленныеДанные.Объекты[Ссылка];
		ОписаниеОбъекта = ЮТМетаданные.ОписаниеОбъектаМетаданных(Ссылка);
		
		ИмяПеременной = ИмяПеременной(Ссылка, НастройкиГенерации.ФорматИменованияПеременных);
		ИмяПеременной = НеконфликтующееИмяПеременной(ИмяПеременной, ПодготовленныеДанные.ИменаПеременных);
		
		СформироватьКодПоСсылке(Контекст, Объект, ИмяПеременной, ОписаниеОбъекта);
		ПодготовленныеДанные.ИменаПеременных.Вставить(ИмяПеременной, Ссылка);
		ПодготовленныеДанные.ВыраженияСсылок.Вставить(Ссылка, ИмяПеременной);
		
	КонецЦикла;
	
	Возврат Конструктор.Текст();
	
КонецФункции

// Преобразует значение в строковое представление для использования в сгенерированном коде.
//
// Параметры:
//  Значение - Произвольный - значение для преобразования.
//  ПараметрыГенерацииКода - см. ЮТГенераторКода.ПараметрыГенерацииКода
//
// Возвращаемое значение:
//  Строка - строковое представление значения, готовое для использования в коде 1С.
//
// Пример:
//  СтрокаЗначения = ЮТГенераторКодаСлужебныйСервер.ЗначениеВСтроку(Истина);
//  // Результат: "Истина"
//
Функция ЗначениеВСтроку(Значение, Знач ПараметрыГенерацииКода = Неопределено) Экспорт
	
	Результат = Неопределено;
	
	Если Значение = Неопределено Тогда
		Возврат "Неопределено";
	КонецЕсли;
	
	ТекТип = ТипЗнч(Значение);
	
	Результат = ВыражениеПримитивногоЗначения(Значение, ТекТип);
	
	Если Результат <> Неопределено Тогда
		Возврат Результат;
	ИначеЕсли ЮТТипыДанныхСлужебный.ЭтоСсылочныйТип(ТекТип) Тогда
		Если ПараметрыГенерацииКода = Неопределено Тогда
			ПараметрыГенерацииКода = ЮТГенераторКода.ПараметрыГенерацииКода();
		КонецЕсли;
		Результат = СсылочноеЗначениеВСтроку(Значение, ПараметрыГенерацииКода);
	Иначе
		Результат = СтрШаблон("!Тип (%1) не поддерживается!", ТекТип);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПодготовленныеНастройкиГенерации(ВходящиеНастройкиГенерации)
	
	НастройкиГенерации = ЮТГенераторКода.ПараметрыГенерацииКода();
	ЗаполнитьЗначенияСвойств(НастройкиГенерации, ВходящиеНастройкиГенерации);
	
	Если НастройкиГенерации.ИспользоватьНастройкуПостоянныеДанные Тогда
		НастройкиГенерации.ПостоянныеДанные = ПостоянныеДанные();
	КонецЕсли;
	
	Если НЕ НастройкиГенерации.ИгнорироватьКодИнициализацииПоТипам Тогда
		НастройкиГенерации.КодИнициализацииПоТипам = КодИнициализацииПоТипам();
	КонецЕсли;
	
	НастройкиГенерации.ИгнорироватьКодИнициализацииПоТипам = НЕ ЗначениеЗаполнено(НастройкиГенерации.КодИнициализацииПоТипам);
	НастройкиГенерации.ИспользоватьНастройкуПостоянныеДанные = ЗначениеЗаполнено(НастройкиГенерации.ПостоянныеДанные);
	
	Возврат НастройкиГенерации;
	
КонецФункции

// Создает структуру контекста генерации кода с необходимыми данными.
//
// Параметры:
//  Конструктор - см. ЮТРаботаСТекстом.КонструкторТекста
//  НастройкиГенерации - см. ЮТГенераторКода.ПараметрыГенерацииКода
//  ПодготовленныеДанные - см. ПодготовитьДанныеПоСсылкам
//
// Возвращаемое значение:
//  Структура - контекст генерации с полями:
//    * Конструктор - см. ЮТРаботаСТекстом.КонструкторТекста
//    * НастройкиГенерации - см. ЮТГенераторКода.ПараметрыГенерацииКода
//    * ПодготовленныеДанные - см. ПодготовитьДанныеПоСсылкам
Функция КонтекстГенерации(Конструктор, НастройкиГенерации, ПодготовленныеДанные)
	
	Контекст = Новый Структура;
	Контекст.Вставить("Конструктор", Конструктор);
	Контекст.Вставить("НастройкиГенерации", НастройкиГенерации);
	Контекст.Вставить("ПодготовленныеДанные", ПодготовленныеДанные);
	
	Возврат Контекст;
	
КонецФункции

// Формирует код создания объекта по ссылке и добавляет его в конструктор текста.
// Генерирует код создания конструктора объекта, установки реквизитов, заполнения табличных частей
// и вызова метода Провести() или Записать() в зависимости от типа объекта.
//
// Параметры:
//  Контекст - см. КонтекстГенерации
//  Объект - Произвольный - объект метаданных (документ, справочник и т.д.), для которого формируется код.
//  ИмяПеременной - Строка - имя переменной, в которую будет помещен объект.
//  ОписаниеОбъекта - см. ЮТМетаданные.ОписаниеОбъектаМетаданных
//
Процедура СформироватьКодПоСсылке(Контекст, Объект, ИмяПеременной, ОписаниеОбъекта)
	
	Конструктор = Контекст.Конструктор;
	
	ЭтоДокумент = ЮТМетаданные.ЭтоДокумент(ОписаниеОбъекта);
	
	ШагКомментарийОбъекта(Конструктор, Объект, ОписаниеОбъекта);
	ШагКонструкторОбъекта(Конструктор, ОписаниеОбъекта, ИмяПеременной);
	
	Конструктор.УвеличитьОтступ();
	ШагУстановкаРеквизитов(Контекст, Объект, ОписаниеОбъекта.Реквизиты);
	
	// Установка даты для документов
	Если ЭтоДокумент Тогда
		Конструктор.НоваяСтрока(".Установить(""Дата"", ТекущаяДатаСеанса())");
	КонецЕсли;
	
	// Установка пометки удаления, если есть
	Если Объект.ПометкаУдаления Тогда
		Конструктор.НоваяСтрока(".Установить(""ПометкаУдаления"", Истина)");
	КонецЕсли;
	
	// Фикция обязательных полей
	Конструктор.НоваяСтрока(".ФикцияОбязательныхПолей() // Автоматически заполняем обязательные поля");
	
	// Табличные части
	Для Каждого Элемент Из ОписаниеОбъекта.ТабличныеЧасти Цикл
		ШагЗаполненияТабличнойЧасти(Контекст, Элемент.Ключ, Объект[Элемент.Ключ], Элемент.Значение);
	КонецЦикла;
	
	// Провести или Записать
	Если ЭтоДокумент И Объект.Проведен Тогда
		Конструктор.НоваяСтрока(".Провести()");
	Иначе
		Конструктор.НоваяСтрока(".Записать()");
	КонецЕсли;
	
	Конструктор.УменьшитьОтступ()
		.НоваяСтрока(";").ПереносСтроки();
	
КонецПроцедуры

// Подготавливает данные для генерации кода по ссылкам на объекты.
// Собирает объекты, определяет порядок генерации на основе зависимостей,
// формирует имена переменных для повторяющихся ссылок.
//
// Параметры:
//  СсылкиНаОбъекты - Массив из ЛюбаяСсылка - массив ссылок на объекты для генерации.
//  ПараметрыГенерацииКода - см. ЮТГенераторКода.ПараметрыГенерацииКода
//
// Возвращаемое значение:
//  Структура - подготовленные данные для генерации:
//    * Объекты - Соответствие из ЛюбаяСсылка - соответствие ссылок на объекты.
//    * УпорядоченныеСсылки - Массив - упорядоченный массив ссылок в порядке генерации.
//    * ИменаПеременных - Соответствие из Строка - соответствие имен переменных для повторяющихся ссылок.
//    * ВыраженияСсылок - Соответствие из Строка - соответствие выражений для ссылок.
//
Функция ПодготовитьДанныеПоСсылкам(СсылкиНаОбъекты, ПараметрыГенерацииКода)
	
	Результат = Новый Структура;
	Результат.Вставить("Объекты", Новый Соответствие);
	Результат.Вставить("УпорядоченныеСсылки", Новый Массив);
	Результат.Вставить("ИменаПеременных", Новый Соответствие);
	Результат.Вставить("ВыраженияСсылок", Новый Соответствие);
	
	Дубли = Новый Массив;
	
	Для Каждого Ссылка Из СсылкиНаОбъекты Цикл
		Если Результат.Объекты[Ссылка] = Неопределено Тогда
			Результат.Объекты.Вставить(Ссылка, Ссылка.ПолучитьОбъект());
		Иначе
			Дубли.Добавить(Ссылка);
		КонецЕсли;
	КонецЦикла;
	
	// Собираем все ссылочные значения из объектов
	СсылочныеЗначенияПоОбъектам = СобратьСсылочныеЗначенияПоОбъектам(ЮТКоллекции.ВыгрузитьЗначения(Результат.Объекты, "Значение"));
	
	Для Каждого Ссылка Из Дубли Цикл
		Ссылки = СсылочныеЗначенияПоОбъектам[Ссылка];
		Для Каждого Элемент Из Ссылки Цикл
			Ссылки[Элемент.Ключ] = Элемент.Значение + 1;
		КонецЦикла;
	КонецЦикла;
	
	// Определяем порядок генерации объектов на основе зависимостей
	Результат.УпорядоченныеСсылки = ОпределитьПорядокГенерации(СсылкиНаОбъекты, СсылочныеЗначенияПоОбъектам);
	
	СчетчикСсылок = ПосчитатьСсылки(СсылочныеЗначенияПоОбъектам);
	
	Для Каждого Ссылка Из СсылкиНаОбъекты Цикл
		СчетчикСсылок.Удалить(Ссылка);
	КонецЦикла;
	
	Результат.ВыраженияСсылок = ВыраженияПоСсылкам(СчетчикСсылок, ПараметрыГенерацииКода);
	// Формируем имена переменных для повторяющихся ссылок
	Результат.ИменаПеременных = СформироватьИменаПеременныхДляСсылок(СчетчикСсылок, ПараметрыГенерацииКода.ФорматИменованияПеременных);
	
	Возврат Результат;
	
КонецФункции

#Область ШагиГенерацииКода

// Добавляет в конструктор текста код создания конструктора объекта YAxUnit.
//
// Параметры:
//  Конструктор - см. ЮТРаботаСТекстом.КонструкторТекста
//  ОписаниеОбъекта - см. ЮТМетаданные.ОписаниеОбъектаМетаданных
//  ИмяПеременной - Строка - имя переменной для конструктора объекта.
//
Процедура ШагКонструкторОбъекта(Конструктор, ОписаниеОбъекта, ИмяПеременной)
	
	Конструктор.НоваяСтрокаПоШаблону("%1 = ЮТест.Данные().КонструкторОбъекта(""%2.%3"")",
									 ИмяПеременной,
									 ОписаниеОбъекта.ОписаниеТипа.Имя,
									 ОписаниеОбъекта.Имя);
	
КонецПроцедуры

// Добавляет в конструктор текста код создания документа через YAxUnit.
//
// Параметры:
//  Конструктор - см. ЮТРаботаСТекстом.КонструкторТекста - конструктор текста.
//  Документ - ДокументСсылка - ссылка на документ для создания.
//  ИмяПеременной - Строка - имя переменной для ссылки на документ.
//
Процедура ШагСоздатьДокумент(Конструктор, Документ, ИмяПеременной)
	
	Описание = ЮТМетаданные.ОписаниеОбъектаМетаданных(Документ);
	Выражение = ВыражениеСозданияСсылочногоЗначения(Документ, Описание);
	Конструктор.НоваяСтрокаПоШаблону("%1 = %2;", ИмяПеременной, Выражение);
	
КонецПроцедуры

// Добавляет в конструктор текста код создания движений документа по регистрам.
//
// Параметры:
//  Конструктор - см. ЮТРаботаСТекстом.КонструкторТекста
//  ДанныеДвижений - Соответствие - данные движений по регистрам:
//    * Ключ - Строка - имя регистра.
//    * Значение - ТаблицаЗначений - таблица движений по регистру.
//  ИмяПеременной - Строка - имя переменной документа.
//
Процедура ШагДвиженияДокументаПоРегистру(Конструктор, ДанныеДвижений, ИмяПеременной)
	
	Для Каждого Запись Из ДанныеДвижений Цикл
		Конструктор.ПереносСтроки()
			.НоваяСтрока("// Движения по регистру " + Запись.Ключ)
			.НоваяСтрокаПоШаблону("ЮТест.Данные().КонструкторДвижений(%1, ""%2"")", ИмяПеременной, Запись.Ключ);
		
//		ШагЗаполненияТаблицы(Конструктор, Запись.Значение);
		
		Конструктор.НоваяСтрока(".Записать();");
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в конструктор текста код заполнения табличной части объекта.
//
// Параметры:
//  Контекст - Структура - контекст генерации кода.
//  ИмяТабличнойЧасти - Строка - имя табличной части.
//  Таблица - ТаблицаЗначений - данные табличной части.
//  СтруктураРеквизитовТабличнойЧасти - Структура - описание реквизитов табличной части.
//
Процедура ШагЗаполненияТабличнойЧасти(Контекст, ИмяТабличнойЧасти, Таблица, СтруктураРеквизитовТабличнойЧасти)
	
	Если ЗначениеЗаполнено(Таблица) Тогда
		Контекст.Конструктор
			.НоваяСтрокаПоШаблону(".ТабличнаяЧасть(""%1"")", ИмяТабличнойЧасти)
			.УвеличитьОтступ();
		ШагЗаполненияТаблицы(Контекст, Таблица, ЮТКоллекции.ВыгрузитьЗначения(СтруктураРеквизитовТабличнойЧасти, "Значение"));
		Контекст.Конструктор.УменьшитьОтступ();
	КонецЕсли;
	
КонецПроцедуры

// Добавляет в конструктор текста код заполнения таблицы значениями.
//
// Параметры:
//  Контекст - Структура - контекст генерации кода.
//  Таблица - ТаблицаЗначений - таблица для заполнения.
//  Колонки - КолонкиТаблицыЗначений, Неопределено - колонки таблицы для обработки.
//            Если Неопределено, используются все колонки таблицы.
//
Процедура ШагЗаполненияТаблицы(Контекст, Таблица, Знач Колонки = Неопределено)
	
	Конструктор = Контекст.Конструктор;
	
	Если Колонки = Неопределено Тогда
		Колонки = Таблица.Колонки;
	КонецЕсли;
	
	Для Каждого СтрокаДвижения Из Таблица Цикл
		
		Конструктор.НоваяСтрока(".ДобавитьСтроку()")
			.УвеличитьОтступ();
		
		Для Каждого Колонка Из Колонки Цикл
			ИмяКолонки = Колонка.Имя;
			Значение = СтрокаДвижения[ИмяКолонки];
			ШагУстановитьРеквизит(Контекст, ИмяКолонки, Значение);
		КонецЦикла;
		
		Конструктор.УменьшитьОтступ();
		
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в конструктор текста комментарий о создании объекта.
//
// Параметры:
//  Конструктор - см. ЮТРаботаСТекстом.КонструкторТекста
//  Объект - Произвольный - объект метаданных.
//  ОписаниеОбъекта - см. ЮТМетаданные.ОписаниеОбъектаМетаданных
//
Процедура ШагКомментарийОбъекта(Конструктор, Объект, ОписаниеОбъекта)
	
	Конструктор.НоваяСтрокаПоШаблону("// Создание объекта %1.%2 на основании %3",
									 ОписаниеОбъекта.ОписаниеТипа.Имя,
									 ОписаниеОбъекта.Имя,
									 Объект);
	
КонецПроцедуры

// Добавляет в конструктор текста код установки реквизитов объекта.
//
// Параметры:
//  Контекст - Структура - контекст генерации кода.
//  Объект - Произвольный - объект метаданных.
//  Реквизиты - Структура - описание реквизитов объекта.
//
Процедура ШагУстановкаРеквизитов(Контекст, Объект, Реквизиты)
	
	Для Каждого Элемент Из Реквизиты Цикл
		
		Если НЕ Элемент.Значение.Стандартный Или Элемент.Ключ = "Наименование" Тогда
			Значение = Объект[Элемент.Ключ];
			ШагУстановитьРеквизит(Контекст, Элемент.Ключ, Значение);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в конструктор текста код установки значения реквизита объекта.
//
// Параметры:
//  Контекст - Структура - контекст генерации кода.
//  Имя - Строка - имя реквизита.
//  Значение - Произвольный - значение реквизита.
//
Процедура ШагУстановитьРеквизит(Контекст, Имя, Значение)
	
	Конструктор = Контекст.Конструктор;
	НастройкиГенерации = Контекст.НастройкиГенерации;
	
	Если НЕ НастройкиГенерации.ПропускатьПустыеЗначения ИЛИ ЗначениеЗаполнено(Значение) Тогда
		Выражение = Контекст.ПодготовленныеДанные.ВыраженияСсылок[Значение];
		Если Выражение <> Неопределено Тогда
			Конструктор
				.НоваяСтрокаПоШаблону(".Установить(""%1"", %2)", Имя, Выражение);
		ИначеЕсли ЮТТипыДанныхСлужебный.ЭтоСсылочныйТип(ТипЗнч(Значение)) И НЕ Контекст.НастройкиГенерации.ИспользоватьПоиск Тогда
			Конструктор
				.НоваяСтрокаПоШаблону(".Фикция(""%1"")", Имя);
		Иначе
			Конструктор
				.НоваяСтрокаПоШаблону(".Установить(""%1"", %2)", Имя, ЗначениеВСтроку(Значение, Контекст.НастройкиГенерации));
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ТипыДанных

// Преобразует описание типов в строковое представление для использования в коде.
// Использует простую форму для типов без квалификаторов и полную форму для типов с квалификаторами.
//
// Параметры:
//  ОписаниеТипов - ОписаниеТипов - описание типов для преобразования.
//
// Возвращаемое значение:
//  Строка - строковое представление конструктора ОписаниеТипов.
//
Функция ОписаниеТиповВСтрокуКонструктор(ОписаниеТипов)
	
	// Получаем простую строку типов без квалификаторов
	МассивТипов = Новый Массив;
	Для Каждого ТекТип Из ОписаниеТипов.Типы() Цикл
		СтрокаТипа = ПредставлениеТипаБезКвалификаторов(ТекТип);
		МассивТипов.Добавить(СтрокаТипа);
	КонецЦикла;
	СтрокаТипов = СтрСоединить(МассивТипов, ", ");
	
	// Проверяем, нужно ли использовать полную форму с квалификаторами
	// Используем полную форму, если есть квалификаторы, отличные от значений по умолчанию
	ЕстьКвалификаторы = ЕстьКвалификаторыВОписанииТипов(ОписаниеТипов);
	
	Если ЕстьКвалификаторы Тогда
		
		Если ЕстьКвалификаторыЧисла(ОписаниеТипов) Тогда
			КвалификаторыЧисла = СтрШаблон("Новый КвалификаторыЧисла(%1, %2, ДопустимыйЗнак.%3)",
				ОписаниеТипов.КвалификаторыЧисла.Разрядность,
				ОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти,
				ОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак);
		Иначе
			КвалификаторыЧисла = "";
		КонецЕсли;
		
		// Для строки всегда генерируем квалификаторы, если они заданы или отличаются от значений по умолчанию
		Если ЕстьКвалификаторыСтроки(ОписаниеТипов) Тогда
			// Всегда указываем оба параметра для явно заданных квалификаторов
			КвалификаторыСтроки = СтрШаблон("Новый КвалификаторыСтроки(%1, ДопустимаяДлина.%2)",
				ОписаниеТипов.КвалификаторыСтроки.Длина,
				ОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина);
		Иначе
			КвалификаторыСтроки = "";
		КонецЕсли;
		
		Если ЕстьКвалификаторыДаты(ОписаниеТипов) Тогда
			КвалификаторыДаты = СтрШаблон("Новый КвалификаторыДаты(ЧастиДаты.%1)", ОписаниеТипов.КвалификаторыДаты.ЧастиДаты);
		Иначе
			КвалификаторыДаты = "";
		КонецЕсли;
		
		// Генерируем полную форму с конструкторами квалификаторов
		Параметры = Новый Массив;
		Параметры.Добавить("""" + СтрокаТипов + """");
		Параметры.Добавить(КвалификаторыЧисла);
		Параметры.Добавить(КвалификаторыСтроки);
		Параметры.Добавить(КвалификаторыДаты);
		
		// Удаляем пустые параметры с конца
		Пока Параметры.Количество() > 1 И Параметры[Параметры.ВГраница()] = "" Цикл
			Параметры.Удалить(Параметры.ВГраница());
		КонецЦикла;
		
		// Формируем строку параметров (пустые параметры обозначаются как пустая строка между запятыми)
		Результат = "Новый ОписаниеТипов(" + СтрСоединить(Параметры, ", ") + ")";
		
	Иначе
		
		// Простая форма без квалификаторов
		Результат = "Новый ОписаниеТипов(""" + СтрокаТипов + """)";
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Преобразует тип значения в строковое представление без квалификаторов.
//
// Параметры:
//  ТипЗначения - Тип - тип значения для преобразования.
//
// Возвращаемое значение:
//  Строка - строковое представление типа без квалификаторов.
//
Функция ПредставлениеТипаБезКвалификаторов(ТипЗначения)
	
	СтрокаТипа = "";
	
	Если ЮТТипыДанныхСлужебный.ЭтоСсылочныйТип(ТипЗначения) Тогда
		ОписаниеОбъектаМетаданных = ЮТМетаданные.ОписаниеОбъектаМетаданных(ТипЗначения);
		СтрокаТипа = СтрШаблон("%1Ссылка.%2", ОписаниеОбъектаМетаданных.ОписаниеТипа.Имя, ОписаниеОбъектаМетаданных.Имя);
	Иначе
		СтрокаТипа = Строка(ТипЗначения);
	КонецЕсли;
	
	Возврат СтрокаТипа;
	
КонецФункции

// Проверяет, нужно ли использовать полную форму конструктора ОписаниеТипов.
// Полная форма используется, если есть квалификаторы, отличные от значений по умолчанию.
//
// Параметры:
//  ОписаниеТипов - ОписаниеТипов - описание типов для проверки.
//
// Возвращаемое значение:
//  Булево - Истина, если нужно использовать полную форму конструктора.
//
Функция ЕстьКвалификаторыВОписанииТипов(ОписаниеТипов)
	
	Возврат ЕстьКвалификаторыЧисла(ОписаниеТипов) ИЛИ ЕстьКвалификаторыСтроки(ОписаниеТипов) ИЛИ ЕстьКвалификаторыДаты(ОписаниеТипов);
	
КонецФункции

Функция ЕстьКвалификаторыЧисла(ОписаниеТипов)
	
	Возврат ОписаниеТипов.КвалификаторыЧисла <> Неопределено
		И (ОписаниеТипов.КвалификаторыЧисла.Разрядность > 0
			Или ОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти > 0
			Или ОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак <> ДопустимыйЗнак.Любой);
	
КонецФункции

Функция ЕстьКвалификаторыСтроки(ОписаниеТипов)
	
	Возврат ОписаниеТипов.КвалификаторыСтроки <> Неопределено
		И (ОписаниеТипов.КвалификаторыСтроки.Длина > 0 Или ОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина <> ДопустимаяДлина.Переменная);
	
КонецФункции

Функция ЕстьКвалификаторыДаты(ОписаниеТипов)
	
	Возврат ОписаниеТипов.КвалификаторыДаты <> Неопределено
		И (ОписаниеТипов.КвалификаторыДаты.ЧастиДаты <> ЧастиДаты.ДатаВремя);
	
КонецФункции

#КонецОбласти

#Область АнализСсылочныхЗначений

// Собирает все ссылочные значения из объектов с подсчетом количества использований.
//
// Параметры:
//  Объекты - Массив - массив ссылок на объекты для анализа.
//
// Возвращаемое значение:
//  Соответствие из Соответствие - соответствие, где для каждого объекта хранятся его ссылочные значения:
//    * Ключ - ЛюбаяСсылка - ссылка на объект из входного массива.
//    * Значение - Соответствие из Число - ссылочные значения для данного объекта:
//      * Ключ - ЛюбаяСсылка - ссылочное значение.
//      * Значение - Число - количество использований в данном объекте.
Функция СобратьСсылочныеЗначенияПоОбъектам(Объекты)
	
	СсылочныеЗначенияПоОбъектам = Новый Соответствие;
	
	Для Каждого Объект Из Объекты Цикл
		
		ОписаниеОбъекта = ЮТМетаданные.ОписаниеОбъектаМетаданных(Объект.Ссылка);
		
		Если ОписаниеОбъекта = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СсылочныеЗначенияОбъекта = Новый Соответствие;
		
		// Анализ реквизитов объекта
		ИзвлечьСсылкиИзРеквизитов(СсылочныеЗначенияОбъекта, Объект, ОписаниеОбъекта.Реквизиты);
		
		// Анализ табличных частей объекта
		Для Каждого ЭлементТабличнойЧасти Из ОписаниеОбъекта.ТабличныеЧасти Цикл
			Таблица = Объект[ЭлементТабличнойЧасти.Ключ];
			Если ЗначениеЗаполнено(Таблица) Тогда
				ИзвлечьСсылкиИзТабличнойЧасти(СсылочныеЗначенияОбъекта, Таблица, ЮТКоллекции.ВыгрузитьЗначения(ЭлементТабличнойЧасти.Значение, "Значение"));
			КонецЕсли;
		КонецЦикла;
		
		СсылочныеЗначенияПоОбъектам.Вставить(Объект.Ссылка, СсылочныеЗначенияОбъекта);
		
	КонецЦикла;
	
	Возврат СсылочныеЗначенияПоОбъектам;
	
КонецФункции

// Извлекает ссылочные значения из реквизитов объекта.
//
// Параметры:
//  СсылочныеЗначения - Соответствие из Число- результирующее соответствие ссылочных значений для объекта.
//  Объект - Произвольный - объект для анализа реквизитов.
//  Реквизиты - Структура - описание реквизитов объекта.
//
Процедура ИзвлечьСсылкиИзРеквизитов(СсылочныеЗначения, Объект, Реквизиты)
	
	Для Каждого Элемент Из Реквизиты Цикл
		
		Если НЕ Элемент.Значение.Стандартный Тогда
			
			Значение = Объект[Элемент.Ключ];
			
			Если ЗначениеЗаполнено(Значение) И ЮТТипыДанныхСлужебный.ЭтоСсылочныйТип(ТипЗнч(Значение)) Тогда
				
				Если СсылочныеЗначения.Получить(Значение) = Неопределено Тогда
					СсылочныеЗначения.Вставить(Значение, 1);
				Иначе
					СсылочныеЗначения[Значение] = СсылочныеЗначения[Значение] + 1;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Извлекает ссылочные значения из табличной части объекта.
// 
// Параметры:
//  СсылочныеЗначения - Соответствие из Число - результирующее соответствие ссылочных значений для объекта.
//  Таблица - ТаблицаЗначений - табличная часть объекта.
//  Колонки - Массив из КолонкаТаблицыЗначений, Неопределено - Колонки
Процедура ИзвлечьСсылкиИзТабличнойЧасти(СсылочныеЗначения, Таблица, Колонки = Неопределено)
	
	Если Колонки = Неопределено Тогда
		Колонки = Таблица.Колонки;
	КонецЕсли;
	
	Для Каждого СтрокаТаблицы Из Таблица Цикл
		
		Для Каждого Колонка Из Колонки Цикл
			
			Значение = СтрокаТаблицы[Колонка.Имя];
			
			Если ЗначениеЗаполнено(Значение) И ЮТТипыДанныхСлужебный.ЭтоСсылочныйТип(ТипЗнч(Значение)) Тогда
				
				Если СсылочныеЗначения.Получить(Значение) = Неопределено Тогда
					СсылочныеЗначения.Вставить(Значение, 1);
				Иначе
					СсылочныеЗначения[Значение] = СсылочныеЗначения[Значение] + 1;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Определяет порядок генерации объектов на основе зависимостей.
//
// Параметры:
//  СсылкиНаОбъекты - Массив - массив ссылок на объекты для генерации.
//  СсылочныеЗначенияПоОбъектам - Соответствие - собранные ссылочные значения, сгруппированные по объектам
//    (результат функции СобратьСсылочныеЗначенияПоОбъектам).
//
// Возвращаемое значение:
//  Массив - упорядоченный массив ссылок на объекты в порядке их генерации.
//
Функция ОпределитьПорядокГенерации(СсылкиНаОбъекты, СсылочныеЗначенияПоОбъектам)
	
	Результат = Новый Массив;

	МножествоОбъектов = Новый Соответствие;
	Для Каждого СсылкаНаОбъект Из СсылкиНаОбъекты Цикл
		МножествоОбъектов.Вставить(СсылкаНаОбъект, Истина);
	КонецЦикла;

	ДляОбработки = ЮТКоллекции.СкопироватьМассив(СсылкиНаОбъекты);
	
	Пока ЗначениеЗаполнено(ДляОбработки) Цикл
		
		СсылкаНаОбъект = НайтиОбъектБезНеобработанныхЗависимостей(ДляОбработки, СсылочныеЗначенияПоОбъектам, МножествоОбъектов);
		
		Если СсылкаНаОбъект = Неопределено Тогда
			ЮТКоллекции.ДополнитьМассив(Результат, ДляОбработки);
			Прервать;
		КонецЕсли;
		
		Результат.Добавить(СсылкаНаОбъект);
		МножествоОбъектов.Удалить(СсылкаНаОбъект);
		ДляОбработки.Удалить(ДляОбработки.Найти(СсылкаНаОбъект));
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Находит объект без необработанных зависимостей.
//
// Параметры:
//  ДляОбработки - Массив - массив объектов для обработки.
//  СсылочныеЗначенияПоОбъектам - Соответствие - ссылочные значения по объектам.
//  МножествоОбъектов - Соответствие - множество еще не обработанных объектов.
//
// Возвращаемое значение:
//  ЛюбаяСсылка - ссылка на найденный объект, или Неопределено, если такой объект не найден.
//
Функция НайтиОбъектБезНеобработанныхЗависимостей(ДляОбработки, СсылочныеЗначенияПоОбъектам, МножествоОбъектов)
	
	Для Каждого СсылкаНаОбъект Из ДляОбработки Цикл
		
		СсылочныеЗначенияОбъекта = СсылочныеЗначенияПоОбъектам.Получить(СсылкаНаОбъект);
		
		Если ВсеЗависимостиОбработаны(СсылочныеЗначенияОбъекта, МножествоОбъектов) Тогда
			Возврат СсылкаНаОбъект;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Проверяет, все ли зависимости объекта уже обработаны.
//
// Параметры:
//  СсылочныеЗначенияОбъекта - Соответствие - ссылочные значения объекта.
//  МножествоОбъектов - Соответствие - множество еще не обработанных объектов.
//
// Возвращаемое значение:
//  Булево - Истина, если все зависимости обработаны, иначе Ложь.
//
Функция ВсеЗависимостиОбработаны(СсылочныеЗначенияОбъекта, МножествоОбъектов)
	
	Если СсылочныеЗначенияОбъекта = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Для Каждого СсылочноеЗначение Из СсылочныеЗначенияОбъекта Цикл
		Если МножествоОбъектов.Получить(СсылочноеЗначение.Ключ) <> Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Подсчитывает общее количество использований каждой ссылки во всех объектах.
//
// Параметры:
//  СсылочныеЗначенияПоОбъектам - Соответствие из Соответствие - ссылочные значения, сгруппированные по объектам:
//    * Ключ - ЛюбаяСсылка - ссылка на объект.
//    * Значение - Соответствие из Число - ссылочные значения для объекта:
//      * Ключ - ЛюбаяСсылка - ссылочное значение.
//      * Значение - Число - количество использований в данном объекте.
//
// Возвращаемое значение:
//  Соответствие из Число - общее количество использований каждой ссылки:
//    * Ключ - ЛюбаяСсылка - ссылочное значение.
//    * Значение - Число - общее количество использований.
//
Функция ПосчитатьСсылки(СсылочныеЗначенияПоОбъектам)
	
	СчетчикСсылок = Новый Соответствие;
	Для Каждого ЭлементПоОбъекту Из СсылочныеЗначенияПоОбъектам Цикл
		
		Для Каждого СсылочныеЗначение Из ЭлементПоОбъекту.Значение Цикл
			Количество = СчетчикСсылок[СсылочныеЗначение.Ключ];
			Если Количество <> Неопределено Тогда
				СчетчикСсылок[СсылочныеЗначение.Ключ] = Количество + СсылочныеЗначение.Значение;
			Иначе
				СчетчикСсылок[СсылочныеЗначение.Ключ] = СсылочныеЗначение.Значение;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат СчетчикСсылок;
	
КонецФункции

// Преобразует все ссылочные значения в строковое представление.
//
// Параметры:
//  СчетчикСсылок - Соответствие из Число - собранные ссылочные значения
//  ПараметрыГенерацииКода - см. ЮТГенераторКода.ПараметрыГенерацииКода
//
// Возвращаемое значение:
//  Соответствие из Строка - выражения по ссылкам
Функция ВыраженияПоСсылкам(СчетчикСсылок, ПараметрыГенерацииКода)
	
	Выражения = Новый Соответствие;
	
	ИспользоватьПоиск = ПараметрыГенерацииКода.ИспользоватьПоиск;
	ПостоянныеДанные = ПараметрыГенерацииКода.ПостоянныеДанные;
	КодИнициализацииПоТипам = ПараметрыГенерацииКода.КодИнициализацииПоТипам;
	ИспользоватьНастройкуПостоянныеДанные = ПараметрыГенерацииКода.ИспользоватьНастройкуПостоянныеДанные;
	ИспользоватьКодИнициализацииПоТипам = НЕ ПараметрыГенерацииКода.ИгнорироватьКодИнициализацииПоТипам;
	
	Для Каждого ЭлементПоОбъекту Из СчетчикСсылок Цикл
		
		Значение = ЭлементПоОбъекту.Ключ;
		ТипЗначения = ТипЗнч(Значение);
		
		Если ИспользоватьКодИнициализацииПоТипам Тогда
			Выражение = ВыражениеПолученияЗначения(Значение, ТипЗначения);
			Если ЗначениеЗаполнено(Выражение) Тогда
				Выражения[Значение] = Выражение;
				Продолжить;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ИспользоватьКодИнициализацииПоТипам И КодИнициализацииПоТипам[ТипЗначения] <> Неопределено Тогда
			Выражения[Значение] = СтрШаблон(КодИнициализацииПоТипам[ТипЗначения], Строка(Значение));
		ИначеЕсли ИспользоватьНастройкуПостоянныеДанные И ПостоянныеДанные[ТипЗначения] <> Неопределено Тогда
			Описание = ЮТМетаданные.ОписаниеОбъектаМетаданных(ТипЗначения);
			Выражения[Значение] = ВыражениеПоискаСсылочногоЗначения(Значение, Описание, ПостоянныеДанные[ТипЗначения]);
		ИначеЕсли ЭлементПоОбъекту.Значение > 1 ИЛИ ИспользоватьПоиск Тогда
			Выражения[Значение] = СсылочноеЗначениеВСтроку(Значение, ПараметрыГенерацииКода);
		Иначе
			// В других случаях используется фикция значений
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Выражения;
	
КонецФункции

#КонецОбласти

#Область Переменные

// Формирует имена переменных для ссылок, которые используются несколько раз.
//
// Параметры:
//  СчетчикСсылок - Соответствие из Число - собранные ссылочные значения
//  ФорматИменованияПеременных - Строка - см. ЮТГенераторКода.ФорматИменованияПеременных
//  
// Возвращаемое значение:
//  Соответствие из ЛюбаяСсылка - соответствие имен переменных для ссылок:
//    * Ключ - Строка - имя переменной
//    * Значение - ЛюбаяСсылка - Ссылка
//
Функция СформироватьИменаПеременныхДляСсылок(СчетчикСсылок, ФорматИменованияПеременных)
	
	ИменаПеременных = Новый Соответствие;
	
	// Собираем все ссылки и подсчитываем общее количество использований
	ВсеСсылкиСКоличеством = Новый Соответствие;
	
	Для Каждого ЭлементСсылки Из СчетчикСсылок Цикл
		
		Если ЭлементСсылки.Значение > 1 Тогда
			ВсеСсылкиСКоличеством.Вставить(ЭлементСсылки.Ключ, Истина);
		КонецЕсли;
		
	КонецЦикла;
	
	ФорматыИменованияПеременных = ЮТГенераторКода.ФорматИменованияПеременных();
	
	Для Каждого ЭлементСсылки Из ВсеСсылкиСКоличеством Цикл
		
		Ссылка = ЭлементСсылки.Ключ;
		
		БазовоеИмя = ИмяПеременной(Ссылка, ФорматИменованияПеременных, ФорматыИменованияПеременных);
		ИмяПеременной = НеконфликтующееИмяПеременной(БазовоеИмя, ИменаПеременных);
		
		ИменаПеременных.Вставить(ИмяПеременной, Ссылка);
		
	КонецЦикла;
	
	Возврат ИменаПеременных;
	
КонецФункции

Функция ИмяПеременной(Ссылка, ФорматИменованияПеременных, ФорматыИменованияПеременных = Неопределено)
	
	Если ФорматыИменованияПеременных = Неопределено Тогда
		ФорматыИменованияПеременных = ЮТГенераторКода.ФорматИменованияПеременных();
	КонецЕсли;
	
	Если ФорматИменованияПеременных = ФорматыИменованияПеременных.ПоТипу Тогда
		ИмяПеременной = ЮТМетаданные.ОписаниеОбъектаМетаданных(Ссылка).Имя;
	ИначеЕсли ФорматИменованияПеременных = ФорматыИменованияПеременных.ПоПредставлению Тогда
		ИмяПеременной = НормализоватьИмяПеременной(Строка(Ссылка));
		Если ПустаяСтрока(ИмяПеременной) Тогда
			ИмяПеременной = "Ссылка";
		КонецЕсли;
	ИначеЕсли ФорматИменованияПеременных = ФорматыИменованияПеременных.ПоТипуИПредставлению Тогда
		ИмяПеременной = ЮТМетаданные.ОписаниеОбъектаМетаданных(Ссылка).Имя + НормализоватьИмяПеременной(Строка(Ссылка));
	Иначе
		ВызватьИсключение "Неподдерживаемый формат именования переменных: " + ФорматИменованияПеременных;
	КонецЕсли;
	
	Возврат ИмяПеременной;
	
КонецФункции

// Формирует неконфликтующее имя переменной, добавляя числовой суффикс при необходимости.
//
// Параметры:
//  БазовоеИмя - Строка - базовое имя переменной.
//  ИменаПеременных - Соответствие - соответствие уже используемых имен переменных.
//
// Возвращаемое значение:
//  Строка - неконфликтующее имя переменной.
//
Функция НеконфликтующееИмяПеременной(БазовоеИмя, ИменаПеременных)
	
	Суффикс = 1;
	ИмяПеременной = БазовоеИмя;
	
	Пока ИменаПеременных[ИмяПеременной] <> Неопределено Цикл
		Суффикс = Суффикс + 1;
		ИмяПеременной = БазовоеИмя + ЮТОбщий.ЧислоВСтроку(Суффикс);
	КонецЦикла;
	
	Возврат ИмяПеременной;
	
КонецФункции

// Генерирует код создания переменных для повторяющихся ссылок в начале сгенерированного кода.
//
// Параметры:
//  Контекст - Структура - контекст генерации кода.
//
Процедура ГенерацияПеременных(Контекст)
	
	Конструктор = Контекст.Конструктор;
	ПодготовленныеДанные = Контекст.ПодготовленныеДанные;
	
	Если НЕ ЗначениеЗаполнено(ПодготовленныеДанные.ИменаПеременных) Тогда
		Возврат;
	КонецЕсли;
	
	УпорядоченныеПеременные = УпорядочитьПеременные(ПодготовленныеДанные);
	
	// Генерируем код создания переменных для повторяющихся ссылок
	Для Каждого ИмяПеременной Из УпорядоченныеПеременные Цикл
		
		Значение = ПодготовленныеДанные.ИменаПеременных[ИмяПеременной];
		Выражение = ПодготовленныеДанные.ВыраженияСсылок[Значение];
		
		Если Выражение <> Неопределено Тогда
			
			Конструктор.НоваяСтрокаПоШаблону("%1 = %2;", ИмяПеременной, Выражение);
			ПодготовленныеДанные.ВыраженияСсылок[Значение] = ИмяПеременной;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Конструктор.НоваяСтрока();
	
КонецПроцедуры

// Нормализует строку представления объекта для использования в имени переменной.
// Удаляет недопустимые символы, заменяет пробелы на подчеркивания,
// добавляет префикс для имен, начинающихся с цифры.
//
// Параметры:
//  Представление - Строка - представление объекта.
//
// Возвращаемое значение:
//  Строка - нормализованное имя переменной, валидное для использования в коде 1С.
//
Функция НормализоватьИмяПеременной(Представление)
	
	Результат = СокрЛП(Представление);
	
	Если ПустаяСтрока(Результат) Тогда
		Возврат "";
	КонецЕсли;
	
	// Заменяем пробелы на подчеркивания
	Результат = СтрЗаменить(Результат, " ", "_");
	
	// Удаляем недопустимые символы, оставляем только буквы, цифры и подчеркивания
	ВременнаяСтрока = "";
	Для Инд = 1 По СтрДлина(Результат) Цикл
		
		Символ = Сред(Результат, Инд, 1);
		КодСимвола = КодСимвола(Символ);
		
		// Буквы (русские и латинские) и подчеркивание
		ЭтоПодходящийСимвол = (КодСимвола >= 1040 И КодСимвола <= 1103) // Русские буквы
			Или (КодСимвола >= 65 И КодСимвола <= 90) // A-Z
			Или (КодСимвола >= 97 И КодСимвола <= 122) // a-z
			Или КодСимвола = 95 // Подчеркивание
			Или (КодСимвола >= 48 И КодСимвола <= 57); // Цифры
		
		Если ЭтоПодходящийСимвол Тогда
			ВременнаяСтрока = ВременнаяСтрока + Символ;
		КонецЕсли;
		
	КонецЦикла;
	
	Результат = ВременнаяСтрока;
	
	// Если первый символ - цифра, добавляем префикс "Объект"
	Если СтрДлина(Результат) > 0 И КодСимвола(Сред(Результат, 1, 1)) >= 48 И КодСимвола(Сред(Результат, 1, 1)) <= 57 Тогда
		Результат = "_" + Результат;
	КонецЕсли;
	
	// Если строка пустая, используем имя по умолчанию
	Если ПустаяСтрока(Результат) Тогда
		Результат = "";
	КонецЕсли;
	
	// Проверяем валидность через ЮТСтроки
	Если НЕ ЮТСтроки.ЭтоВалидноеИмяПеременной(Результат) Тогда
		// Если имя невалидное, используем имя по умолчанию
		Результат = "";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция УпорядочитьПеременные(ПодготовленныеДанные)
	
	ПорядокСортировкиПеременных = ПорядокСортировкиПеременных();
	
	Переменные = Новый ТаблицаЗначений;
	Переменные.Колонки.Добавить("ИмяПеременной");
	Переменные.Колонки.Добавить("Тип");
	Переменные.Колонки.Добавить("Порядок");
	Переменные.Колонки.Добавить("НомерСтроки");
	
	Для Каждого ЭлементПеременной Из ПодготовленныеДанные.ИменаПеременных Цикл
		
		Значение = ЭлементПеременной.Значение;
		ТипПеременной = ТипЗнч(Значение);
		
		СтрокаПеременной = Переменные.Добавить();
		СтрокаПеременной.ИмяПеременной = ЭлементПеременной.Ключ;
		СтрокаПеременной.Тип = ТипПеременной;
		СтрокаПеременной.Порядок = ЮТКоллекции.ЗначениеСоответствия(ПорядокСортировкиПеременных, ТипПеременной, 99);
		СтрокаПеременной.НомерСтроки = Переменные.Количество();
		
	КонецЦикла;
	
	Переменные.Сортировать("Порядок УБЫВ, Тип, ИмяПеременной");
	
	Возврат Переменные.ВыгрузитьКолонку("ИмяПеременной");
	
КонецФункции

#КонецОбласти

#Область СериализацияВMarkdown

// Сериализует таблицу значений в формат Markdown и добавляет код в конструктор текста.
//
// Параметры:
//  Конструктор - см. ЮТРаботаСТекстом.КонструкторТекста - конструктор текста.
//  Данные - ТаблицаЗначений - таблица для сериализации.
//  ИмяПеременной - Строка - имя переменной для таблицы в сгенерированном коде.
//
Процедура СериализоватьТаблицуВMarkdown(Конструктор, Данные, ИмяПеременной)
	
	СериализованныеДанные = Новый ТаблицаЗначений();
	Для Каждого Колонка Из Данные.Колонки Цикл
		СериализованныеДанные.Колонки.Добавить(Колонка.Имя, Новый ОписаниеТипов("Строка"), , СтрДлина(Колонка.Имя));
	КонецЦикла;
	
	Для Каждого Строка Из Данные Цикл
		
		НоваяСтрока = СериализованныеДанные.Добавить();
		Для Инд = 0 По Данные.Колонки.Количество() - 1 Цикл
			НоваяСтрока[Инд] = ЗначениеВСтрокуMarkdown(Строка[Инд]);
			СериализованныеДанные.Колонки[Инд].Ширина = Макс(СериализованныеДанные.Колонки[Инд].Ширина, СтрДлина(НоваяСтрока[Инд]));
		КонецЦикла;
		
	КонецЦикла;
	
	Конструктор.НоваяСтрока(ИмяПеременной + " = ");
	ЗаголовокТаблицыВMarkdown(Конструктор, СериализованныеДанные.Колонки, Символы.Таб);
	
	Для Каждого Строка Из СериализованныеДанные Цикл
		СтрокаТаблицыВMarkdown(Конструктор, Строка, СериализованныеДанные.Колонки, Символы.Таб);
	КонецЦикла;
	
	Конструктор.ДобавитьВКонецСтроки(""";");
	
КонецПроцедуры

// Добавляет в конструктор текста заголовок таблицы в формате Markdown.
//
// Параметры:
//  Конструктор - см. ЮТРаботаСТекстом.КонструкторТекста - конструктор текста.
//  Колонки - КолонкиТаблицыЗначений - колонки таблицы.
//  Префикс - Строка - префикс для каждой строки (например, табуляция).
//
Процедура ЗаголовокТаблицыВMarkdown(Конструктор, Колонки, Префикс)
	
	ДанныеСтроки = Новый Массив;
	ДанныеСтроки.Добавить(Префикс + """|");
	
	Для Каждого Колонка Из Колонки Цикл
		Ячейка = СтрШаблон(" %1 |", ЮТСтроки.ДополнитьСправа(Колонка.Имя, Колонка.Ширина));
		ДанныеСтроки.Добавить(Ячейка);
	КонецЦикла;
	
	Конструктор.НоваяСтрока(СтрСоединить(ДанныеСтроки));
	
	// Разделитель
	ДанныеСтроки = Новый Массив;
	ДанныеСтроки.Добавить(Префикс + "||");
	
	Для Каждого Колонка Из Колонки Цикл
		Ячейка = СтрШаблон(" %1 |", ЮТСтроки.СтрокаСимволов("-", Колонка.Ширина));
		ДанныеСтроки.Добавить(Ячейка);
	КонецЦикла;
	
	Конструктор.НоваяСтрока(СтрСоединить(ДанныеСтроки));
	
КонецПроцедуры

// Добавляет в конструктор текста строку таблицы в формате Markdown.
//
// Параметры:
//  Конструктор - см. ЮТРаботаСТекстом.КонструкторТекста - конструктор текста.
//  СтрокаДанных - СтрокаТаблицыЗначений - строка таблицы для добавления.
//  Колонки - КолонкиТаблицыЗначений - колонки таблицы.
//  Префикс - Строка - префикс для строки (например, табуляция).
//
Процедура СтрокаТаблицыВMarkdown(Конструктор, СтрокаДанных, Колонки, Префикс)
	
	ДанныеСтроки = Новый Массив;
	ДанныеСтроки.Добавить(Префикс + "||");
	
	Для Инд = 0 По Колонки.Количество() - 1 Цикл
		Ячейка = СтрШаблон(" %1 |", ЮТСтроки.ДополнитьСправа(СтрокаДанных[Инд], Колонки[Инд].Ширина));
		ДанныеСтроки.Добавить(Ячейка);
	КонецЦикла;
	
	Конструктор.НоваяСтрока(СтрСоединить(ДанныеСтроки));
	
КонецПроцедуры

// Преобразует значение в строковое представление для использования в таблице Markdown.
//
// Параметры:
//  Значение - Произвольный - значение для преобразования.
//
// Возвращаемое значение:
//  Строка - строковое представление значения для таблицы Markdown.
//
Функция ЗначениеВСтрокуMarkdown(Значение)
	
	Результат = "";
	
	Если НЕ ЗначениеЗаполнено(Значение) Тогда
		Возврат Результат;
	КонецЕсли;
	
	ТекТип = ТипЗнч(Значение);
	
	Если ТекТип = Тип("Булево") Тогда
		
		Результат = Формат(Значение, "БЛ=Ложь; БИ=Истина");
		
	ИначеЕсли ТекТип = Тип("Строка") Тогда
		
		Результат = ЭкранированиеСтроки(Значение);
		
	ИначеЕсли ТекТип = Тип("Число") Тогда
		
		Результат = Формат(Значение, "ЧГ=;ЧРД='.'");
		
	ИначеЕсли ТекТип = Тип("Дата") Тогда
		
		Результат = Формат(Значение, "ДФ='гггг.ММ.дд ЧЧ:мм:сс';");
		
	ИначеЕсли ЮТТипыДанныхСлужебный.ЭтоСистемноеПеречисление(ТекТип) Тогда
		
		Результат = Строка(Значение);
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТекТип) Тогда
		
		МетаданныеТипа = Метаданные.НайтиПоТипу(ТекТип);
		ИмяПеречисления = МетаданныеТипа.Имя;
		Индекс = Перечисления[ИмяПеречисления].Индекс(Значение);
		Результат = Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[Индекс].Имя;
		
	ИначеЕсли ЮТТипыДанныхСлужебный.ЭтоСсылочныйТип(ТекТип) Тогда
		
		ОписаниеОбъектаМетаданных = ЮТМетаданные.ОписаниеОбъектаМетаданных(ТекТип);
		
		Если ОписаниеОбъектаМетаданных = Неопределено Тогда
			Результат = СтрШаблон("!Тип (%1) не поддерживается!", ТекТип);
		ИначеЕсли ОписаниеОбъектаМетаданных.ОписаниеТипа.Предопределенные И Значение.Предопределенный Тогда
			Результат = Значение.ИмяПредопределенныхДанных;
		ИначеЕсли ЮТМетаданные.ЭтоДокумент(ОписаниеОбъектаМетаданных) Тогда
			Результат = СокрЛП(Значение.Номер);
		ИначеЕсли ЮТМетаданные.ЭтоПланСчетов(ОписаниеОбъектаМетаданных) И ОписаниеОбъектаМетаданных.Реквизиты.Свойство("Код") Тогда
			Результат = СокрЛП(Значение.Код);
		Иначе
			Результат = ЭкранированиеСтроки(Значение.Наименование); // Замена одной кавычки на две
		КонецЕсли;
		
	Иначе
		
		Результат = СтрШаблон("!Тип (%1) не поддерживается!", ТекТип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Сериализация

Функция ВыражениеПримитивногоЗначения(Значение, ТипЗначения)
	
	Результат = Неопределено;
	
	Если ТипЗначения = Тип("Булево") Тогда
		
		Результат = Формат(Значение, "БЛ=Ложь; БИ=Истина");
		
	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		
		ЭкранированноеНаименование = ЭкранированиеСтроки(Значение);
		Результат = СтрШаблон("""%1""", ЭкранированноеНаименование);
		
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		
		Результат = Формат(Значение, "ЧРД=.; ЧН=0; ЧГ=;");
		
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		
		Результат = "'" + Формат(Значение, "ДФ='гггг.ММ.дд ЧЧ:мм:сс';") + "'";
		
	ИначеЕсли ТипЗначения = Тип("ОписаниеТипов") Тогда
		
		Результат = ОписаниеТиповВСтрокуКонструктор(Значение);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ВыражениеПредопределенногоСсылочногоЗначения(Значение, ОписаниеОбъекта)
	
	Результат = Неопределено;
	
	Если НЕ ЗначениеЗаполнено(Значение) Тогда
		Результат = СтрШаблон("%1.%2.ПустаяСсылка()", ОписаниеОбъекта.ОписаниеТипа.ИмяКоллекции, ОписаниеОбъекта.Имя);
	ИначеЕсли ЮТМетаданные.ЭтоПеречисление(ОписаниеОбъекта) Тогда
		
		Индекс = Перечисления[ОписаниеОбъекта.Имя].Индекс(Значение);
		ИмяЗначенияПеречисления = Метаданные.Перечисления[ОписаниеОбъекта.Имя].ЗначенияПеречисления[Индекс].Имя;
		Результат = СтрШаблон("Перечисления.%1.%2", ОписаниеОбъекта.Имя, ИмяЗначенияПеречисления);
		
	ИначеЕсли ОписаниеОбъекта.ОписаниеТипа.Предопределенные И Значение.Предопределенный Тогда
		
		Результат = СтрШаблон("%1.%2.%3", ОписаниеОбъекта.ОписаниеТипа.ИмяКоллекции, ОписаниеОбъекта.Имя, Значение.ИмяПредопределенныхДанных);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ВыражениеПоискаСсылочногоЗначения(Значение, ОписаниеОбъекта, Знач РеквизитПоиска = Неопределено)
	
	Если ЮТМетаданные.ЭтоДокумент(ОписаниеОбъекта) Тогда
		Результат = СтрШаблон("Документы.%1.НайтиПоНомеру(""%2"", '%3')",
							  ОписаниеОбъекта.Имя,
							  СокрЛП(Значение.Номер),
							  Формат(Значение.Дата, "ДФ='гггг.ММ.дд ЧЧ:мм:сс';"));
		
	Иначе
		ОбъектМетаданныхПуть = СтрШаблон("%1.%2", ОписаниеОбъекта.ОписаниеТипа.ИмяКоллекции, ОписаниеОбъекта.Имя);
		
		Если РеквизитПоиска = Неопределено Тогда
			РеквизитПоиска = ?(ОписаниеОбъекта.Реквизиты.Свойство("Код"), "Код", "Наименование");
		КонецЕсли;
		
		Если РеквизитПоиска = "Код" Тогда
			Результат = СтрШаблон("%1.НайтиПоКоду(""%2"")", ОбъектМетаданныхПуть, Значение.Код);
		ИначеЕсли РеквизитПоиска = "Наименование" Тогда
			ЭкранированноеНаименование = ЭкранированиеСтроки(Значение.Наименование);
			Результат = СтрШаблон("%1.НайтиПоНаименованию(""%2"", Истина)", ОбъектМетаданныхПуть, ЭкранированноеНаименование);
		Иначе
			ВызватьИсключение СтрШаблон("Неподдерживаемый реквизит поиска %1 для %2", РеквизитПоиска, ОбъектМетаданныхПуть);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ВыражениеСозданияСсылочногоЗначения(Значение, ОписаниеОбъекта)
	
	ИмяМенеджера = СтрШаблон("%1.%2", ОписаниеОбъекта.ОписаниеТипа.ИмяКоллекции, ОписаниеОбъекта.Имя);
		
	Если ЮТМетаданные.ЭтоДокумент(ОписаниеОбъекта) Тогда
		Результат = СтрШаблон("ЮТест.Данные().СоздатьДокумент(""%1"")", ИмяМенеджера);
	ИначеЕсли ОписаниеОбъекта.ОписаниеТипа.Группы И Значение.ЭтоГруппа Тогда
		Результат = СтрШаблон("ЮТест.Данные().СоздатьГруппу(""%1"", ""%2"")", ИмяМенеджера, Строка(Значение));
	Иначе
		Результат = СтрШаблон("ЮТест.Данные().СоздатьЭлемент(""%1"", ""%2"")", ИмяМенеджера, Строка(Значение));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Преобразует ссылочное значение в строковое представление для использования в коде 1С.
// Использует различные способы получения ссылки в зависимости от типа объекта.
//
// Параметры:
//  Значение - ЛюбаяСсылка - ссылочное значение для преобразования.
//  ПараметрыГенерацииКода - см. ЮТГенераторКода.ПараметрыГенерацииКода
//
// Возвращаемое значение:
//  Строка - строковое представление ссылки в формате кода 1С.
//
Функция СсылочноеЗначениеВСтроку(Значение, ПараметрыГенерацииКода)
	
	Описание = ЮТМетаданные.ОписаниеОбъектаМетаданных(Значение);
	
	Если Описание = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ВыражениеПредопределенногоСсылочногоЗначения(Значение, Описание);
	
	Если Результат <> Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если ПараметрыГенерацииКода.ИспользоватьПоиск Тогда
		Результат = ВыражениеПоискаСсылочногоЗначения(Значение, Описание);
	Иначе
		Результат = ВыражениеСозданияСсылочногоЗначения(Значение, Описание);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Экранирует специальные символы в строке для использования в коде 1С и таблицах Markdown.
//
// Параметры:
//  Значение - Строка - строка для экранирования.
//
// Возвращаемое значение:
//  Строка - экранированная строка.
//
Функция ЭкранированиеСтроки(Значение)
	
	ЭкранированноеНаименование = Строка(Значение);
	ЭкранированноеНаименование = СтрЗаменить(ЭкранированноеНаименование, Символы.ПС, Символы.ПС + "|" );
	ЭкранированноеНаименование = СтрЗаменить(ЭкранированноеНаименование, "'", "''" );
	ЭкранированноеНаименование = СтрЗаменить(ЭкранированноеНаименование, """", """"""); // Замена одной кавычки на две
	
	Возврат ЭкранированноеНаименование;
	
КонецФункции

#КонецОбласти

#Область ПодключаемыеНастройки

Функция МодулиНастроек()
	
	Возврат ЮТПодключаемыеМодулиСлужебный.МодулиНастройкиКодогенерации();
	
КонецФункции

Функция КодИнициализацииПоТипам()
	
	Результат = Новый Соответствие;
	
	Для Каждого Модуль Из МодулиНастроек() Цикл
		//@skip-check empty-except-statement
		Попытка
			ЮТКоллекции.ДополнитьСтруктуру(Результат, Модуль.КодИнициализацииПоТипам());
		Исключение
			// Игнорируем ошибку
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПостоянныеДанные()
	
	Результат = Новый Соответствие;
	
	Для Каждого Модуль Из МодулиНастроек() Цикл
		//@skip-check empty-except-statement
		Попытка
			ЮТКоллекции.ДополнитьСтруктуру(Результат, Модуль.ПостоянныеДанные());
		Исключение
			// Игнорируем ошибку
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПорядокСортировкиПеременных()
	
	Результат = Новый Соответствие;
	
	Для Каждого Модуль Из МодулиНастроек() Цикл
		//@skip-check empty-except-statement
		Попытка
			ЮТКоллекции.ДополнитьСтруктуру(Результат, Модуль.ПорядокСортировкиПеременных());
		Исключение
			// Игнорируем ошибку
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ВыражениеПолученияЗначения(Значение, ТипЗначения)
	
	Для Каждого Модуль Из МодулиНастроек() Цикл
		//@skip-check empty-except-statement
		Попытка
			Результат = Модуль.ВыражениеПолученияЗначения(Значение, ТипЗначения);
			Если Результат <> Неопределено Тогда
				Возврат Результат;
			КонецЕсли;
		Исключение
			// Игнорируем ошибку
		КонецПопытки;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#КонецОбласти

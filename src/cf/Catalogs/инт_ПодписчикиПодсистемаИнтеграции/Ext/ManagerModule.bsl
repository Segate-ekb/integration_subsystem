///////////////////////////////////////////////////////////////////////////////
// инт_ПодписчикиПодсистемаИнтеграции (Модуль менеджера)
// Подписчики для отправки в другую базу с подсистемой интеграции
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Формирует сообщение для отправки
//
// Параметры:
//  ДанныеСообщения - Соответствие - Данные для сериализации
//  Подписчик - СправочникСсылка.инт_ПодписчикиПодсистемаИнтеграции - Ссылка на подписчика
//  ИдентификаторСообщения - УникальныйИдентификатор - УИД сообщения
//
// Возвращаемое значение:
//  Строка - Сериализованное сообщение
//
Функция СформироватьСообщение(ДанныеСообщения, Подписчик, ИдентификаторСообщения) Экспорт
    
    Возврат инт_КоннекторHTTP.ОбъектВJson(ДанныеСообщения);
    
КонецФункции

// Отправляет сообщение подписчику
//
// Параметры:
//  Сообщение - Структура - Данные сообщения (ИдентификаторСообщения, Подписчик, СформированноеСообщение)
//  ОтложенныеДействия - Соответствие - Для пакетной обработки
//
Процедура ОтправитьСообщение(Сообщение, ОтложенныеДействия) Экспорт
    
    // Получим поток данных, он будет необходим для отправки
    ДанныеИсходящегоСообщения = РегистрыСведений.инт_ОчередьИсходящихСообщений.ПолучитьДанныеОчередиПоИдентификатору(
        Сообщение.ИдентификаторСообщения,
        "ПотокДанных, ИсходныеДанные");
    
    ПотокДанных = ДанныеИсходящегоСообщения.ПотокДанных;
    Подписчик = Сообщение.Подписчик;
    
    СтруктураПараметровСоединения = Справочники.инт_Эндпоинты.СтруктураПараметровСоединения(Подписчик.Эндпоинт);
    
    // URL по шаблону подсистемы интеграции
    URL = СтрШаблон("%1/hs/api/v1/%2/%3",
        СтруктураПараметровСоединения.АдресРесурса,
        ПотокДанных.Код,
        Сообщение.ИдентификаторСообщения);
    
    Заголовки = Новый Соответствие;
    Заголовки.Вставить("X-Message-ID", Строка(Сообщение.ИдентификаторСообщения));
    
    Ответ = инт_КоннекторHTTP.Post(URL, Сообщение.СформированноеСообщение, Заголовки, СтруктураПараметровСоединения.Сессия);
    
    // Постобработка по коду ответа
    ВыполнитьПостПроцессинг(Подписчик, Ответ, ДанныеИсходящегоСообщения.ИсходныеДанные);
    
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Выполняет постобработку по коду состояния HTTP-ответа
//
// Параметры:
//  Подписчик - СправочникСсылка.инт_ПодписчикиПодсистемаИнтеграции - Ссылка на подписчика
//  Ответ - Структура - Ответ HTTP-сервера (КодСостояния, Тело)
//  ИсходныеДанные - ОпределяемыйТип.инт_ИсходныеДанные - Ссылка на исходные данные сообщения
//
Процедура ВыполнитьПостПроцессинг(Подписчик, Ответ, ИсходныеДанные = Неопределено)
    
    КодСостояния = Ответ.КодСостояния;
    ДвоичныеДанныеEPF = ПолучитьОбработчикПоКодуСостояния(КодСостояния, Подписчик);
    
    Попытка
        Исполнить(ДвоичныеДанныеEPF, Ответ, ИсходныеДанные, Истина);
    Исключение
        ПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()); // BSLLS:DeprecatedMethods8317-off
        СообщениеОбОшибке = СтрШаблон("При пост-обработке ответа возникла ошибка!
        |
        | Информация об ошибке: %1",
        ПредставлениеОшибки);
        
        ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.Подписчики.ПостОбработкаОтвета",
                                    УровеньЖурналаРегистрации.Ошибка,
                                    ,
                                    ,
                                    СообщениеОбОшибке);
        ВызватьИсключение;
    КонецПопытки;
    
КонецПроцедуры

Функция ПолучитьОбработчикПоКодуСостояния(КодСостояния, Подписчик)
    
    СтрокаПостПроцессинга = Подписчик.ПостПроцессинг.Найти(КодСостояния, "КодСостояния");
    
    Если СтрокаПостПроцессинга <> Неопределено Тогда
        // Проверяем дисковый кэш по хешу текста обработчика.
        ХешТекста = инт_ГенераторОбработок.ХешТекстаОбработчика(СтрокаПостПроцессинга.Обработчик);
        ИдОбъекта = Строка(Подписчик.УникальныйИдентификатор());
        КаталогОбъекта = инт_ГенераторОбработок.КаталогКэшаОбъекта(ИдОбъекта);
        ПутьКФайлу = КаталогОбъекта + ХешТекста + ".epf";
        
        Файл = Новый Файл(ПутьКФайлу);
        Если Файл.Существует() Тогда
            ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.КэшEPF",
                УровеньЖурналаРегистрации.Примечание, , Подписчик,
                СтрШаблон("ИнтСубс: Кэш-попадание (диск), код %1: %2", КодСостояния, ПутьКФайлу));
            Возврат ПутьКФайлу;
        КонецЕсли;
        
        // Кэш-промах: читаем бинарные данные из БД и записываем на диск.
        ДвоичныеДанные = СтрокаПостПроцессинга.СкомпилированныйОбработчик.Получить();
        Если ДвоичныеДанные <> Неопределено Тогда
            ДвоичныеДанные.Записать(ПутьКФайлу);
            ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.КэшEPF",
                УровеньЖурналаРегистрации.Примечание, , Подписчик,
                СтрШаблон("ИнтСубс: Кэш-промах (диск), записан из БД, код %1: %2", КодСостояния, ПутьКФайлу));
            Возврат ПутьКФайлу;
        КонецЕсли;
        
        // Компилируем заново.
        ДопПеременные = Новый Структура("Ответ,ИсходныеДанные", "", "");
        ДвоичныеДанные = инт_ГенераторОбработок.СкомпилироватьОбработку(СтрокаПостПроцессинга.Обработчик, ДопПеременные);
        ДвоичныеДанные.Записать(ПутьКФайлу);
        ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.КэшEPF",
            УровеньЖурналаРегистрации.Предупреждение, , Подписчик,
            СтрШаблон("ИнтСубс: Кэш-промах (диск+БД), скомпилирован заново, код %1: %2", КодСостояния, ПутьКФайлу));
        Возврат ПутьКФайлу;
    Иначе
        Код = ПолучитьОбработчикПоУмолчанию(КодСостояния);
        Если ПустаяСтрока(Код) Тогда
            Возврат Неопределено;
        КонецЕсли;
        ДопПеременные = Новый Структура("Ответ,ИсходныеДанные", "", "");
        Возврат инт_ГенераторОбработок.СкомпилироватьОбработку(Код, ДопПеременные);
    КонецЕсли;
    
КонецФункции

Функция ПолучитьОбработчикПоУмолчанию(КодСостояния)
    
    Обработчик = "";
    // Здесь через ИначеЕсли можно определить базовое поведение для разных кодов состояний.
    // Если их будет много - вынести в регистр
    Если НЕ (КодСостояния >= 200 И КодСостояния < 300) Тогда // BSLLS:MagicNumber-off ну коды http-то все знают
        Обработчик = "СообщениеОбОшибке = СтрШаблон(""При попытке отправки сообщения код ответа отличается от ожидаемого!
            |	|Код состояния: %1
            |	|ТелоОтвета: %2"", Ответ.КодСостояния, ПолучитьСтрокуИзДвоичныхДанных(Ответ.Тело));
            |ВызватьИсключение Строка(Ответ.Тело);";
    КонецЕсли;
    Возврат Обработчик;
    
КонецФункции

Процедура Исполнить(ДвоичныеДанныеИлиПутьEPF, Ответ, ИсходныеДанные, РазрешитьФиксациюИзменений = Ложь)
    
    Если ДвоичныеДанныеИлиПутьEPF = Неопределено Тогда
        Возврат;
    КонецЕсли;
    
    инт_ГенераторОбработок.ИсполнитьОбработкуПодписчика(ДвоичныеДанныеИлиПутьEPF, Ответ, ИсходныеДанные, РазрешитьФиксациюИзменений);
    
КонецПроцедуры

#КонецОбласти

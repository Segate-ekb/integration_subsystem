///////////////////////////////////////////////////////////////////////////////
// инт_ПодписчикиHTTP (Модуль менеджера)
// Подписчики для отправки по произвольному HTTP
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Формирует сообщение для отправки
//
// Параметры:
//  ДанныеСообщения - Соответствие - Данные для сериализации
//  Подписчик - СправочникСсылка.инт_ПодписчикиHTTP - Ссылка на подписчика
//  ИдентификаторСообщения - УникальныйИдентификатор - УИД сообщения
//
// Возвращаемое значение:
//  Строка - Сериализованное сообщение
//
Функция СформироватьСообщение(ДанныеСообщения, Подписчик, ИдентификаторСообщения) Экспорт
    
    Возврат инт_КоннекторHTTP.ОбъектВJson(ДанныеСообщения);
    
КонецФункции

// Отправляет сообщение подписчику
//
// Параметры:
//  Сообщение - Структура - Данные сообщения (ИдентификаторСообщения, Подписчик, СформированноеСообщение, ИдентификаторПотока)
//  ОтложенныеДействия - Соответствие - Для пакетной обработки
//
Процедура ОтправитьСообщение(Сообщение, ОтложенныеДействия) Экспорт
    
    ДанныеИсходящегоСообщения = РегистрыСведений.инт_ОчередьИсходящихСообщений.ПолучитьДанныеОчередиПоИдентификатору(
        Сообщение.ИдентификаторСообщения,
        "ПотокДанных, ИдентификаторСообщения, ИсходныеДанные");
    
    Подписчик = Сообщение.Подписчик;
    СтруктураПараметровСоединения = Справочники.инт_Эндпоинты.СтруктураПараметровСоединения(Подписчик.Эндпоинт);
    
    // Формируем URL с учётом способа передачи параметров
    URL = СформироватьURL(СтруктураПараметровСоединения.АдресРесурса, Подписчик, ДанныеИсходящегоСообщения);
    Заголовки = СформироватьЗаголовки(Подписчик, ДанныеИсходящегоСообщения);
    ПараметрыЗапроса = СформироватьПараметрыЗапроса(Подписчик, ДанныеИсходящегоСообщения);
    
    ДополнительныеПараметры = Новый Структура("Заголовки, ПараметрыЗапроса", Заголовки, ПараметрыЗапроса);
    
    Ответ = инт_КоннекторHTTP.Post(URL, Сообщение.СформированноеСообщение, ДополнительныеПараметры, СтруктураПараметровСоединения.Сессия);
    
    // Постобработка по коду ответа
    ВыполнитьПостПроцессинг(Подписчик, Ответ, ДанныеИсходящегоСообщения.ИсходныеДанные);
    
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Формирует URL с учётом способа передачи идентификаторов
//
// Параметры:
//  БазовыйURL - Строка - Базовый адрес ресурса из эндпоинта
//  Подписчик - СправочникСсылка.инт_ПодписчикиHTTP - Ссылка на подписчика
//  ДанныеИсходящегоСообщения - Структура - Данные исходящего сообщения
//
// Возвращаемое значение:
//  Строка - Сформированный URL
//
Функция СформироватьURL(Знач БазовыйURL, Подписчик, ДанныеИсходящегоСообщения) // BSLLS:LatinAndCyrillicSymbolInWord-off
    
    Если НЕ ЗначениеЗаполнено(БазовыйURL) Тогда
        ВызватьИсключение СтрШаблон("Не заполнена ссылка на сервис для подписчика <%1>", Подписчик);
    КонецЕсли;
    
    URL = БазовыйURL;
    
    // Замена плейсхолдеров в пути URL
    Если Подписчик.СпособПередачиИдентификатораПотока = Перечисления.инт_СпособыПередачиПараметровПоHTTP.ВПараметреПути Тогда
        URL = СтрЗаменить(URL, "{flow_id}", ДанныеИсходящегоСообщения.ПотокДанных.Код);
    КонецЕсли;
    
    Если Подписчик.СпособПередачиИдентификатораСообщения = Перечисления.инт_СпособыПередачиПараметровПоHTTP.ВПараметреПути Тогда
        URL = СтрЗаменить(URL, "{message_id}", ДанныеИсходящегоСообщения.ИдентификаторСообщения);
    КонецЕсли;
    
    Возврат URL;
    
КонецФункции

// Формирует заголовки HTTP-запроса
//
// Параметры:
//  Подписчик - СправочникСсылка.инт_ПодписчикиHTTP - Ссылка на подписчика
//  ДанныеИсходящегоСообщения - Структура - Данные исходящего сообщения
//
// Возвращаемое значение:
//  Соответствие - Заголовки запроса
//
Функция СформироватьЗаголовки(Подписчик, ДанныеИсходящегоСообщения)
    
    Заголовки = Новый Соответствие;
    
    Если Подписчик.СпособПередачиИдентификатораПотока = Перечисления.инт_СпособыПередачиПараметровПоHTTP.ВЗаголовке Тогда
        Заголовки.Вставить("flow_id", ДанныеИсходящегоСообщения.ПотокДанных.Код);
    КонецЕсли;
    
    Если Подписчик.СпособПередачиИдентификатораСообщения = Перечисления.инт_СпособыПередачиПараметровПоHTTP.ВЗаголовке Тогда
        Заголовки.Вставить("message_id", ДанныеИсходящегоСообщения.ИдентификаторСообщения);
    КонецЕсли;
    
    Возврат Заголовки;
    
КонецФункции

// Формирует параметры запроса (query string)
//
// Параметры:
//  Подписчик - СправочникСсылка.инт_ПодписчикиHTTP - Ссылка на подписчика
//  ДанныеИсходящегоСообщения - Структура - Данные исходящего сообщения
//
// Возвращаемое значение:
//  Структура - Параметры запроса
//
Функция СформироватьПараметрыЗапроса(Подписчик, ДанныеИсходящегоСообщения)
    
    ПараметрыЗапроса = Новый Структура;
    
    Если Подписчик.СпособПередачиИдентификатораПотока = Перечисления.инт_СпособыПередачиПараметровПоHTTP.ВПараметреЗапроса Тогда
        ПараметрыЗапроса.Вставить("flow_id", ДанныеИсходящегоСообщения.ПотокДанных.Код);
    КонецЕсли;
    
    Если Подписчик.СпособПередачиИдентификатораСообщения = Перечисления.инт_СпособыПередачиПараметровПоHTTP.ВПараметреЗапроса Тогда
        ПараметрыЗапроса.Вставить("message_id", ДанныеИсходящегоСообщения.ИдентификаторСообщения);
    КонецЕсли;
    
    Возврат ПараметрыЗапроса;
    
КонецФункции

// Выполняет постобработку по коду состояния HTTP-ответа
//
// Параметры:
//  Подписчик - СправочникСсылка.инт_ПодписчикиHTTP - Ссылка на подписчика
//  Ответ - Структура - Ответ HTTP-сервера (КодСостояния, Тело)
//  ИсходныеДанные - ОпределяемыйТип.инт_ИсходныеДанные - Ссылка на исходные данные сообщения
//
Процедура ВыполнитьПостПроцессинг(Подписчик, Ответ, ИсходныеДанные = Неопределено)
    
    КодСостояния = Ответ.КодСостояния;
    ДвоичныеДанныеEPF = ПолучитьОбработчикПоКодуСостояния(КодСостояния, Подписчик);
    
    Попытка
        Исполнить(ДвоичныеДанныеEPF, Ответ, ИсходныеДанные, Истина);
    Исключение
        ПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()); // BSLLS:DeprecatedMethods8317-off
        СообщениеОбОшибке = СтрШаблон("При пост-обработке ответа возникла ошибка!
        |
        | Информация об ошибке: %1",
        ПредставлениеОшибки);
        
        ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.Подписчики.ПостОбработкаОтвета",
                                    УровеньЖурналаРегистрации.Ошибка,
                                    ,
                                    ,
                                    СообщениеОбОшибке);
        ВызватьИсключение;
    КонецПопытки;
    
КонецПроцедуры

Функция ПолучитьОбработчикПоКодуСостояния(КодСостояния, Подписчик)
    
    СтрокаПостПроцессинга = Подписчик.ПостПроцессинг.Найти(КодСостояния, "КодСостояния");
    
    Если СтрокаПостПроцессинга <> Неопределено Тогда
        // Проверяем дисковый кэш по хешу текста обработчика.
        ХешТекста = инт_ГенераторОбработок.ХешТекстаОбработчика(СтрокаПостПроцессинга.Обработчик);
        ИдОбъекта = Строка(Подписчик.УникальныйИдентификатор());
        КаталогОбъекта = инт_ГенераторОбработок.КаталогКэшаОбъекта(ИдОбъекта);
        ПутьКФайлу = КаталогОбъекта + ХешТекста + ".epf";
        
        Файл = Новый Файл(ПутьКФайлу);
        Если Файл.Существует() Тогда
            ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.КэшEPF",
                УровеньЖурналаРегистрации.Примечание, , Подписчик,
                СтрШаблон("HTTP: Кэш-попадание (диск), код %1: %2", КодСостояния, ПутьКФайлу));
            Возврат ПутьКФайлу;
        КонецЕсли;
        
        // Кэш-промах: читаем бинарные данные из БД и записываем на диск.
        ДвоичныеДанные = СтрокаПостПроцессинга.СкомпилированныйОбработчик.Получить();
        Если ДвоичныеДанные <> Неопределено Тогда
            ДвоичныеДанные.Записать(ПутьКФайлу);
            ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.КэшEPF",
                УровеньЖурналаРегистрации.Примечание, , Подписчик,
                СтрШаблон("HTTP: Кэш-промах (диск), записан из БД, код %1: %2", КодСостояния, ПутьКФайлу));
            Возврат ПутьКФайлу;
        КонецЕсли;
        
        // Компилируем заново.
        ДопПеременные = Новый Структура("Ответ,ИсходныеДанные", "", "");
        ДвоичныеДанные = инт_ГенераторОбработок.СкомпилироватьОбработку(СтрокаПостПроцессинга.Обработчик, ДопПеременные);
        ДвоичныеДанные.Записать(ПутьКФайлу);
        ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.КэшEPF",
            УровеньЖурналаРегистрации.Предупреждение, , Подписчик,
            СтрШаблон("HTTP: Кэш-промах (диск+БД), скомпилирован заново, код %1: %2", КодСостояния, ПутьКФайлу));
        Возврат ПутьКФайлу;
    Иначе
        Код = ПолучитьОбработчикПоУмолчанию(КодСостояния);
        Если ПустаяСтрока(Код) Тогда
            Возврат Неопределено;
        КонецЕсли;
        ДопПеременные = Новый Структура("Ответ,ИсходныеДанные", "", "");
        Возврат инт_ГенераторОбработок.СкомпилироватьОбработку(Код, ДопПеременные);
    КонецЕсли;
    
КонецФункции

Функция ПолучитьОбработчикПоУмолчанию(КодСостояния)
    
    Обработчик = "";
    // Здесь через ИначеЕсли можно определить базовое поведение для разных кодов состояний.
    // Если их будет много - вынести в регистр
    Если НЕ (КодСостояния >= 200 И КодСостояния < 300) Тогда // BSLLS:MagicNumber-off ну коды http-то все знают
        Обработчик = "СообщениеОбОшибке = СтрШаблон(""При попытке отправки сообщения код ответа отличается от ожидаемого!
            |	|Код состояния: %1
            |	|ТелоОтвета: %2"", Ответ.КодСостояния, ПолучитьСтрокуИзДвоичныхДанных(Ответ.Тело));
            |ВызватьИсключение Строка(Ответ.Тело);";
    КонецЕсли;
    Возврат Обработчик;
    
КонецФункции

Процедура Исполнить(ДвоичныеДанныеИлиПутьEPF, Ответ, ИсходныеДанные, РазрешитьФиксациюИзменений = Ложь)
    
    Если ДвоичныеДанныеИлиПутьEPF = Неопределено Тогда
        Возврат;
    КонецЕсли;
    
    инт_ГенераторОбработок.ИсполнитьОбработкуПодписчика(ДвоичныеДанныеИлиПутьEPF, Ответ, ИсходныеДанные, РазрешитьФиксациюИзменений);
    
КонецПроцедуры

#КонецОбласти

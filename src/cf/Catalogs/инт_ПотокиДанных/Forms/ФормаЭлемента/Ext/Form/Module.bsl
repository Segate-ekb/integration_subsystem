
///////////////////////////////////////////////////////////////////////////////
// инт_ПотокиДанных.ФормаЭлемента
//  
////////////////////////////////////////////////////////////////////////////////

#Область ОбработчикиСобытийФормы

&НаКлиенте
Процедура ПриОткрытии(Отказ)

	конс_ПодключаемаяКонсольКлиент.ПодключитьРедактор(ЭтаФорма);
КонецПроцедуры

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	конс_ПодключаемаяКонсольСервер.ИнициализироватьРедактор(ЭтотОбъект, УникальныйИдентификатор, "РедакторКода");
    
    ЗаполнитьСписокВыбораИмяСхемПакета();
    ОбновитьВидимостьЭлементовФормы();

	// Десериализуем Пример в реквизит формы ПримерСсылка
    Если ЗначениеЗаполнено(Объект.Пример) Тогда
        ПримерСсылка = ЗначениеИзСтрокиВнутр(Объект.Пример);
    КонецЕсли;
КонецПроцедуры

&НаСервере
Процедура ПриЧтенииНаСервере(ТекущийОбъект)
    // Десериализуем Пример в реквизит формы ПримерСсылка при чтении существующего объекта
    Если ЗначениеЗаполнено(Объект.Пример) Тогда
        ПримерСсылка = ЗначениеИзСтрокиВнутр(Объект.Пример);
    Иначе
        ПримерСсылка = Неопределено;
    КонецЕсли;
КонецПроцедуры

&НаСервере
Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
    // Сериализуем ПримерСсылка обратно в строку
    Если ЗначениеЗаполнено(ПримерСсылка) Тогда
        ТекущийОбъект.Пример = ЗначениеВСтрокуВнутр(ПримерСсылка);
    Иначе
        ТекущийОбъект.Пример = "";
    КонецЕсли;
    
    // Компилируем обработчик в EPF (пропускаем, если текст не изменился).
    Если ЗначениеЗаполнено(ТекущийОбъект.ТекстОбработчика) Тогда
        
        ТекущийХеш = инт_ГенераторОбработок.ХешТекстаОбработчика(ТекущийОбъект.ТекстОбработчика);
        ДвоичныеДанныеEPF = Неопределено;
        
        // 1. Проверяем кэш формы (EPF уже скомпилирован при проверке и актуален по хешу текста).
        Если ТекущийХеш = ХешПоследнейКомпиляции И ЗначениеЗаполнено(АдресEPFВоВременномХранилище) Тогда
            ДвоичныеДанныеEPF = ПолучитьИзВременногоХранилища(АдресEPFВоВременномХранилище);
        КонецЕсли;
        
        // 2. Проверяем сохранённый EPF в БД.
        Если ДвоичныеДанныеEPF = Неопределено И Не ТекущийОбъект.Ссылка.Пустая() Тогда
            Если ТекущийОбъект.ТекстОбработчика = ТекущийОбъект.Ссылка.ТекстОбработчика Тогда
                ДвоичныеДанныеEPF = ТекущийОбъект.Ссылка.СкомпилированныйОбработчик.Получить();
            КонецЕсли;
        КонецЕсли;
        
        // 3. Компилируем заново.
        Если ДвоичныеДанныеEPF = Неопределено Тогда
            Попытка
                ДвоичныеДанныеEPF = инт_ГенераторОбработок.СкомпилироватьОбработку(ТекущийОбъект.ТекстОбработчика);
            Исключение
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = "Ошибка компиляции обработчика: " + ОписаниеОшибки();
                Сообщение.Сообщить();
            КонецПопытки;
        КонецЕсли;
        
        Если ДвоичныеДанныеEPF <> Неопределено Тогда
            ТекущийОбъект.СкомпилированныйОбработчик = Новый ХранилищеЗначения(ДвоичныеДанныеEPF);
            ТекущийОбъект.ДополнительныеСвойства.Вставить("ОбработчикСкомпилирован", Истина);
        КонецЕсли;
    КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПередЗаписью(Отказ, ПараметрыЗаписи)
   Объект.ТекстОбработчика = конс_ПодключаемаяКонсольКлиент.ПолучитьТекст(ЭтаФорма);
   
   ВалидироватьПередЗаписью = Истина;
   Если ПараметрыЗаписи.Свойство("ВалидироватьПередЗаписью") Тогда
	   ВалидироватьПередЗаписью = ПараметрыЗаписи.ВалидироватьПередЗаписью;
   КонецЕсли;

   Если ВалидироватьПередЗаписью Тогда
		
		ОчиститьСообщения();
		конс_ПодключаемаяКонсольКлиент.ОчиститьМаркерыОшибок(ЭтаФорма, "РедакторКода");
		
		// Сбрасываем кэш, чтобы EPF перекомпилировался из актуального текста.
		ХешПоследнейКомпиляции = "";
		
		Попытка
			ПодготовитьEPFДляПроверки();
		Исключение
			ПоказатьОшибкуВРедакторе(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
			Отказ = Истина;
			ОписаниеОповещения = Новый ОписаниеОповещения("ПослеОтветаНаВопросОЗаписи", ЭтотОбъект);
			ПоказатьВопрос(ОписаниеОповещения, "Ошибка компиляции обработчика!
			|Все равно записать?", РежимДиалогаВопрос.ДаНет, 60);
			Возврат;
		КонецПопытки;
		
		Если Не ПроверкаПрошлаУспешно() Тогда
			Отказ = Истина;
			ОписаниеОповещения = Новый ОписаниеОповещения("ПослеОтветаНаВопросОЗаписи", ЭтотОбъект);
			ПоказатьВопрос(ОписаниеОповещения, "При проверке потока обнаружены ошибки!
			|Все равно записать?", РежимДиалогаВопрос.ДаНет, 60);
		КонецЕсли;
		
   КонецЕсли;

КонецПроцедуры
#КонецОбласти

#Область ОбработчикиСобытийЭлементовШапкиФормы
&НаКлиенте
Процедура СхемаДанныхПриИзменении(Элемент)
   	ЗаполнитьСписокВыбораИмяСхемПакета();
	РедакторКодаДокументСформирован(Неопределено);
КонецПроцедуры

&НаКлиенте
Процедура ПримерПриИзменении(Элемент)
	// Сериализуем ПримерСсылка в Объект.Пример для обновления отслеживаемых реквизитов
	Если ЗначениеЗаполнено(ПримерСсылка) Тогда
		Объект.Пример = ПримерСсылкаВСтроку(ПримерСсылка);
	Иначе
		Объект.Пример = "";
	КонецЕсли;
	ПерезаполнитьОтслеживаемыеРеквизиты();
	ВизуальныеНастройкиЭлементовФормСвязанныхСОтслеживаемымиРеквизитами();
    Объект.ТекстОбработчика = конс_ПодключаемаяКонсольКлиент.ПолучитьТекст(ЭтаФорма);
    РедакторКодаДокументСформирован(Элементы.РедакторКода);
КонецПроцедуры

&НаСервереБезКонтекста
Функция ПримерСсылкаВСтроку(Ссылка)
	Возврат ЗначениеВСтрокуВнутр(Ссылка);
КонецФункции

&НаКлиенте
Процедура РедакторКодаПриНажатии(Элемент, ДанныеСобытия, СтандартнаяОбработка)
	конс_ПодключаемаяКонсольКлиент.ОбработчикПриНажатии(ЭтаФорма, ДанныеСобытия);
		
КонецПроцедуры

&НаКлиенте
Процедура РедакторКодаДокументСформирован(Элемент)
	конс_ПодключаемаяКонсольКлиент.ОбработчикДокументСформирован(ЭтаФорма);
	ДобавитьПеременные();
	УстановитьСхему();
	конс_ПодключаемаяКонсольКлиент.ЗагрузитьПользовательскийКонтекст(ЭтаФорма);
	конс_ПодключаемаяКонсольКлиент.ОчиститьТекст(ЭтаФорма);
	конс_ПодключаемаяКонсольКлиент.УстановитьТекст(ЭтаФорма, Объект.ТекстОбработчика);
КонецПроцедуры 

#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицыФормы

#КонецОбласти

#Область ОбработчикиКомандФормы
&НаКлиенте
Процедура ПроверитьПоПримеру(Команда)
	ОчиститьСообщения();
	конс_ПодключаемаяКонсольКлиент.ОчиститьМаркерыОшибок(ЭтаФорма, "РедакторКода");
	Объект.ТекстОбработчика = конс_ПодключаемаяКонсольКлиент.ПолучитьТекст(ЭтаФорма);
	
	// Подготавливаем EPF до замера производительности.
	Попытка
		ПодготовитьEPFДляПроверки();
	Исключение
		ПоказатьОшибкуВРедакторе(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат;
	КонецПопытки;
	
	НачалоЗамера = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Если ПроверкаПрошлаУспешно() Тогда
		ВремяВыполнения = ТекущаяУниверсальнаяДатаВМиллисекундах() - НачалоЗамера;
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = СтрШаблон("Проверка прошла успешно!
		|Время выполнения: %1 мс.", ВремяВыполнения);
		Сообщение.Сообщить();
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ОпределитьОтслеживаемыеРеквизиты(Команда)
	ДопПараметры = Новый Структура("ОтслеживаемыеРеквизиты, СсылкаНаОбъект", Объект.ОтслеживаемыеРеквизиты, ПримерСсылка);
	
	ОписаниеОповещения = Новый ОписаниеОповещения("ПослеЗакрытияФормыРедактированияОтслеживаемыхРеквизитов", ЭтотОбъект);
	ОткрытьФорму("Справочник.инт_ПотокиДанных.Форма.РедактированиеОтслеживаемыхРеквизитов",ДопПараметры,ЭтотОбъект,,,,ОписаниеОповещения,РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции


&НаКлиенте
Функция СобратьОписаниеОжидаемогоРезультата() Экспорт;
    
   // TODO: !!!! Собирать описание ожидаемого результата, по OpenApi Схеме!!!!
   
   Результат = Новый структура;
   
   Результат.Вставить("ref", "classes.Соответствие");
   Результат.Вставить("description", "Соответствие содержащее сериализованную и подготовленную информацию, которая сможет пройти валидацию по схеме.");
   
   СтруктураПараметра = Новый Структура("ref, name, description", "catalogs.инт_ПотокиДанных", "Dataflow", "Поток данных");
   СтруктураПараметров = Новый Структура("Dataflow", СтруктураПараметра);
   Результат.Вставить("properties", СтруктураПараметров);
   
   Возврат Результат;
	
КонецФункции

&НаСервере
Процедура ПерезаполнитьОтслеживаемыеРеквизиты()
	
	Если ЗначениеЗаполнено(Объект.ОтслеживаемыеРеквизиты) Тогда
		ИсходныеДанные = ЗначениеИзСтрокиВнутр(Объект.ОтслеживаемыеРеквизиты);
	Иначе
		ИсходныеДанные = Неопределено;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПримерСсылка) Тогда
		Объект.ОтслеживаемыеРеквизиты = ЗначениеВСтрокуВнутр(Справочники.инт_ПотокиДанных.ЗаполнитьДеревоРеквизитовПоСсылке(ПримерСсылка, ИсходныеДанные));
	КонецЕсли;
	
КонецПроцедуры



// Подготовка EPF: компиляция или получение из кэша.
// Вызывается до замера производительности, чтобы компиляция не влияла на замер.
&НаСервере
Процедура ПодготовитьEPFДляПроверки()
	
	ТекущийХеш = инт_ГенераторОбработок.ХешТекстаОбработчика(Объект.ТекстОбработчика);
	
	// Если хеш совпадает — EPF уже в кэше формы, ничего не делаем.
	Если ТекущийХеш = ХешПоследнейКомпиляции И ЗначениеЗаполнено(АдресEPFВоВременномХранилище) Тогда
		Возврат;
	КонецЕсли;
	
	ДвоичныеДанныеEPF = Неопределено;
	
	// Проверяем сохранённый EPF в БД.
	Если Не Объект.Ссылка.Пустая() Тогда
		Если Объект.ТекстОбработчика = Объект.Ссылка.ТекстОбработчика Тогда
			ДвоичныеДанныеEPF = Объект.Ссылка.СкомпилированныйОбработчик.Получить();
		КонецЕсли;
	КонецЕсли;
	
	// Компилируем заново.
	Если ДвоичныеДанныеEPF = Неопределено Тогда
		СмещенияМодуля = Неопределено;
		ДвоичныеДанныеEPF = инт_ГенераторОбработок.СкомпилироватьОбработку(Объект.ТекстОбработчика, , , СмещенияМодуля);
		Если СмещенияМодуля <> Неопределено Тогда
			СмещениеТелаКода = СмещенияМодуля.СмещениеТелаКода;
			СмещениеПроцедур = СмещенияМодуля.СмещениеПроцедур;
		КонецЕсли;
	КонецЕсли;
	
	// Сохраняем в кэш формы.
	АдресEPFВоВременномХранилище = ПоместитьВоВременноеХранилище(ДвоичныеДанныеEPF, УникальныйИдентификатор);
	ХешПоследнейКомпиляции = ТекущийХеш;
	
КонецПроцедуры

// Исполнение обработчика. Замер производительности оборачивает только этот вызов.
&НаСервере
Процедура ПроверитьПоПримеруНаСервере()
	
	ДвоичныеДанныеEPF = ПолучитьИзВременногоХранилища(АдресEPFВоВременномХранилище);
	
	Если Объект.НаправлениеПотока = Перечисления.инт_НаправлениеПотокаДанных.Исходящий Тогда
		Результат = инт_ГенераторОбработок.ИсполнитьОбработку(ДвоичныеДанныеEPF, ПримерСсылка);
		
		Если Объект.Валидация Тогда
			Справочники.инт_ПотокиДанных.ВалидироватьСообщениеПоПотоку(Результат, Объект);
		КонецЕсли;
	Иначе
		Соответствие = ДесериализоватьИВалидироватьТестовыеДанные();
		Если Соответствие = Неопределено Тогда
			Возврат;
		КонецЕсли;
		инт_ГенераторОбработок.ИсполнитьОбработку(ДвоичныеДанныеEPF, Соответствие, Ложь);
	КонецЕсли;
КонецПроцедуры

&НаСервере
Функция ДесериализоватьИВалидироватьТестовыеДанные()
	Попытка
		Соответствие = инт_КоннекторHTTP.JsonВОбъект(ТестовыеДанные);
	Исключение
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = "Не удалось разобрать Json.";
		Сообщение.Поле = "ТестовыеДанные";
		Сообщение.Сообщить();
		Возврат Неопределено;
	КонецПопытки;
	
	Справочники.инт_ПотокиДанных.ВалидироватьСообщениеПоПотоку(Соответствие, Объект);
	Возврат Соответствие;
КонецФункции
       
&НаСервере
Процедура ЗаполнитьСписокВыбораИмяСхемПакета()
    Элементы.ИмяСхемыПакета.СписокВыбора.ЗагрузитьЗначения(Справочники.инт_Схемы.МассивИменПакетовПоСхеме(Объект.СхемаДанных));
КонецПроцедуры

&НаСервере
Процедура ОбновитьВидимостьЭлементовФормы()
    
	ЭтоВходящийПоток = Объект.НаправлениеПотока = Перечисления.инт_НаправлениеПотокаДанных.Входящий;
	ЭтоИсходящийПоток = Объект.НаправлениеПотока = Перечисления.инт_НаправлениеПотокаДанных.Исходящий;
	
	Элементы.АсинхроннаяОбработка.Видимость = ЭтоВходящийПоток;
    Элементы.ГруппаПодписчики.Видимость = ЭтоИсходящийПоток;
    Элементы.ГруппаПример.Видимость = ЭтоИсходящийПоток;
	Элементы.ТестовыеДанные.Видимость = ЭтоВходящийПоток;
	Элементы.ГруппаПодпискиВходящие.Видимость = ЭтоВходящийПоток;
	
	ВизуальныеНастройкиЭлементовФормСвязанныхСОтслеживаемымиРеквизитами();
КонецПроцедуры

&НаСервере
Процедура ВизуальныеНастройкиЭлементовФормСвязанныхСОтслеживаемымиРеквизитами()
	Элементы.ОпределитьОтслеживаемыеРеквизиты.Видимость = ЗначениеЗаполнено(Объект.ОтслеживаемыеРеквизиты);
	Если Не ЗначениеЗаполнено(Объект.ОтслеживаемыеРеквизиты) Тогда
		Возврат;
	КонецЕсли;
	
	Дерево = ЗначениеИзСтрокиВнутр(Объект.ОтслеживаемыеРеквизиты);
	
	Если НЕ Дерево.Строки.Найти(2, "ОтслеживатьИзменения", Истина) = Неопределено Тогда
		Элементы.ОпределитьОтслеживаемыеРеквизиты.Заголовок = "Список отслеживаемых реквизитов";
		Элементы.ОпределитьОтслеживаемыеРеквизиты.Картинка = БиблиотекаКартинок.ВыбратьЗначение;
		Элементы.ПредупреждениеОбОтслеживаемыхРеквизитах.Видимость = Истина;
		Элементы.ПредупреждениеОбОтслеживаемыхРеквизитах.Заголовок = "Внимание! Отслеживается изменение только части реквизитов!";
		Элементы.ПредупреждениеОбОтслеживаемыхРеквизитах.ЦветТекста = ЦветаСтиля.ЦветАкцента;
	ИначеЕсли Дерево.Строки.Найти(1, "ОтслеживатьИзменения", Истина) = Неопределено Тогда
		Элементы.ОпределитьОтслеживаемыеРеквизиты.Заголовок = "Список отслеживаемых реквизитов";
		Элементы.ОпределитьОтслеживаемыеРеквизиты.Картинка = БиблиотекаКартинок.ВыбратьЗначение;
		Элементы.ПредупреждениеОбОтслеживаемыхРеквизитах.Видимость = Истина;
		Элементы.ПредупреждениеОбОтслеживаемыхРеквизитах.Заголовок = "Ошибка! В списке отслеживаемых реквизитов нет ни одного значения!";
		Элементы.ПредупреждениеОбОтслеживаемыхРеквизитах.ЦветТекста = ЦветаСтиля.ЦветОсобогоТекста;
	Иначе
		Элементы.ОпределитьОтслеживаемыеРеквизиты.Заголовок = "Отслеживаются любые изменения";
		Элементы.ОпределитьОтслеживаемыеРеквизиты.Картинка = БиблиотекаКартинок.СинтаксическийКонтроль;
		Элементы.ПредупреждениеОбОтслеживаемыхРеквизитах.Видимость = Ложь;
	КонецЕсли;
	Элементы.ОпределитьОтслеживаемыеРеквизиты.Доступность = ЗначениеЗаполнено(ПримерСсылка);
КонецПроцедуры

&НаКлиенте
Процедура НаправлениеПотокаПриИзменении(Элемент)
    ОбновитьВидимостьЭлементовФормы();
	РедакторКодаДокументСформирован(Неопределено);
КонецПроцедуры

&НаКлиенте
Функция ПроверкаПрошлаУспешно()
	Успех = Истина; 

	Попытка
		ПроверитьПоПримеруНаСервере();
	Исключение
		ПоказатьОшибкуВРедакторе(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()), Истина);
		Успех = Ложь;
	КонецПопытки;
	
	Возврат Успех;
КонецФункции

//Вынести в отдельную процедуру
&НаКлиенте
Процедура ПослеОтветаНаВопросОЗаписи(РезультатВопроса, ДополнительныеПараметры) Экспорт
	
	Если РезультатВопроса = КодВозвратаДиалога.Да Тогда
		Записать(Новый Структура("ВалидироватьПередЗаписью", Ложь));
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ПослеЗакрытияФормыРедактированияОтслеживаемыхРеквизитов(ОтслеживаемыеРеквизиты, ДополнительныеПараметры) Экспорт
	Если ЗначениеЗаполнено(ОтслеживаемыеРеквизиты) Тогда
		Объект.ОтслеживаемыеРеквизиты = ОтслеживаемыеРеквизиты;
	КонецЕсли;
	
	ВизуальныеНастройкиЭлементовФормСвязанныхСОтслеживаемымиРеквизитами();
КонецПроцедуры

&НаСервере
Процедура ДобавитьПеременные()
	
	// Очищаем предыдущие переменные — при смене направления набор переменных меняется
	ОчиститьПеременныеКонтекста();
	
	Если Объект.НаправлениеПотока = Перечисления.инт_НаправлениеПотокаДанных.Исходящий Тогда
		конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(ЭтотОбъект, "Результат", Новый Соответствие,
			"Возврат результата обработки");
		конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(ЭтотОбъект, "ИсходныеДанные", ПримерСсылка,
			"Ссылка на обрабатываемый объект");
	Иначе
		конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(ЭтотОбъект, "ИсходныеДанные", Тип("Соответствие"),
			"Десериализованный JSON входящего сообщения (Соответствие)");
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Процедура ОчиститьПеременныеКонтекста()
	Попытка
		ПараметрыРедактора = ЭтотОбъект.конс_СтруктураПараметровРедактораКода;
		ПараметрыРедактора.JSONПеременных = "";
		Если ЗначениеЗаполнено(ПараметрыРедактора.АдресЗначенийПеременных) Тогда
			ПоместитьВоВременноеХранилище(Новый Соответствие, ПараметрыРедактора.АдресЗначенийПеременных);
		КонецЕсли;
		// Необходимо переприсвоить реквизит формы, чтобы платформа зафиксировала изменения
		ЭтотОбъект.конс_СтруктураПараметровРедактораКода = ПараметрыРедактора;
	Исключение
		// Структура параметров ещё не инициализирована
	КонецПопытки;
КонецПроцедуры 


&НаКлиенте
Процедура УстановитьСхему()
	Если Не ЗначениеЗаполнено(Объект.СхемаДанных) или Не ЗначениеЗаполнено(Объект.ИмяСхемыПакета) Тогда 
		Возврат;
	КонецЕсли;     
	Схема = ПолучитьТекстСхемы(); 
	конс_ПодключаемаяКонсольКлиент.ЗагрузитьФайлСхемы(ЭтаФорма, Схема);
	
	Если Объект.НаправлениеПотока = ПредопределенноеЗначение("Перечисление.инт_НаправлениеПотокаДанных.Исходящий") Тогда
		конс_ПодключаемаяКонсольКлиент.ЗагрузитьСхемуПеременной(ЭтаФорма, "Результат", Схема, Объект.ИмяСхемыПакета);
	Иначе
		конс_ПодключаемаяКонсольКлиент.ЗагрузитьСхемуПеременной(ЭтаФорма, "ИсходныеДанные", Схема, Объект.ИмяСхемыПакета);
	КонецЕсли;

КонецПроцедуры   


&НаКлиенте
Процедура ИмяСхемыПакетаПриИзменении(Элемент)
	РедакторКодаДокументСформирован(Неопределено);
КонецПроцедуры


&НаСервере
Функция ПолучитьТекстСхемы()

	Возврат Справочники.инт_Схемы.ПолучитьOpenApiСхему(Объект.СхемаДанных);

КонецФункции 

// Показать ошибку в редакторе кода с подсветкой строки.
// Извлекает номер строки и колонки из текста ошибки,
// очищает текст от внутренних путей модулей {Модуль.Путь(N,M)}:
// и вызывает подсветку соответствующей строки в Monaco-редакторе.
//
// Параметры:
//  ТекстОшибки        - Строка - Текст ошибки (из КраткоеПредставлениеОшибки или лога).
//  ЭтоОшибкаВыполнения - Булево - Истина если ошибка runtime (нужен пересчёт строки по смещениям),
//                                  Ложь если ошибка компиляции (строки уже пересчитаны).
&НаКлиенте
Процедура ПоказатьОшибкуВРедакторе(Знач ТекстОшибки, Знач ЭтоОшибкаВыполнения = Ложь)
	
	НомерСтроки = 0;
	НомерКолонки = 1;
	
	// Очищаем текст от блоков {Модуль.Путь(N,M)}: — они не информативны для пользователя.
	// Координаты извлекаем из самого внутреннего (последнего) блока.
	Пока Истина Цикл
		ПозФигОткр = СтрНайти(ТекстОшибки, "{");
		Если ПозФигОткр = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозФигЗакр = СтрНайти(ТекстОшибки, "}", , ПозФигОткр);
		Если ПозФигЗакр = 0 Тогда
			Прервать;
		КонецЕсли;
		Суффикс = Сред(ТекстОшибки, ПозФигЗакр + 1);
		Если Не СтрНачинаетсяС(Суффикс, ": ") Тогда
			Прервать;
		КонецЕсли;
		
		// Извлекаем координаты (N,M) из содержимого блока.
		СодержимоеБлока = Сред(ТекстОшибки, ПозФигОткр + 1, ПозФигЗакр - ПозФигОткр - 1);
		ПозОткрСк = СтрНайти(СодержимоеБлока, "(");
		Если ПозОткрСк > 0 Тогда
			ПозЗакрСк = СтрНайти(СодержимоеБлока, ")", , ПозОткрСк);
			Если ПозЗакрСк > 0 Тогда
				Координаты = Сред(СодержимоеБлока, ПозОткрСк + 1, ПозЗакрСк - ПозОткрСк - 1);
				Части = СтрРазделить(Координаты, ",");
				Если Части.Количество() >= 2 Тогда
					Попытка
						ВозможнаяСтрока = Число(СокрЛП(Части[0]));
						ВозможнаяКолонка = Число(СокрЛП(Части[1]));
						Если ВозможнаяСтрока > 0 Тогда
							НомерСтроки = ВозможнаяСтрока;
							НомерКолонки = ВозможнаяКолонка;
						КонецЕсли;
					Исключение
						// Не числовые координаты.
					КонецПопытки;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// Убираем блок {…}: из текста.
		ТекстОшибки = СокрЛ(Лев(ТекстОшибки, ПозФигОткр - 1) + Сред(ТекстОшибки, ПозФигЗакр + 3));
	КонецЦикла;
	ТекстОшибки = СокрЛП(ТекстОшибки);
	
	// Для ошибок выполнения пересчитываем номер строки из модуля EPF в исходный код.
	Если ЭтоОшибкаВыполнения И НомерСтроки > 0 Тогда
		Если СмещениеТелаКода > 0 И НомерСтроки >= СмещениеТелаКода Тогда
			НомерСтроки = НомерСтроки - СмещениеТелаКода + 1;
		ИначеЕсли СмещениеПроцедур > 0 И НомерСтроки >= СмещениеПроцедур Тогда
			НомерСтроки = НомерСтроки - СмещениеПроцедур + 1;
		КонецЕсли;
	КонецЕсли;
	
	конс_ПодключаемаяКонсольКлиент.ПоказатьОшибку(ЭтаФорма, ТекстОшибки, НомерСтроки, НомерКолонки, "РедакторКода");
	
КонецПроцедуры

#КонецОбласти

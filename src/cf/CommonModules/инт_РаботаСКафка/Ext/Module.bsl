////////////////////////////////////////////////////////////////////////////////
// инт_РаботаСКафка
//
// В данном модуле собраны методы работы с ВК simple kafka
////////////////////////////////////////////////////////////////////////////////
#Область ПрограммныйИнтерфейс

// Устанавливает параметры авторизации Kafka на экземпляр компоненты.
// Должен вызываться ПОСЛЕ создания компоненты и ПЕРЕД инициализацией продюсера/консьюмера.
//
// Поддерживаемые протоколы безопасности (security.protocol):
//  - plaintext (Анонимный)
//  - sasl_ssl + PLAIN (Basic, ApiKey)
//  - sasl_ssl + SCRAM-SHA-512 (Digest)
//  - ssl (Tls — mTLS)
//  - sasl_ssl + OAUTHBEARER/OIDC (Bearer)
//
// Параметры:
//  Компонента - AddIn - Экземпляр внешней компоненты simpleKafka1C
//  Эндпоинт   - СправочникСсылка.инт_Эндпоинты - Эндпоинт с настроенной авторизацией
//
Процедура УстановитьПараметрыАвторизации(Компонента, Эндпоинт) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Эндпоинт) Тогда
		Возврат;
	КонецЕсли;
	
	Аутентификация = Справочники.инт_Эндпоинты.ПолучитьАутентификацию(Эндпоинт);
	
	Если Аутентификация = Неопределено Тогда
		// Анонимный — plaintext по умолчанию, параметры не требуются
		Возврат;
	КонецЕсли;
	
	ТипАвторизации = Аутентификация.Тип;
	
	Если ТипАвторизации = "Basic" Тогда
		УстановитьАвторизациюSASL(Компонента, "PLAIN",
			Аутентификация.Пользователь, Аутентификация.Пароль);
		
	ИначеЕсли ТипАвторизации = "Digest" Тогда
		УстановитьАвторизациюSASL(Компонента, "SCRAM-SHA-512",
			Аутентификация.Пользователь, Аутентификация.Пароль);
		
	ИначеЕсли ТипАвторизации = "ApiKey" Тогда
		// API Key: ИмяЗаголовка = sasl.username, Значение = sasl.password (Confluent Cloud pattern)
		УстановитьАвторизациюSASL(Компонента, "PLAIN",
			Аутентификация.ИмяЗаголовка, Аутентификация.Значение);
		
	ИначеЕсли ТипАвторизации = "Bearer" Тогда
		УстановитьАвторизациюOAuthBearer(Компонента, Эндпоинт, Аутентификация);
		
	ИначеЕсли ТипАвторизации = "Tls" Тогда
		УстановитьАвторизациюSSL(Компонента, Эндпоинт, Аутентификация);
		
	КонецЕсли;
	
	// Для всех типов с SSL/TLS пробуем установить корневой CA-сертификат
	Если ТипАвторизации <> Неопределено Тогда
		УстановитьСертификатCA(Компонента, Эндпоинт);
	КонецЕсли;
	
КонецПроцедуры

// Отправляет сообщение в топик Kafka
//
// Параметры:
//  ОтправляемоеСообщение - Строка - Тело сообщения для отправки
//  Брокеры               - Строка - Адреса брокеров Kafka (bootstrap servers), через запятую
//  Топик                 - Строка - Имя топика Kafka
//  НомерПартиции         - Число  - Номер партиции (-1 для автоматического выбора)
//  ИдентификаторСообщения - Строка - Ключ сообщения (опционально)
//  Заголовки             - Строка - Заголовки сообщения в формате JSON (опционально)
//  ТипСжатия             - ПеречислениеСсылка.инт_ТипыСжатияKafka - Тип сжатия сообщений (опционально)
//  Эндпоинт              - СправочникСсылка.инт_Эндпоинты - Эндпоинт для авторизации (опционально)
//
Процедура ОтправитьСообщение(ОтправляемоеСообщение, Брокеры, Топик, НомерПартиции = -1, ИдентификаторСообщения = "", Заголовки = "", ТипСжатия = Неопределено, Эндпоинт = Неопределено) Экспорт

	Компонента = ПолучитьЭкземплярКомпоненты();
	
	// Устанавливаем параметры авторизации если указан эндпоинт
	УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
	
	// Устанавливаем параметр сжатия, если указан
		Если ЗначениеЗаполнено(ТипСжатия) Тогда
			КодСжатия = ПолучитьКодСжатияДляКомпоненты(ТипСжатия);
			Если НЕ ПустаяСтрока(КодСжатия) Тогда
				Компонента.УстановитьПараметр("compression.codec", КодСжатия);
				Компонента.УстановитьПараметр("linger.ms", "10");
			КонецЕсли;
		КонецЕсли;
		
		// Расширяем лимит размера сообщения если необходимо
		УстановитьЛимитРазмераСообщения(Компонента, ОтправляемоеСообщение); 

	// инициализируем подключение к брокеру
	// достаточно указать одного брокера из кластера, либо есть возможность перечислить брокеров через символ запятая
	РезультатИнициализации = Компонента.ИнициализироватьПродюсера(Брокеры);
	
	Если РезультатИнициализации Тогда
		
		РезультатОтправки = Компонента.ОтправитьСообщение(ОтправляемоеСообщение, Топик, НомерПартиции, ИдентификаторСообщения, Заголовки);
		Если Не РезультатОтправки = 0 Тогда
			СообщениеОбОшибке = СтрШаблон("Отправка сообщения не удалась.
			| Информация об ошибке: %1", Компонента.ПолучитьСообщениеОбОшибке());
			ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
			УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке);
			
			Компонента.ОстановитьПродюсера();
			Компонента = Неопределено;

			ВызватьИсключение СообщениеОбОшибке;
		КонецЕсли;
	Иначе
		СообщениеОбОшибке = СтрШаблон("Не удалось инициализировать компоненту.
			| Информация об ошибке: %1", Компонента.ПолучитьСообщениеОбОшибке());
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
                                	УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке);
		Компонента = Неопределено;

		ВызватьИсключение СообщениеОбОшибке;
 
	КонецЕсли;
	
	Компонента.ОстановитьПродюсера();
	Компонента = Неопределено;

КонецПроцедуры

Функция ПолучитьСтруктуруСообщенияДляПакетнойОтправки() Экспорт
	Возврат инт_РаботаСКафкаПовтИсп.ПолучитьСтруктуруСообщенияДляПакетнойОтправки();
КонецФункции

// Отправляет пакет сообщений в топик Kafka
//
// Параметры:
//  МассивСообщений - Массив - Массив структур с полями: message, partition, key, headers
//  Брокеры         - Строка - Адреса брокеров Kafka (bootstrap servers), через запятую
//  Топик           - Строка - Имя топика Kafka
//  ТипСжатия       - ПеречислениеСсылка.инт_ТипыСжатияKafka - Тип сжатия сообщений (опционально)
//  Эндпоинт        - СправочникСсылка.инт_Эндпоинты - Эндпоинт для авторизации (опционально)
//
Процедура ОтправитьСообщенияПакетом(МассивСообщений, Брокеры, Топик, ТипСжатия = Неопределено, Эндпоинт = Неопределено) Экспорт

	Компонента = ПолучитьЭкземплярКомпоненты();
	
	// Устанавливаем параметры авторизации если указан эндпоинт
	УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
	
	// Устанавливаем параметр сжатия, если указан
	Если ЗначениеЗаполнено(ТипСжатия) Тогда
		КодСжатия = ПолучитьКодСжатияДляКомпоненты(ТипСжатия);
		Если НЕ ПустаяСтрока(КодСжатия) Тогда
			Компонента.УстановитьПараметр("compression.codec", КодСжатия);
		КонецЕсли;
	КонецЕсли;
	
	// Подготавливаем JSON сообщений для расчёта размера
	СообщенияJSON = инт_КоннекторHTTP.ОбъектВJson(МассивСообщений);
	
	// Расширяем лимит размера сообщения если необходимо
	УстановитьЛимитРазмераСообщения(Компонента, СообщенияJSON);
	
	РезультатИнициализации = Компонента.ИнициализироватьПродюсера(Брокеры);
	
	Если РезультатИнициализации Тогда
		РезультатОтправки = Компонента.ОтправитьСообщенияПакетом(СообщенияJSON, Топик);
		Если Не РезультатОтправки = 0 Тогда
			СообщениеОбОшибке = СтрШаблон("Пакетная отправка сообщений не удалась.
			| Информация об ошибке: %1", Компонента.ПолучитьСообщениеОбОшибке());
			ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
			УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке);
			ВызватьИсключение СообщениеОбОшибке;
		КонецЕсли;
	Иначе
		СообщениеОбОшибке = СтрШаблон("Не удалось инициализировать компоненту.
			| Информация об ошибке: %1", Компонента.ПолучитьСообщениеОбОшибке());
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
                                	УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке);
		ВызватьИсключение СообщениеОбОшибке;
	КонецЕсли;
	
	Компонента.ОстановитьПродюсера();
	Компонента = Неопределено;

КонецПроцедуры

Функция ПолучитьИнформациюОТопике(Брокеры, ИмяТопика, Эндпоинт = Неопределено) Экспорт
	
	Компонента = ПолучитьЭкземплярКомпоненты();
	УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
	РезультатJSON = Компонента.ПолучитьМетаданныеТопика(Брокеры, ИмяТопика);
	
	Если ПустаяСтрока(РезультатJSON) Тогда
		СообщениеОбОшибке = СтрШаблон("Не удалось получить информацию о топике %1.
		| Информация об ошибке: %2", ИмяТопика, Компонента.ПолучитьСообщениеОбОшибке());
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
						УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке); 
		Компонента = Неопределено;

		ВызватьИсключение СообщениеОбОшибке;
	КонецЕсли;
	
	ДанныеТопика = инт_КоннекторHTTP.JsonВОбъект(РезультатJSON);
	Компонента = Неопределено;

	Возврат ДанныеТопика;
КонецФункции

// Проверяет доступность брокера Kafka
//
// Параметры:
//  Брокеры - Строка - Адрес брокера (например, "localhost:9092")
//  Таймаут - Число - Таймаут ожидания в миллисекундах (по умолчанию 5000)
//
// Возвращаемое значение:
//  Структура - Результат проверки:
//   * Успех - Булево - Истина, если брокер доступен
//   * ОписаниеОшибки - Строка - Текст ошибки если недоступен
//   * ИнформацияОКластере - Структура, Неопределено - Данные о кластере при успехе
//
Функция ПроверитьДоступностьБрокера(Брокеры, Таймаут = 5000, Эндпоинт = Неопределено) Экспорт
	
	Результат = Новый Структура("Успех, ОписаниеОшибки, ИнформацияОКластере", Ложь, "", Неопределено);
	
	Попытка
		Компонента = ПолучитьЭкземплярКомпоненты();
		УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
		
		Если Компонента.ПроверитьДоступностьБрокера(Брокеры, Таймаут) Тогда
			// Получаем информацию о кластере
			РезультатJSON = Компонента.ПолучитьИнформациюОКластере(Брокеры);
			Если НЕ ПустаяСтрока(РезультатJSON) Тогда
				Результат.ИнформацияОКластере = инт_КоннекторHTTP.JsonВОбъект(РезультатJSON);
			КонецЕсли;
			Результат.Успех = Истина;
		Иначе
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
		КонецЕсли;
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	Компонента = Неопределено;

	Возврат Результат;
	
КонецФункции

// Проверяет существование топика в Kafka
//
// Параметры:
//  Брокеры - Строка - Адрес брокера
//  ИмяТопика - Строка - Имя топика
//
// Возвращаемое значение:
//  Структура - Результат проверки:
//   * Существует - Булево - Истина, если топик существует
//   * ОписаниеОшибки - Строка - Текст ошибки подключения (пустая строка если ОК)
//   * Метаданные - Структура, Неопределено - Метаданные топика при существовании
//
Функция ТопикСуществует(Брокеры, ИмяТопика, Эндпоинт = Неопределено) Экспорт
	
	Результат = Новый Структура("Существует, ОписаниеОшибки, Метаданные", Ложь, "", Неопределено);
	
	Попытка
		Компонента = ПолучитьЭкземплярКомпоненты();
		УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
		РезультатJSON = Компонента.ПолучитьМетаданныеТопика(Брокеры, ИмяТопика);
		
		Если ПустаяСтрока(РезультатJSON) Тогда
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
			Компонента = Неопределено;

			Возврат Результат;
		КонецЕсли;
		
		ДанныеТопика = инт_КоннекторHTTP.JsonВОбъект(РезультатJSON);
		
		// Проверяем наличие ошибки "Unknown topic"
		ТекстОшибки = ДанныеТопика.Получить("error");
		Если ТекстОшибки <> Неопределено И СтрНайти(ТекстОшибки, "Unknown topic") > 0 Тогда
			Результат.Существует = Ложь;
		Иначе
			Результат.Существует = Истина;
			Результат.Метаданные = ДанныеТопика;
		КонецЕсли;
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	Компонента = Неопределено;

	Возврат Результат;
	
КонецФункции

// Создает топик в Kafka
//
// Параметры:
//  Брокеры - Строка - Адрес брокера
//  ИмяТопика - Строка - Имя создаваемого топика
//  КоличествоПартиций - Число - Количество партиций (по умолчанию 1)
//  ФакторРепликации - Число - Фактор репликации (по умолчанию 1)
//
// Возвращаемое значение:
//  Структура - Результат создания:
//   * Успех - Булево - Истина, если топик создан
//   * ОписаниеОшибки - Строка - Текст ошибки при неудаче
//
Функция СоздатьТопик(Брокеры, ИмяТопика, КоличествоПартиций = 1, ФакторРепликации = 1, Эндпоинт = Неопределено) Экспорт
	
	Результат = Новый Структура("Успех, ОписаниеОшибки", Ложь, "");
	
	Попытка
		Компонента = ПолучитьЭкземплярКомпоненты();
		УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
		
		Если Компонента.СоздатьТопик(Брокеры, ИмяТопика, КоличествоПартиций, ФакторРепликации) Тогда
			Результат.Успех = Истина;
			ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
				УровеньЖурналаРегистрации.Информация, , ,
				СтрШаблон("Топик %1 успешно создан (партиций: %2, репликация: %3)",
					ИмяТопика, КоличествоПартиций, ФакторРепликации));
		Иначе
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
			ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
				УровеньЖурналаРегистрации.Ошибка, , ,
				СтрШаблон("Ошибка создания топика %1: %2", ИмяТопика, Результат.ОписаниеОшибки));
		КонецЕсли;
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
			УровеньЖурналаРегистрации.Ошибка, , , Результат.ОписаниеОшибки);
	КонецПопытки;
	Компонента = Неопределено;

	Возврат Результат;
	
КонецФункции

// Получает настройки топика из Kafka
//
// Параметры:
//  Брокеры - Строка - Адрес брокера
//  ИмяТопика - Строка - Имя топика
//
// Возвращаемое значение:
//  Структура - Результат:
//   * Успех - Булево - Истина, если настройки получены
//   * ОписаниеОшибки - Строка - Текст ошибки
//   * Настройки - Соответствие - Настройки топика (retention.ms, cleanup.policy, etc.)
//
Функция ПолучитьНастройкиТопика(Брокеры, ИмяТопика, Эндпоинт = Неопределено) Экспорт
	
	Результат = Новый Структура("Успех, ОписаниеОшибки, Настройки", Ложь, "", Новый Соответствие);
	
	Попытка
		Компонента = ПолучитьЭкземплярКомпоненты();
		УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
		РезультатJSON = Компонента.ПолучитьНастройкиТопика(Брокеры, ИмяТопика);
		
		Если ПустаяСтрока(РезультатJSON) Тогда
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
			Компонента = Неопределено;

			Возврат Результат;
		КонецЕсли;
		
		ДанныеНастроек = инт_КоннекторHTTP.JsonВОбъект(РезультатJSON);
		МассивНастроек = ДанныеНастроек.Получить("configs");
		
		Если МассивНастроек <> Неопределено Тогда
			Для Каждого Настройка Из МассивНастроек Цикл
				ИмяНастройки = Настройка.Получить("name");
				ЗначениеНастройки = Настройка.Получить("value");
				Если ИмяНастройки <> Неопределено Тогда
					Результат.Настройки.Вставить(ИмяНастройки, ЗначениеНастройки);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Результат.Успех = Истина;
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	Компонента = Неопределено;

	Возврат Результат;
	
КонецФункции

// Устанавливает настройки топика в Kafka
//
// Параметры:
//  Брокеры - Строка - Адрес брокера
//  ИмяТопика - Строка - Имя топика
//  Настройки - Соответствие - Настройки топика (ключ - имя параметра, значение - значение параметра)
//
// Возвращаемое значение:
//  Структура - Результат:
//   * Успех - Булево - Истина, если настройки установлены
//   * ОписаниеОшибки - Строка - Текст ошибки
//
Функция УстановитьНастройкиТопика(Брокеры, ИмяТопика, Настройки, Эндпоинт = Неопределено) Экспорт
	
	Результат = Новый Структура("Успех, ОписаниеОшибки", Ложь, "");
	
	Если Настройки.Количество() = 0 Тогда
		Результат.Успех = Истина;  
		Компонента = Неопределено;

		Возврат Результат;
	КонецЕсли;
	
	Попытка
		Компонента = ПолучитьЭкземплярКомпоненты();
		УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
		
		// Преобразуем соответствие в JSON для передачи в компоненту
		НастройкиJSON = инт_КоннекторHTTP.ОбъектВJson(Настройки);
		
		Если Компонента.УстановитьНастройкиТопика(Брокеры, ИмяТопика, НастройкиJSON) Тогда
			Результат.Успех = Истина;
			ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
				УровеньЖурналаРегистрации.Информация, , ,
				СтрШаблон("Настройки топика %1 успешно обновлены", ИмяТопика));
		Иначе
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
			ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
				УровеньЖурналаРегистрации.Ошибка, , ,
				СтрШаблон("Ошибка установки настроек топика %1: %2", ИмяТопика, Результат.ОписаниеОшибки));
		КонецЕсли;
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
			УровеньЖурналаРегистрации.Ошибка, , , Результат.ОписаниеОшибки);
		КонецПопытки;
		
	Компонента = Неопределено;
	Возврат Результат;
	
КонецФункции

// Получает информацию о кластере Kafka
//
// Параметры:
//  Брокеры - Строка - Адрес брокера
//
// Возвращаемое значение:
//  Структура - Результат:
//   * Успех - Булево - Истина, если информация получена
//   * ОписаниеОшибки - Строка - Текст ошибки
//   * КоличествоБрокеров - Число - Количество брокеров в кластере
//   * КоличествоТопиков - Число - Количество топиков
//   * Брокеры - Массив - Информация о брокерах
//
Функция ПолучитьИнформациюОКластере(Брокеры, Эндпоинт = Неопределено) Экспорт
	
	Результат = Новый Структура("Успех, ОписаниеОшибки, КоличествоБрокеров, КоличествоТопиков, Брокеры",
		Ложь, "", 0, 0, Новый Массив);
	
	Попытка
		Компонента = ПолучитьЭкземплярКомпоненты();
		УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
		РезультатJSON = Компонента.ПолучитьИнформациюОКластере(Брокеры);
		
		Если ПустаяСтрока(РезультатJSON) Тогда
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
			Компонента = Неопределено;

			Возврат Результат;
		КонецЕсли;
		
		ДанныеКластера = инт_КоннекторHTTP.JsonВОбъект(РезультатJSON);
		
		КолБрокеров = ДанныеКластера.Получить("brokers_count");
		Если КолБрокеров <> Неопределено Тогда
			Результат.КоличествоБрокеров = Число(КолБрокеров);
		КонецЕсли;
		
		КолТопиков = ДанныеКластера.Получить("topics_count");
		Если КолТопиков <> Неопределено Тогда
			Результат.КоличествоТопиков = Число(КолТопиков);
		КонецЕсли;
		
		МассивБрокеров = ДанныеКластера.Получить("brokers");
		Если МассивБрокеров <> Неопределено Тогда
			Результат.Брокеры = МассивБрокеров;
		КонецЕсли;
		
		Результат.Успех = Истина;
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	Компонента = Неопределено;
	Возврат Результат;
	
КонецФункции

// Получает информацию о партициях топика: watermarks и количество сообщений.
//
// Параметры:
//  Брокеры   - Строка - Адреса брокеров Kafka через запятую
//  ИмяТопика - Строка - Имя топика
//  Эндпоинт  - СправочникСсылка.инт_Эндпоинты - Эндпоинт для авторизации (опционально)
//
// Возвращаемое значение:
//  Структура - Результат:
//   * Успех - Булево - Истина, если информация получена
//   * ОписаниеОшибки - Строка - Текст ошибки
//   * Партиции - Массив из Соответствие - Данные партиций (partition, leader, high_watermark, low_watermark)
//
Функция ПолучитьИнформациюОПартициях(Брокеры, ИмяТопика, Эндпоинт = Неопределено) Экспорт
	
	Результат = Новый Структура("Успех, ОписаниеОшибки, Партиции", Ложь, "", Новый Массив);
	
	Попытка
		Компонента = ПолучитьЭкземплярКомпоненты(Истина);
		УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
		РезультатJSON = Компонента.ПолучитьМетаданныеТопика(Брокеры, ИмяТопика);
		
		Если ПустаяСтрока(РезультатJSON) Тогда
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
			Компонента = Неопределено;
			Возврат Результат;
		КонецЕсли;
		
		ДанныеТопика = инт_КоннекторHTTP.JsonВОбъект(РезультатJSON);
		
		// Проверяем наличие ошибки
		ТекстОшибки = ДанныеТопика.Получить("error");
		Если ТекстОшибки <> Неопределено И СтрНайти(ТекстОшибки, "Unknown topic") > 0 Тогда
			Результат.ОписаниеОшибки = "Топик не существует";
			Компонента = Неопределено;
			Возврат Результат;
		КонецЕсли;
		
		// Извлекаем партиции из метаданных
		МассивПартиций = ДанныеТопика.Получить("partitions");
		Если МассивПартиций <> Неопределено Тогда
			Для Каждого Партиция Из МассивПартиций Цикл
				ДанныеПартиции = Новый Соответствие;
				ДанныеПартиции.Вставить("partition", Партиция.Получить("id"));
				ДанныеПартиции.Вставить("leader", Партиция.Получить("leader"));
				ДанныеПартиции.Вставить("high_watermark", Партиция.Получить("high_watermark"));
				ДанныеПартиции.Вставить("low_watermark", Партиция.Получить("low_watermark"));
				Результат.Партиции.Добавить(ДанныеПартиции);
			КонецЦикла;
		КонецЕсли;
		
		Результат.Успех = Истина;
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
			УровеньЖурналаРегистрации.Ошибка, , ,
			СтрШаблон("Ошибка получения информации о партициях топика %1: %2", ИмяТопика, Результат.ОписаниеОшибки));
	КонецПопытки;
	
	Компонента = Неопределено;
	Возврат Результат;
	
КонецФункции

// Получает оффсеты consumer group для топика.
//
// Параметры:
//  Брокеры               - Строка - Адреса брокеров Kafka через запятую
//  ИмяГруппыКонсьюмеров  - Строка - Consumer group ID
//  ИмяТопика             - Строка - Имя топика
//  Эндпоинт              - СправочникСсылка.инт_Эндпоинты - Эндпоинт для авторизации (опционально)
//
// Возвращаемое значение:
//  Структура - Результат:
//   * Успех - Булево - Истина, если данные получены
//   * ОписаниеОшибки - Строка - Текст ошибки
//   * Оффсеты - Массив из Соответствие - Данные оффсетов (partition, offset, high_watermark, lag)
//
Функция ПолучитьОффсетыКонсьюмера(Брокеры, ИмяГруппыКонсьюмеров, ИмяТопика, Эндпоинт = Неопределено) Экспорт
	
	Результат = Новый Структура("Успех, ОписаниеОшибки, Оффсеты", Ложь, "", Новый Массив);
	
	Попытка
		Компонента = ПолучитьЭкземплярКомпоненты(Истина);
		Компонента.УстановитьПараметр("group.id", ИмяГруппыКонсьюмеров);
		УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
		
		РезультатИнициализации = Компонента.ИнициализироватьКонсьюмера(Брокеры);
		Если НЕ РезультатИнициализации Тогда
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
			Компонента = Неопределено;
			Возврат Результат;
		КонецЕсли;
		
		РезультатJSON = Компонента.ПолучитьСмещенияГруппыКонсьюмеров(Брокеры, ИмяГруппыКонсьюмеров, ИмяТопика);
		
		Если ТипЗнч(РезультатJSON) <> Тип("Строка") ИЛИ ПустаяСтрока(РезультатJSON) Тогда
			// Компонента вернула Ложь или пустую строку — 
			// возможно, группа ещё не читала сообщений (оффсеты не зафиксированы).
			СообщениеКомпоненты = Компонента.ПолучитьСообщениеОбОшибке();
			Если ПустаяСтрока(СообщениеКомпоненты) Тогда
				Результат.ОписаниеОшибки = "Оффсеты для группы консьюмеров не найдены. "
					+ "Возможно, группа ещё не читала сообщений из топика.";
			Иначе
				Результат.ОписаниеОшибки = СообщениеКомпоненты;
			КонецЕсли;
			Компонента = Неопределено;
			Возврат Результат;
		КонецЕсли;
		
		ДанныеОффсетов = инт_КоннекторHTTP.JsonВОбъект(РезультатJSON);
		
		МассивОффсетов = ДанныеОффсетов.Получить("offsets");
		Если МассивОффсетов <> Неопределено Тогда
			Для Каждого ОффсетПартиции Из МассивОффсетов Цикл
				ДанныеОффсета = Новый Соответствие;
				ДанныеОффсета.Вставить("partition", ОффсетПартиции.Получить("partition"));
				ДанныеОффсета.Вставить("offset", ОффсетПартиции.Получить("offset"));
				ДанныеОффсета.Вставить("high_watermark", ОффсетПартиции.Получить("high_watermark"));
				
				Оффсет = ОффсетПартиции.Получить("offset");
				HighWM = ОффсетПартиции.Получить("high_watermark");
				Лаг = 0;
				Если Оффсет <> Неопределено И HighWM <> Неопределено Тогда
					Лаг = Число(HighWM) - Число(Оффсет);
					Если Лаг < 0 Тогда
						Лаг = 0;
					КонецЕсли;
				КонецЕсли;
				ДанныеОффсета.Вставить("lag", Лаг);
				
				Результат.Оффсеты.Добавить(ДанныеОффсета);
			КонецЦикла;
		КонецЕсли;
		
		Результат.Успех = Истина;
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
			УровеньЖурналаРегистрации.Ошибка, , ,
			СтрШаблон("Ошибка получения оффсетов группы %1 для топика %2: %3",
				ИмяГруппыКонсьюмеров, ИмяТопика, Результат.ОписаниеОшибки));
	КонецПопытки;
	
	Компонента = Неопределено;
	Возврат Результат;
	
КонецФункции

// Устанавливает оффсет для партиции в consumer group.
// ВАЖНО: консьюмер группы должен быть остановлен (inactive) для изменения оффсетов.
//
// Параметры:
//  Брокеры               - Строка - Адреса брокеров Kafka через запятую
//  ИмяГруппыКонсьюмеров  - Строка - Consumer group ID
//  ИмяТопика             - Строка - Имя топика
//  НомерПартиции         - Число - Номер партиции
//  НовыйОффсет           - Число - Новое значение оффсета
//  Эндпоинт              - СправочникСсылка.инт_Эндпоинты - Эндпоинт для авторизации (опционально)
//
// Возвращаемое значение:
//  Структура - Результат:
//   * Успех - Булево - Истина, если оффсет установлен
//   * ОписаниеОшибки - Строка - Текст ошибки
//
Функция УстановитьОффсетКонсьюмера(Брокеры, ИмяГруппыКонсьюмеров, ИмяТопика, НомерПартиции, НовыйОффсет, Эндпоинт = Неопределено) Экспорт
	
	Результат = Новый Структура("Успех, ОписаниеОшибки", Ложь, "");
	
	Попытка
		Компонента = ПолучитьЭкземплярКомпоненты(Истина);
		Компонента.УстановитьПараметр("group.id", ИмяГруппыКонсьюмеров);
		УстановитьПараметрыАвторизации(Компонента, Эндпоинт);
		
		РезультатИнициализации = Компонента.ИнициализироватьКонсьюмера(Брокеры);
		Если НЕ РезультатИнициализации Тогда
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
			Компонента = Неопределено;
			Возврат Результат;
		КонецЕсли;
		
		Если Компонента.ИзменитьСмещениеГруппыКонсьюмеров(Брокеры, ИмяГруппыКонсьюмеров, ИмяТопика, НомерПартиции, НовыйОффсет) Тогда
			Результат.Успех = Истина;
			ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
				УровеньЖурналаРегистрации.Информация, , ,
				СтрШаблон("Оффсет группы %1 для топика %2, партиции %3 установлен в %4",
					ИмяГруппыКонсьюмеров, ИмяТопика, НомерПартиции, НовыйОффсет));
		Иначе
			Результат.ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();
			ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
				УровеньЖурналаРегистрации.Ошибка, , ,
				СтрШаблон("Ошибка установки оффсета группы %1 для топика %2, партиции %3: %4",
					ИмяГруппыКонсьюмеров, ИмяТопика, НомерПартиции, Результат.ОписаниеОшибки));
		КонецЕсли;
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
			УровеньЖурналаРегистрации.Ошибка, , , Результат.ОписаниеОшибки);
	КонецПопытки;
	
	Компонента = Неопределено;
	Возврат Результат;
	
КонецФункции 

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Устанавливает параметры SASL-авторизации на компоненту Kafka.
// Используется для протоколов SASL_SSL + PLAIN | SCRAM-SHA-512
//
// Параметры:
//  Компонента   - AddIn - Экземпляр внешней компоненты simpleKafka1C
//  Механизм     - Строка - SASL механизм: "PLAIN", "SCRAM-SHA-256", "SCRAM-SHA-512"
//  Пользователь - Строка - Имя пользователя (sasl.username)
//  Пароль       - Строка - Пароль (sasl.password)
//
Процедура УстановитьАвторизациюSASL(Компонента, Механизм, Пользователь, Пароль)
	
	Компонента.УстановитьПараметр("security.protocol", "sasl_ssl");
	Компонента.УстановитьПараметр("sasl.mechanism", Механизм);
	Компонента.УстановитьПараметр("sasl.username", Пользователь);
	Компонента.УстановитьПараметр("sasl.password", Пароль);
	
КонецПроцедуры

// Устанавливает параметры SSL-авторизации (mTLS) на компоненту Kafka.
// Используется для клиентских сертификатов.
// Двоичные данные сертификатов записываются во временные файлы,
// т.к. librdkafka принимает только пути к файлам.
//
// Параметры:
//  Компонента      - AddIn - Экземпляр внешней компоненты simpleKafka1C
//  Эндпоинт        - СправочникСсылка.инт_Эндпоинты - Эндпоинт для чтения доп. ключей из хранилища
//  Аутентификация   - Структура - Данные авторизации:
//   * Тип              - Строка - "Tls"
//   * Сертификат       - ДвоичныеДанные - Двоичные данные клиентского сертификата
//   * ПарольСертификата - Строка - Пароль приватного ключа (ssl.key.password)
//
Процедура УстановитьАвторизациюSSL(Компонента, Эндпоинт, Аутентификация)
	
	Компонента.УстановитьПараметр("security.protocol", "ssl");
	
	// Клиентский сертификат (двоичные данные → временный файл)
	Если ЗначениеЗаполнено(Аутентификация.Сертификат) Тогда
		ПутьСертификата = ЗаписатьВоВременныйФайл(Аутентификация.Сертификат, "cert.pem");
		Компонента.УстановитьПараметр("ssl.certificate.location", ПутьСертификата);
	КонецЕсли;
	
	// Пароль приватного ключа
	Если ЗначениеЗаполнено(Аутентификация.ПарольСертификата) Тогда
		Компонента.УстановитьПараметр("ssl.key.password", Аутентификация.ПарольСертификата);
	КонецЕсли;
	
	// Приватный ключ клиента (двоичные данные из безопасного хранилища → временный файл)
	КлючСертификата = ПрочитатьИзБезопасногоХранилища(Эндпоинт, "Kafka_КлючСертификата");
	Если ЗначениеЗаполнено(КлючСертификата) Тогда
		ПутьКлюча = ЗаписатьВоВременныйФайл(КлючСертификата, "key.pem");
		Компонента.УстановитьПараметр("ssl.key.location", ПутьКлюча);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает параметры OAUTHBEARER-авторизации (OIDC) на компоненту Kafka.
// Использует встроенный OIDC-механизм librdkafka (>= 2.1.0).
//
// Параметры:
//  Компонента      - AddIn - Экземпляр внешней компоненты simpleKafka1C
//  Эндпоинт        - СправочникСсылка.инт_Эндпоинты - Эндпоинт для чтения OIDC-параметров из хранилища
//  Аутентификация   - Структура - Данные авторизации:
//   * Тип   - Строка - "Bearer"
//   * Токен - Строка - Используется как sasl.oauthbearer.client.id
//
Процедура УстановитьАвторизациюOAuthBearer(Компонента, Эндпоинт, Аутентификация)
	
	Компонента.УстановитьПараметр("security.protocol", "sasl_ssl");
	Компонента.УстановитьПараметр("sasl.mechanism", "OAUTHBEARER");
	Компонента.УстановитьПараметр("sasl.oauthbearer.method", "oidc");
	
	// Client ID из стандартного поля Bearer_Токен
	Если ЗначениеЗаполнено(Аутентификация.Токен) Тогда
		Компонента.УстановитьПараметр("sasl.oauthbearer.client.id", Аутентификация.Токен);
	КонецЕсли;
	
	// Client Secret (из безопасного хранилища)
	ClientSecret = ПрочитатьИзБезопасногоХранилища(Эндпоинт, "Kafka_OAuthClientSecret");
	Если ЗначениеЗаполнено(ClientSecret) Тогда
		Компонента.УстановитьПараметр("sasl.oauthbearer.client.secret", ClientSecret);
	КонецЕсли;
	
	// Token Endpoint URL (из безопасного хранилища)
	TokenEndpoint = ПрочитатьИзБезопасногоХранилища(Эндпоинт, "Kafka_OAuthTokenEndpoint");
	Если ЗначениеЗаполнено(TokenEndpoint) Тогда
		Компонента.УстановитьПараметр("sasl.oauthbearer.token.endpoint.url", TokenEndpoint);
	КонецЕсли;
	
	// Scope (из безопасного хранилища, опционально)
	OAuthScope = ПрочитатьИзБезопасногоХранилища(Эндпоинт, "Kafka_OAuthScope");
	Если ЗначениеЗаполнено(OAuthScope) Тогда
		Компонента.УстановитьПараметр("sasl.oauthbearer.scope", OAuthScope);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает корневой CA-сертификат (ssl.ca.location) если он задан в безопасном хранилище.
// Двоичные данные сертификата записываются во временный файл,
// т.к. librdkafka принимает только путь к файлу.
// Применяется для всех SSL/SASL_SSL протоколов.
//
// Параметры:
//  Компонента - AddIn - Экземпляр внешней компоненты simpleKafka1C
//  Эндпоинт   - СправочникСсылка.инт_Эндпоинты - Эндпоинт
//
Процедура УстановитьСертификатCA(Компонента, Эндпоинт)
	
	СертификатCA = ПрочитатьИзБезопасногоХранилища(Эндпоинт, "Kafka_СертификатCA");
	Если ЗначениеЗаполнено(СертификатCA) Тогда
		ПутьCA = ЗаписатьВоВременныйФайл(СертификатCA, "ca.pem");
		Компонента.УстановитьПараметр("ssl.ca.location", ПутьCA);
	КонецЕсли;
	
КонецПроцедуры

// Читает значение из безопасного хранилища в привилегированном режиме.
//
// Параметры:
//  Владелец - ЛюбаяСсылка - Владелец данных (обычно СправочникСсылка.инт_Эндпоинты)
//  Ключ     - Строка - Ключ хранилища
//
// Возвращаемое значение:
//  Произвольный - Значение из хранилища или Неопределено
//
Функция ПрочитатьИзБезопасногоХранилища(Владелец, Ключ)
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат инт_РаботаСБезопаснымХранилищем.ПрочитатьДанныеИзБезопасногоХранилища(Владелец, Ключ);
	
КонецФункции

// Записывает двоичные данные во временный файл и возвращает путь к нему.
// Используется для передачи сертификатов и ключей в librdkafka,
// которая принимает только пути к файлам (ssl.ca.location, ssl.certificate.location и т.д.).
//
// ВНИМАНИЕ: Временные файлы удаляются средствами ОС при перезагрузке.
// При необходимости явного удаления вызывающий код должен удалить файл самостоятельно.
//
// Параметры:
//  ДвоичныеДанные - ДвоичныеДанные - Данные для записи (сертификат, ключ и т.п.)
//  ИмяФайла       - Строка - Имя файла с расширением (например, "ca.pem", "key.pem")
//
// Возвращаемое значение:
//  Строка - Полный путь к созданному временному файлу
//
Функция ЗаписатьВоВременныйФайл(ДвоичныеДанные, ИмяФайла)
	
	КаталогВременный = КаталогВременныхФайлов() + "kafka_certs";
	
	// Создаём подкаталог если его нет
	ФайлКаталога = Новый Файл(КаталогВременный);
	Если НЕ ФайлКаталога.Существует() Тогда
		СоздатьКаталог(КаталогВременный);
	КонецЕсли;
	
	ПолныйПуть = КаталогВременный + ПолучитьРазделительПути() + ИмяФайла;
	ДвоичныеДанные.Записать(ПолныйПуть);
	
	Возврат ПолныйПуть;
	
КонецФункции

// Возвращает строковое представление типа сжатия для параметра compression.codec
//
// Параметры:
//  ТипСжатия - ПеречислениеСсылка.инт_ТипыСжатияKafka - Тип сжатия из перечисления
//
// Возвращаемое значение:
//  Строка - Код сжатия для librdkafka (none, gzip, snappy, lz4, zstd)
//
Функция ПолучитьКодСжатияДляКомпоненты(ТипСжатия)
	
	Если НЕ ЗначениеЗаполнено(ТипСжатия) Тогда
		Возврат "";
	КонецЕсли;
	
	Если ТипСжатия = Перечисления.инт_ТипыСжатияKafka.БезСжатия Тогда
		Возврат "none";
	ИначеЕсли ТипСжатия = Перечисления.инт_ТипыСжатияKafka.Gzip Тогда
		Возврат "gzip";
	ИначеЕсли ТипСжатия = Перечисления.инт_ТипыСжатияKafka.Snappy Тогда
		Возврат "snappy";
	ИначеЕсли ТипСжатия = Перечисления.инт_ТипыСжатияKafka.Lz4 Тогда
		Возврат "lz4";
	ИначеЕсли ТипСжатия = Перечисления.инт_ТипыСжатияKafka.Zstd Тогда
		Возврат "zstd";
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

// Устанавливает параметр message.max.bytes если размер сообщения превышает лимит по умолчанию (1 МБ)
// Библиотека librdkafka проверяет размер сообщения ДО сжатия, поэтому необходимо расширять лимит
// для больших сообщений даже при использовании сжатия
//
// Параметры:
//  Компонента - AddIn - Экземпляр внешней компоненты simpleKafka1C
//  Сообщение  - Строка - Текст сообщения для отправки
//
Процедура УстановитьЛимитРазмераСообщения(Компонента, Сообщение)
	
	// Лимит по умолчанию в librdkafka - 1 МБ (1048576 байт)
	ЛимитПоУмолчанию = 1000000; // ~1 МБ с запасом
	// Дополнительный запас для заголовков и метаданных
	ДополнительныйЗапас = 1048576; // 1 МБ
	
	РазмерДанных = СтрДлина(Сообщение); // приблизительная оценка для UTF-8
	
	Если РазмерДанных > ЛимитПоУмолчанию Тогда
		НовыйЛимит = РазмерДанных + ДополнительныйЗапас;
		Компонента.УстановитьПараметр("message.max.bytes", Формат(НовыйЛимит, "ЧДЦ=0; ЧГ=0"));
	КонецЕсли;
	
КонецПроцедуры

// Функция - Получить экземпляр компоненты
// Создаёт и возвращает экземпляр нативной компоненты simpleKafka1C.
//
// Параметры:
//  Изолированно - Булево - Если Истина, компонента подключается в отдельном процессе.
//    Используйте Истина для интерактивных (UI) операций — crash компоненты
//    не приведёт к падению клиента 1С.
//
// Возвращаемое значение:
//  AddIn - Экземпляр внешней компоненты
//
Функция ПолучитьЭкземплярКомпоненты(Изолированно = Ложь)
	
	Если Изолированно Тогда
		ПодключитьВнешнююКомпоненту("ОбщийМакет.инт_simple_kafka", "IntegrationSafe",
			ТипВнешнейКомпоненты.Native, ТипПодключенияВнешнейКомпоненты.Изолированно);
	Иначе
		ПодключитьВнешнююКомпоненту("ОбщийМакет.инт_simple_kafka", "Integration",
			ТипВнешнейКомпоненты.Native, ТипПодключенияВнешнейКомпоненты.НеИзолированно);
	КонецЕсли;
	
	ИмяКомпоненты = ?(Изолированно, "AddIn.IntegrationSafe.simpleKafka1C", "AddIn.Integration.simpleKafka1C");

	Попытка
		Компонента = Новый(ИмяКомпоненты);
	Исключение
		СообщениеОбОшибке = "Ошибка при подключении компоненты <Simple Kafka 1C>!";
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.РаботаСКафка",
                                        УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке);
		ВызватьИсключение СообщениеОбОшибке;
	КонецПопытки;
	
	// Настраиваем логирование если задан каталог
	НастроитьЛогированиеКомпоненты(Компонента);

	Возврат Компонента;
КонецФункции

// Настраивает логирование компоненты Kafka
//
// Параметры:
//  Компонента - AddIn - Экземпляр внешней компоненты simpleKafka1C
//
Процедура НастроитьЛогированиеКомпоненты(Компонента)
	
	// Получаем настройки логирования из константы или настроек
	КаталогЛогов = ПолучитьКаталогЛоговKafka();
	
	Если ПустаяСтрока(КаталогЛогов) Тогда
		Возврат;
	КонецЕсли;
	
	// Устанавливаем каталог логов
	Компонента.КаталогЛогов = КаталогЛогов;
	
	// Устанавливаем формат имени файла лога (новый файл каждый день)
	Компонента.ФорматИмениФайловЛога = "%Y%m%d";
	
	// Устанавливаем идентификатор клиента для различения логов
	ИдентификаторКлиента = ПолучитьИдентификаторКлиентаKafka();
	Если НЕ ПустаяСтрока(ИдентификаторКлиента) Тогда
		Компонента.УстановитьПараметр("client.id", ИдентификаторКлиента);
	КонецЕсли;
	
	// Настраиваем уровень отладки если требуется
	УровеньОтладки = ПолучитьУровеньОтладкиKafka();
	Если НЕ ПустаяСтрока(УровеньОтладки) Тогда
		Компонента.УстановитьПараметр("debug", УровеньОтладки);
	КонецЕсли;
	
	// Настраиваем сбор статистики если задан интервал
	ИнтервалСтатистики = ПолучитьИнтервалСтатистикиKafka();
	Если ИнтервалСтатистики > 0 Тогда
		Компонента.УстановитьПараметр("statistics.interval.ms", Формат(ИнтервалСтатистики, "ЧДЦ=0; ЧГ=0"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает каталог для записи логов Kafka
//
// Возвращаемое значение:
//  Строка - Путь к каталогу логов или пустая строка если логирование отключено
//
Функция ПолучитьКаталогЛоговKafka()
	
	КаталогЛогов = Константы.инт_КаталогЛоговKafka.Получить();
	Если ЗначениеЗаполнено(КаталогЛогов) Тогда
		Возврат ДобавитьРазделительПути(КаталогЛогов);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Добавляет разделитель пути в конец каталога если его нет
//
// Параметры:
//  Каталог - Строка - Путь к каталогу
//
// Возвращаемое значение:
//  Строка - Путь с разделителем в конце
//
Функция ДобавитьРазделительПути(Каталог)
	
	Если ПустаяСтрока(Каталог) Тогда
		Возврат "";
	КонецЕсли;
	
	Разделитель = ПолучитьРазделительПути();
	ПоследнийСимвол = Прав(Каталог, 1);
	
	Если ПоследнийСимвол = "/" ИЛИ ПоследнийСимвол = "\" Тогда
		Возврат Каталог;
	КонецЕсли;
	
	Возврат Каталог + Разделитель;
	
КонецФункции

// Возвращает идентификатор клиента Kafka для логов
//
// Возвращаемое значение:
//  Строка - Идентификатор клиента
//
Функция ПолучитьИдентификаторКлиентаKafka()
	
	ИдентификаторКлиента = Константы.инт_ИдентификаторКлиентаKafka.Получить();
	Если ЗначениеЗаполнено(ИдентификаторКлиента) Тогда
		Возврат ИдентификаторКлиента;
	КонецЕсли;
	
	// По умолчанию используем имя информационной базы
	Возврат "1c_simple_kafka";
	
КонецФункции

// Возвращает уровень отладки для логов Kafka
//
// Возвращаемое значение:
//  Строка - Список категорий отладки через запятую или пустая строка
//
Функция ПолучитьУровеньОтладкиKafka()
	
	УровеньОтладки = Константы.инт_УровеньОтладкиKafka.Получить();
	Если ЗначениеЗаполнено(УровеньОтладки) Тогда
		Возврат УровеньОтладки;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Возвращает интервал сбора статистики Kafka в миллисекундах
//
// Возвращаемое значение:
//  Число - Интервал в мс (0 = отключено)
//
Функция ПолучитьИнтервалСтатистикиKafka()
	
	Интервал = Константы.инт_ИнтервалСтатистикиKafka.Получить();
	Если ЗначениеЗаполнено(Интервал) Тогда
		Возврат Интервал;
	КонецЕсли;
	
	Возврат 0;
	
КонецФункции

// Возвращает строку отладки для продюсера Kafka
//
// Возвращаемое значение:
//  Строка - Категории отладки для продюсера
//
Функция ПолучитьУровеньОтладкиПродюсера() Экспорт
	Возврат "broker,topic,msg";
КонецФункции

// Возвращает строку отладки для консьюмера Kafka
//
// Возвращаемое значение:
//  Строка - Категории отладки для консьюмера
//
Функция ПолучитьУровеньОтладкиКонсьюмера() Экспорт
	Возврат "consumer,cgrp,topic,fetch";
КонецФункции

// Возвращает строку для сбора всех отладочных событий Kafka
//
// Возвращаемое значение:
//  Строка - Все категории отладки
//
Функция ПолучитьУровеньОтладкиПолный() Экспорт
	Возврат "generic,broker,topic,metadata,feature,queue,msg,protocol,cgrp,security,fetch,interceptor,plugin,consumer,admin,eos,mock,assignor,conf,all";
КонецФункции

#КонецОбласти

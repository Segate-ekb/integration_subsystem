// Модуль конс_ВМ_ОпКодыКлиентСервер
//
// Обработчики опкодов (байткодов) виртуальной машины.
// Каждая процедура/функция реализует один опкод ВМ,
// модифицируя состояние (стек, переменные, указатель команд).
//
// Вызываются через Выполнить из основного модуля ВМ (конс_ВМ_КлиентСервер).

#Область ПрограммныйИнтерфейс

#Область ОбработчикиБайткодов

// Обработчик байткода LINENUM - установка номера текущей строки
Функция НомерСтроки(ВМ, Стек, Команда, ТочкиОстанова, АдресПеременных, НомерУровняСтека) Экспорт
	
	ВМ.НомерСтрокиОстанова = Команда.Аргумент;
	
	// Проверка точек останова (останавливаемся всегда, независимо от глубины)
	Если ТочкиОстанова[Команда.Аргумент] <> Неопределено Тогда
		Возврат конс_ВМ_КлиентСервер.СохранитьСостояниеВМ(ВМ, НомерУровняСтека, АдресПеременных);
	КонецЕсли;
	
	// Проверка "Шагнуть через" — остановка при возврате на нужный уровень вызовов
	Если ВМ.Отладка.МаксимальнаяГлубинаОстановки <> Неопределено
		И ВМ.Стеки.СтекВызовов.Количество() <= ВМ.Отладка.МаксимальнаяГлубинаОстановки Тогда
		Возврат конс_ВМ_КлиентСервер.СохранитьСостояниеВМ(ВМ, НомерУровняСтека, АдресПеременных);
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Обработчик байткода END - завершение подпрограммы
Процедура КонецПодпрограммы(ВМ, Стек, Команда) Экспорт
	
	СтекВызовов = ВМ.Стеки.СтекВызовов;
	
	Если СтекВызовов.Количество() > 0 Тогда
		ЭлементСтека = СтекВызовов[0];
		ВМ.ТекущаяКоманда = ЭлементСтека.ТочкаВызова + 1;
		ВМ.Индексы.КлючиПеременных.Удалить(ВМ.ИдентификаторВызова);
		СтекВызовов.Удалить(0);
		
		Если ВМ.ИсходнаяВМ <> Неопределено И СтекВызовов.Количество() = 0 Тогда
			ВМ.ТекущаяКоманда = ВМ.Программа.Команды.Количество();
			Возврат;
		КонецЕсли;
		
		ИдентификаторыДляОчистки = Новый Соответствие;
		ИдентификаторыДляОчистки.Вставить(ВМ.ИдентификаторВызова, Истина);
		конс_ВМ_КлиентСервер.ОчиститьСтекПоИдентификаторам(ВМ.Стеки.Стек, ИдентификаторыДляОчистки);
		конс_ВМ_КлиентСервер.ОчиститьСтекПоИдентификаторам(ВМ.Стеки.СтекВременныхПеременных, ИдентификаторыДляОчистки);
		ВМ.ИдентификаторВызова = ?(СтекВызовов.Количество() > 0, СтекВызовов[0].ИдентификаторВызова, Неопределено);
	Иначе
		ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	КонецЕсли;
	
КонецПроцедуры

// Обработчик байткода LTE - сравнение "меньше или равно"
Процедура МеньшеРавно(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение <= Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода DIV - деление
Процедура Деление(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение / Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода CALLPROC - вызов процедуры объекта
Процедура ВызовПроцедуры(ВМ, Стек, Команда) Экспорт
	
	конс_ВМ_КлиентСервер.ВыполнитьВызовМетода(ВМ, Стек, Команда, Ложь);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода POPTMP - извлечение из стека временных переменных
Процедура ИзвлечьВременную(ВМ, Стек, Команда) Экспорт
	
	ВМ.Стеки.СтекВременныхПеременных.Удалить(0);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода PUTTMP - помещение в стек временных переменных
Процедура ПоместитьВременную(ВМ, Стек, Команда) Экспорт
	
	ВМ.Стеки.СтекВременныхПеременных.Вставить(0, Новый Структура("Флаг,ИдентификаторВызова,Значение", "Временная", ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода GT - сравнение "больше"
Процедура Больше(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение > Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода LDUNDEF - загрузка значения Неопределено
Процедура ЗагрузитьНеопределено(ВМ, Стек, Команда) Экспорт
	
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Неопределено, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода LDINDEX - загрузка по индексу
Процедура ЗагрузитьПоИндексу(ВМ, Стек, Команда) Экспорт
	
	Индекс = Стек[0].Значение;
	Стек.Удалить(0);
	конс_ВМ_КлиентСервер.ЗагрузитьСвойствоИлиИндекс(ВМ, Стек, Индекс);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода LDVAR - загрузка переменной модуля
Процедура ЗагрузитьПеременную(ВМ, Стек, Команда) Экспорт
	
	Если Команда.Аргумент >= ВМ.Программа.Переменные.Количество() Тогда
		ВызватьИсключение НСтр("ru='Переменная не определена (индекс: ';en='Variable is not defined (index: '", ТекущийЯзыкСистемы()) + Команда.Аргумент + ")";
	КонецЕсли;
	ИсходнаяПеременная = ВМ.Программа.Переменные[Команда.Аргумент];
	
	НоваяПеременная = Новый Структура("Имя,Адрес,Флаг,ВМ,ЗначениеПредСвойства,ИмяСвойства");
	ЗаполнитьЗначенияСвойств(НоваяПеременная, ИсходнаяПеременная);
	НоваяПеременная.Вставить("Значение", конс_ВМ_КлиентСервер.ПолучитьЗначениеПеременнойВМ(ВМ, ИсходнаяПеременная));
	НоваяПеременная.Вставить("ИдентификаторВызова", ВМ.ИдентификаторВызова);
	НоваяПеременная.Вставить("ИсходныйИдентификаторВызова", ИсходнаяПеременная.ИдентификаторВызова);
	
	Стек.Вставить(0, НоваяПеременная);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: NEXT - получение следующего элемента коллекции
// Используется для реализации цикла Для Каждого
Процедура СледующийЭлемент(ВМ, Стек, Команда) Экспорт
	
	Итератор = Стек[0].Значение;
	
	Попытка
		ТекущийЭлемент = Итератор.КоллекцияЭлементов[Итератор.ТекущийЭлемент];
		ПеременнаяСтека = Стек[0];
		Флаг = ПеременнаяСтека.Флаг;
		
		конс_ВМ_КлиентСервер.УстановитьЗначениеПеременной(ВМ, Стек, ПеременнаяСтека, Флаг, ТекущийЭлемент);
		
		Итератор.ТекущийЭлемент = Итератор.ТекущийЭлемент + 1;
		ВМ.Стеки.СтекВременныхПеременных[0].Значение = Итератор;
		
		Стек.Удалить(0);
		Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Истина, ВМ.ИдентификаторВызова));
	Исключение
		Стек.Удалить(0);
		Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Ложь, ВМ.ИдентификаторВызова));
	КонецПопытки;
	
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: JMPFALSE - условный переход при ложном значении
Процедура ПереходПоЛжи(ВМ, Стек, Команда) Экспорт
	
	Если Не Стек[0].Значение Тогда
		ВМ.ТекущаяКоманда = Команда.Аргумент;
	Иначе
		ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	КонецЕсли;
	
	Стек.Удалить(0);
	
КонецПроцедуры

// Обработчик байткода: BLCKEND - конец блока (выход из N уровней попыток).
// Аргумент = количество фреймов СтекПопыток, которые нужно снять.
// Используется при Возврат из подпрограммы или при успешном завершении тела попытки.
Процедура КонецБлока(ВМ, Стек, Команда) Экспорт
	
	СтекПопыток = ВМ.Стеки.СтекПопыток;
	Количество = Команда.Аргумент;
	Пока Количество > 0 Цикл
		СтекПопыток.Удалить(0);
		Количество = Количество - 1;
	КонецЦикла;
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: LDFALSE - загрузка значения Ложь в стек
Процедура ЗагрузитьЛожь(ВМ, Стек, Команда) Экспорт
	
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Ложь, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: INC - инкремент переменной (++counter)
Процедура Инкремент(ВМ, Стек, Команда) Экспорт
	
	Если ВМ.Стеки.СтекВызовов.Количество() > 0 Тогда
		ВМ.Стеки.СтекВызовов[0].Переменные[Стек[0].Адрес].Значение = Стек[0].Значение + 1;
	Иначе
		ВМ.Программа.Переменные[Стек[0].Адрес].Значение = Стек[0].Значение + 1;
	КонецЕсли;
	
	Стек.Удалить(0);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: MOD - остаток от деления (%)
Процедура ОстатокОтДеления(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение % Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: LDLOC - загрузка локальной переменной из стека вызовов
Процедура ЗагрузитьЛокальную(ВМ, Стек, Команда) Экспорт
	
	Если Команда.Аргумент >= ВМ.Стеки.СтекВызовов[0].Переменные.Количество() Тогда
		ВызватьИсключение НСтр("ru='Переменная не определена (индекс: ';en='Variable is not defined (index: '", ТекущийЯзыкСистемы()) + Команда.Аргумент + ")";
	КонецЕсли;
	ИсходнаяПеременная = ВМ.Стеки.СтекВызовов[0].Переменные[Команда.Аргумент];
	
	НоваяПеременная = Новый Структура("Имя,Адрес,Флаг,ВМ,ЗначениеПредСвойства,ИмяСвойства");
	ЗаполнитьЗначенияСвойств(НоваяПеременная, ИсходнаяПеременная);
	НоваяПеременная.Вставить("Значение", конс_ВМ_КлиентСервер.ПолучитьЗначениеПеременнойВМ(ВМ, ИсходнаяПеременная));
	НоваяПеременная.Вставить("ИдентификаторВызова", ВМ.ИдентификаторВызова);
	НоваяПеременная.Вставить("ИсходныйИдентификаторВызова", ИсходнаяПеременная.ИдентификаторВызова);
	
	Стек.Вставить(0, НоваяПеременная);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: BEGINTRY - начало блока Попытка.
// Регистрирует фрейм в стеке попыток (без рекурсии).
// Аргумент = адрес перехода на блок Исключение.
Процедура НачалоПопытки(ВМ, Стек, Команда) Экспорт
	
	ВМ.Стеки.СтекПопыток.Вставить(0, Новый Структура(
		"АдресПерехода,ИдентификаторВызова,КоличествоВременныхПеременных",
		Команда.Аргумент, ВМ.ИдентификаторВызова,
		ВМ.Стеки.СтекВременныхПеременных.Количество()));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: SUB - вычитание
Процедура Вычитание(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение - Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: NOT - логическое отрицание
Процедура ЛогическоеНе(ВМ, Стек, Команда) Экспорт
	конс_ВМ_КлиентСервер.ПоместитьРезультатФункцииВСтек(ВМ, Стек, НЕ Стек[0].Значение, 1);
КонецПроцедуры

// Обработчик байткода: ARGNUM - установка количества аргументов для вызова
Процедура ЧислоАргументов(ВМ, Стек, Команда) Экспорт
	
	ВМ.КоличествоАргументов = Команда.Аргумент;
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: ENDTRY - конец блока Попытка.
// Если на вершине СтекОшибок есть запись с ГлубинаПопыток = текущей глубине СтекПопыток,
// значит мы выходим из блока Исключение — убираем запись об ошибке.
Процедура ЗавершениеПопытки(ВМ, Стек, Команда) Экспорт
	
	СтекОшибок = ВМ.Стеки.СтекОшибок;
	Если СтекОшибок.Количество() > 0
		И СтекОшибок[0].ГлубинаПопыток = ВМ.Стеки.СтекПопыток.Количество() Тогда
		СтекОшибок.Удалить(0);
	КонецЕсли;
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: ERRDESCR - ОписаниеОшибки().
// Помещает текст текущей ошибки из СтекОшибок в стек операндов.
// Если СтекОшибок пуст — помещает пустую строку.
Процедура ОписаниеОшибкиВСтек(ВМ, Стек, Команда) Экспорт
	
	СтекОшибок = ВМ.Стеки.СтекОшибок;
	Если СтекОшибок.Количество() > 0 Тогда
		Текст = СтекОшибок[0].ОписаниеОшибки;
	Иначе
		Текст = "";
	КонецЕсли;
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Текст, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: ERRINFO - ИнформацияОбОшибке().
// Помещает объект ИнформацияОбОшибке из текста текущей ошибки в стек операндов.
// Если СтекОшибок пуст — помещает ИнформацияОбОшибке() платформы (может быть Неопределено).
Процедура ИнформацияОбОшибкеВСтек(ВМ, Стек, Команда) Экспорт
	
	СтекОшибок = ВМ.Стеки.СтекОшибок;
	Если СтекОшибок.Количество() > 0 Тогда
		ОбъектОшибки = конс_ВМ_КлиентСервер.ТекстВИнформациюОбОшибке(СтекОшибок[0].ОписаниеОшибки);
	Иначе
		ОбъектОшибки = ИнформацияОбОшибке();
	КонецЕсли;
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", ОбъектОшибки, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: GOTO - безусловный переход к метке
Процедура ПереходКМетке(ВМ, Стек, Команда) Экспорт
	
	ВМ.ТекущаяКоманда = ВМ.Программа.Метки[Команда.Аргумент].АдресКоманды;
	
КонецПроцедуры

// Обработчик байткода: LT - сравнение меньше (<)
Процедура Меньше(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение < Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: LDTRUE - загрузка значения Истина в стек
Процедура ЗагрузитьИстину(ВМ, Стек, Команда) Экспорт
	
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Истина, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: CALLLOC - вызов локальной процедуры/функции
// Это самый сложный обработчик - обрабатывает вызов внутренних подпрограмм
Процедура ВызовПодпрограммы(ВМ, Стек, Команда) Экспорт
	
	Подпрограмма = ВМ.Программа.Подпрограммы[Команда.Аргумент];
	ФлагПодпрограммы = Подпрограмма.Флаг;
	
	// ВнешняяФункция / ВнешняяПроцедура — вызов глобального метода контекста
	// или локальной подпрограммы исходной ВМ (при вычислении выражения)
	Если ФлагПодпрограммы = "ВнешняяФункция" ИЛИ ФлагПодпрограммы = "ВнешняяПроцедура" Тогда
		// Проверяем, не является ли эта подпрограмма локальной функцией/процедурой
		// из исходной ВМ (например, при вычислении выражения во время отладки)
		ЛокальнаяПодпрограмма = ВМ.Индексы.КлючиЛокальныхПодпрограмм[ВРег(Подпрограмма.Имя)];
		Если ЛокальнаяПодпрограмма <> Неопределено Тогда
			конс_ВМ_КлиентСервер.ВызватьВнутреннююПодпрограмму(ВМ, Стек, Команда, ЛокальнаяПодпрограмма, ЛокальнаяПодпрограмма.Флаг);
		Иначе
			ЭтоФункция = (ФлагПодпрограммы = "ВнешняяФункция");
			конс_ВМ_КлиентСервер.ВызватьВнешнююПодпрограмму(ВМ, Стек, Команда, ЭтоФункция);
			ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
		КонецЕсли;
		
	Иначе
		// Внутренняя или экспортная подпрограмма
		конс_ВМ_КлиентСервер.ВызватьВнутреннююПодпрограмму(ВМ, Стек, Команда, Подпрограмма, ФлагПодпрограммы);
	КонецЕсли;
	
КонецПроцедуры

// Обработчик байткода: MINUS - унарный минус (смена знака)
Процедура УнарныйМинус(ВМ, Стек, Команда) Экспорт
	конс_ВМ_КлиентСервер.ПоместитьРезультатФункцииВСтек(ВМ, Стек, -Стек[0].Значение, 1);
КонецПроцедуры

// Обработчик байткода: CALLFUNC - вызов функции объекта
Процедура ВызовФункции(ВМ, Стек, Команда) Экспорт
	
	конс_ВМ_КлиентСервер.ВыполнитьВызовМетода(ВМ, Стек, Команда);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: OR - логическое ИЛИ с коротким замыканием
Процедура ЛогическоеИли(ВМ, Стек, Команда) Экспорт
	
	Результат = Булево(Стек[0].Значение);
	Стек.Удалить(0);
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Результат, ВМ.ИдентификаторВызова));
	
	Если Стек[0].Значение = Истина Тогда
		ВМ.ТекущаяКоманда = Команда.Аргумент;
	Иначе
		Стек.Удалить(0);
		ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	КонецЕсли;
	
КонецПроцедуры

// Обработчик байткода: JMP - безусловный переход
Процедура Переход(ВМ, Стек, Команда) Экспорт
	
	ВМ.ТекущаяКоманда = Команда.Аргумент;
	
КонецПроцедуры

// Обработчик байткода: LDNULL - загрузка значения Null в стек
Процедура ЗагрузитьNull(ВМ, Стек, Команда) Экспорт
	
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Null, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: AND - логическое И с коротким замыканием
Процедура ЛогическоеИ(ВМ, Стек, Команда) Экспорт
	
	Результат = Булево(Стек[0].Значение);
	Стек.Удалить(0);
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Результат, ВМ.ИдентификаторВызова));
	
	Если Стек[0].Значение = Ложь Тогда
		ВМ.ТекущаяКоманда = Команда.Аргумент;
	Иначе
		Стек.Удалить(0);
		ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	КонецЕсли;
	
КонецПроцедуры

// Обработчик байткода: MUL - умножение
Процедура Умножение(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение * Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: LDCONST - загрузка константы в стек
Процедура ЗагрузитьКонстанту(ВМ, Стек, Команда) Экспорт
	
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", ВМ.Программа.Константы[Команда.Аргумент].Значение, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: ADD - сложение
Процедура Сложение(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение + Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: LDRET - загрузка результата функции в стек
Процедура ЗагрузитьРезультат(ВМ, Стек, Команда) Экспорт
	
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", ВМ.РезультатФункции.Значение, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: NE - сравнение на неравенство (<>)
Процедура НеРавно(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение <> Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: ASSIGN - присваивание значения переменной
Процедура Присвоить(ВМ, Стек, Команда) Экспорт
	
	ПеременнаяНазначения = Стек[1];
	ФлагПеременной = ПеременнаяНазначения.Флаг;
	
	Если ФлагПеременной <> "Временная" Тогда
		// Обычная переменная
		конс_ВМ_КлиентСервер.УстановитьЗначениеПеременной(ВМ, Стек, ПеременнаяНазначения, ФлагПеременной, Стек[0].Значение);
	Иначе
		// Временная переменная (итератор цикла Для Каждого)
		ВременнаяПеременная = ВМ.Стеки.СтекВременныхПеременных[0];
		ВременнаяПеременная.Значение = Стек[0].Значение;
	КонецЕсли;
	
	Стек.Удалить(0);
	Стек.Удалить(0);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: RAISE - вызов исключения.
// Аргумент = 0: перевызов текущей ошибки (из СтекОшибок).
// Аргумент <> 0: вызов нового исключения из стека операндов.
Процедура ВызовИсключения(ВМ, Стек, Команда) Экспорт
	
	Если Команда.Аргумент = 0 Тогда
		// Перевызов: берём текст ошибки из СтекОшибок
		СтекОшибок = ВМ.Стеки.СтекОшибок;
		Если СтекОшибок.Количество() > 0 Тогда
			ТекстИсключения = СтекОшибок[0].ОписаниеОшибки;
			СтекОшибок.Удалить(0);
			ВызватьИсключение ТекстИсключения;
		Иначе
			ВызватьИсключение "Нет текущего исключения для перевызова";
		КонецЕсли;
	Иначе
		// Новое исключение из стека операндов
		ТекстИсключения = Стек[0].Значение;
		Стек.Удалить(0);
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
КонецПроцедуры

// Обработчик байткода: ITER - создание итератора для цикла Для Каждого
Процедура СоздатьИтератор(ВМ, Стек, Команда) Экспорт
	
	Коллекция = Стек[0].Значение;
	
	Попытка
		// Проверка на Соответствие (нужна особая обработка)
		Если ТипЗнч(Коллекция) = Тип("Соответствие") Тогда
			ВызватьИсключение "";
		КонецЕсли;
		// Проверка доступа по индексу
		ПервыйЭлемент = Коллекция[0];
		КоллекцияЭлементов = Коллекция;
	Исключение
		// Конвертация в массив для коллекций без индексного доступа
		КоллекцияЭлементов = Новый Массив;
		Для Каждого Элемент Из Коллекция Цикл
			КоллекцияЭлементов.Добавить(Элемент);
		КонецЦикла;
	КонецПопытки;
	
	Итератор = Новый Структура("КоллекцияЭлементов,ТекущийЭлемент", КоллекцияЭлементов, 0);
	
	Стек.Удалить(0);
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Итератор, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: LDPROP - загрузка свойства объекта
Процедура ЗагрузитьСвойство(ВМ, Стек, Команда) Экспорт
	
	ИмяСвойства = ВМ.Программа.Константы[Команда.Аргумент].Значение;
	конс_ВМ_КлиентСервер.ЗагрузитьСвойствоИлиИндекс(ВМ, Стек, ИмяСвойства);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: RET - возврат значения из функции
Процедура ВозвратЗначения(ВМ, Стек, Команда) Экспорт
	
	ВМ.РезультатФункции.Значение = Стек[0].Значение;
	Стек.Удалить(0);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: CMP - сравнение на равенство (=)
Процедура Сравнение(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение = Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: GTE - сравнение больше или равно (>=)
Процедура БольшеРавно(ВМ, Стек, Команда) Экспорт
	
	УстановитьРезультатБинарнойОперации(ВМ, Стек[1].Значение >= Стек[0].Значение, Стек);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: LDTMP - загрузка временной переменной в стек
Процедура ЗагрузитьВременную(ВМ, Стек, Команда) Экспорт
	
	НоваяПеременная = Новый Структура(
		"Значение,Флаг,ИдентификаторВызова",
		ВМ.Стеки.СтекВременныхПеременных[0].Значение,
		"Временная",
		ВМ.ИдентификаторВызова
	);
	Стек.Вставить(0, НоваяПеременная);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: EXEC - выполнение динамического кода (Выполнить)
Процедура ВыполнитьКод(ВМ, Стек, Команда) Экспорт
	
	ТекстКода = Стек[0].Значение;
	Стек.Удалить(0);
	
	РезультатКомпиляции = конс_КомпиляцияКлиентСервер.ВыполнитьКомпиляцию(ТекстКода, ВМ.АдресТаблицПерехода, Истина);
	
	Если Не РезультатКомпиляции.ВыполнениеВозможно Тогда
		Для Каждого Ошибка Из РезультатКомпиляции.Ошибки Цикл
			Если Ошибка.Тип = 0 Тогда
				ВызватьИсключение Ошибка.Название;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ВложеннаяВМ = конс_ВМ_КлиентСервер.СоздатьВложеннуюВМДляВыполнения(ВМ, РезультатКомпиляции);
	
	конс_ВМ_КлиентСервер.ПродолжитьОтладку(ВложеннаяВМ, Неопределено, Ложь, Новый Соответствие);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: LDNONE - загрузка пустого значения (для пропущенных параметров)
Процедура ЗагрузитьПустое(ВМ, Стек, Команда) Экспорт
	
	Стек.Вставить(0, Новый Структура("ЭтоПустоеЗначение,ИдентификаторВызова,Значение", Истина, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	
КонецПроцедуры

// Обработчик байткода: TYPEOF - получение типа значения
Процедура ТипЗначения(ВМ, Стек, Команда) Экспорт
	конс_ВМ_КлиентСервер.ПоместитьРезультатФункцииВСтек(ВМ, Стек, ТипЗнч(Стек[0].Значение), 1);
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиВстроенныхФункций

// Обработчик встроенной функции NEW с произвольным числом параметров (Новый с типом и массивом параметров)
Процедура КонструкторОбъекта(ВМ, Стек, Команда) Экспорт
	
	МассивПараметров = Новый Массив;
	
	Пока ВМ.КоличествоАргументов > 0 Цикл
		МассивПараметров.Вставить(0, Стек[0].Значение);
		Стек.Удалить(0);
		ВМ.КоличествоАргументов = ВМ.КоличествоАргументов - 1;
	КонецЦикла;
	
	конс_ВМ_КлиентСервер.ПоместитьРезультатФункцииВСтек(ВМ, Стек, Новый(Тип(ВМ.Программа.Константы[Команда.Аргумент].Значение), МассивПараметров));
КонецПроцедуры

// Обработчик встроенной функции MIN (Мин) — переменное число аргументов
Процедура Минимум(ВМ, Стек, Команда) Экспорт
	конс_ВМ_КлиентСервер.ВычислитьФункциюСПеременнымЧисломАргументов(ВМ, Стек, "МИН");
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
КонецПроцедуры

// Обработчик встроенной функции MAX (Макс) — переменное число аргументов
Процедура Максимум(ВМ, Стек, Команда) Экспорт
	конс_ВМ_КлиентСервер.ВычислитьФункциюСПеременнымЧисломАргументов(ВМ, Стек, "МАКС");
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
КонецПроцедуры

// Обработчик ДобавитьОбработчик с локальной процедурой (не поддерживается)
Процедура ДобавитьОбработчикЛокальный(ВМ, Стек, Команда) Экспорт
	Стек.Удалить(0);
	Стек.Удалить(0);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	ВызватьИсключение НСтр("ru='В данной консоли кода невозможно использование локальной процедуры/функции в качестве обработчика';en='In this code console it is not possible to use a local procedure/function as a handler'", ТекущийЯзыкСистемы());
КонецПроцедуры

// Обработчик ДобавитьОбработчик с внешним объектом
Процедура ДобавитьОбработчикВнешний(ВМ, Стек, Команда) Экспорт
	Выполнить "ДобавитьОбработчик Стек[3].Значение." + Стек[2].Значение + ", " + "Стек[1].Значение." + Стек[0].Значение;
	Стек.Удалить(0);
	Стек.Удалить(0);
	Стек.Удалить(0);
	Стек.Удалить(0);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
КонецПроцедуры

// Обработчик УдалитьОбработчик с локальной процедурой (не поддерживается)
Процедура УдалитьОбработчикЛокальный(ВМ, Стек, Команда) Экспорт
	Стек.Удалить(0);
	Стек.Удалить(0);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	ВызватьИсключение НСтр("ru='В данной консоли кода невозможно использование локальной процедуры/функции в качестве обработчика';en='In this code console it is not possible to use a local procedure/function as a handler'", ТекущийЯзыкСистемы());
КонецПроцедуры

// Обработчик УдалитьОбработчик с внешним объектом
Процедура УдалитьОбработчикВнешний(ВМ, Стек, Команда) Экспорт
	Выполнить "УдалитьОбработчик Стек[3].Значение." + Стек[2].Значение + ", " + "Стек[1].Значение." + Стек[0].Значение;
	Стек.Удалить(0);
	Стек.Удалить(0);
	Стек.Удалить(0);
	Стек.Удалить(0);
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Записывает результат бинарной операции в стек
Процедура УстановитьРезультатБинарнойОперации(ВМ, Результат, Стек)
	Стек.Удалить(0);
	Стек.Удалить(0);
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Результат, ВМ.ИдентификаторВызова));
КонецПроцедуры

#КонецОбласти

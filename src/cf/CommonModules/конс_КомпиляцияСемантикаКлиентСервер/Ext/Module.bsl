// Модуль конс_КомпиляцияСемантикаКлиентСервер
//
// Семантические действия компилятора BSL.
// Извлечены из конс_КомпиляцияКлиентСервер для улучшения модульности.
//
// Процедуры семантических действий вызываются при редукции нетерминалов.
// Все семантические действия имеют единую сигнатуру:
//   Процедура _ИмяНетерминала(Сем, Узел, Компиляция, Ошибки)
//
// Диспатчеризация осуществляется динамически через Выполнить.
// Имена процедур _* определяются грамматикой и НЕ подлежат переименованию.

#Область ПрограммныйИнтерфейс

// Выполняет семантическое действие для узла AST.
// Диспатчеризует вызов процедуры _ИмяНетерминала по имени нетерминала узла.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел AST с полем Нетерминал
//  Компиляция - Структура, Неопределено - дополнительные данные компиляции
//  Ошибки - Массив - накопитель ошибок
Процедура ВыполнитьСемантическоеДействие(Сем, Узел, Компиляция, Ошибки) Экспорт
	Выполнить "_" + Узел.Нетерминал + "(Сем, Узел, Компиляция, Ошибки)";
КонецПроцедуры

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

Процедура ЗагрузитьПеременнуюНаСтек(ДочернийУзел, Сем, Ошибки, РодительскийУзел, ПозицияВставки = Неопределено)
	Если НЕ ДочернийУзел.Свойство("Нетерминал") ИЛИ НЕ ДочернийУзел.Атрибуты.Свойство("ИмяПеременной") Тогда
		Возврат;
	КонецЕсли;
	Данные = конс_КомпиляцияКлиентСервер.ПолучитьДанныеПеременнойВМ(ДочернийУзел.Атрибуты.ИмяПеременной, Сем, Ошибки, РодительскийУзел.НомерСтроки);
	ЭмитироватьКоманду(Данные.ОпКод, Данные.Адрес, Сем, РодительскийУзел, ПозицияВставки);
КонецПроцедуры

// Эмитирует команду ВМ с сокращённым синтаксисом.
// Упрощает цепочечную генерацию команд в семантических процедурах.
//
// Параметры:
//  ОпКод - Строка - код операции виртуальной машины
//  Арг - Число - аргумент команды (по умолчанию 0)
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел AST
//  Пред - УникальныйИдентификатор, Неопределено - идентификатор предыдущей команды (позиция вставки)
//  Связь - УникальныйИдентификатор, Неопределено - связанная команда для аргумента
//  Сдвиг - Число - смещение для аргумента
//
// Возвращаемое значение:
//  УникальныйИдентификатор - идентификатор добавленной команды
Функция ЭмитироватьКоманду(ОпКод, Арг, Сем, Узел, Пред = Неопределено, Связь = Неопределено, Сдвиг = 0)
	Возврат конс_КомпиляцияКлиентСервер.ДобавитьКомандуВМ(ОпКод, Арг, Сем, Узел, Пред, Связь, Сдвиг);
КонецФункции

// Считает аргументы вызова и эмитирует команду ЧИСЛОАРГ если нужно.
// Общий паттерн для _Вызов, _ВызовПроцедуры, _ВызовМетода, _ВызовМетодаПроцедуры.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел вызова (содержит имя и аргументы)
//
// Возвращаемое значение:
//  Число - количество аргументов вызова
Функция ПосчитатьАргументыВызова(Сем, Узел)
	КоличествоАргументов = 0;
	ИмяВРег = "";
	Если Узел.СоставУзла[0].Свойство("Терминал") Тогда
		ИмяВРег = ВРег(Узел.СоставУзла[0].Значение);
	КонецЕсли;
	Если Узел.СоставУзла[2].Свойство("Нетерминал") Тогда
		КоличествоАргументов = Узел.СоставУзла[2].Атрибуты.ТекущееКоличествоАргументов;
	КонецЕсли;
	ЭтоМинМакс = (ИмяВРег = "МАКС" ИЛИ ИмяВРег = "МИН");
	Если Сем.ИменаВстроенныхФункций[ИмяВРег] = Неопределено ИЛИ ЭтоМинМакс Тогда
		ЭмитироватьКоманду("ЧИСЛОАРГ", КоличествоАргументов, Сем, Узел);
	КонецЕсли;
	Узел.Атрибуты.Вставить("КоличествоАргументов", КоличествоАргументов);
	Возврат КоличествоАргументов;
КонецФункции

// Общая логика обработки заголовка процедуры/функции.
// Проверяет конфликты имён, регистрирует подпрограмму и её аргументы.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел заголовка (ProcedureHeader или FunctionHeader)
//  Ошибки - Массив - массив ошибок компиляции
Процедура ОбработатьЗаголовокПодпрограммы(Сем, Узел, Ошибки)
	Если Сем.РежимВыполнить Тогда
		ТекстОшибки = НСтр("ru='Ожидается последовательность операторов';en='Sequence of operators expected'", ТекущийЯзыкСистемы());
		Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 0, ТекстОшибки));
	КонецЕсли;
	ИмяПодпрограммыВерхнийРегистр = ВРег(Узел.СоставУзла[1].Значение);
	Если Сем.МетодыГлобальногоКонтекста[ИмяПодпрограммыВерхнийРегистр] <> Неопределено ИЛИ Сем.ИменаВстроенныхФункций[ИмяПодпрограммыВерхнийРегистр] <> Неопределено Тогда
		ТекстОшибки = НСтр("ru='Имена объявленных процедур и функций не должны совпадать с именами процедур и функций глобального контекста (';en='The names of declared procedures and functions must not coincide with the names of procedures and functions of the global context ('", ТекущийЯзыкСистемы()) + Узел.СоставУзла[1].Значение + ")";
		Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 0, ТекстОшибки, Узел.СоставУзла[1].НомерСтроки));
	КонецЕсли;
	ОписаниеПодпрограммы = Сем.Подпрограммы[ИмяПодпрограммыВерхнийРегистр];
	Если ОписаниеПодпрограммы <> Неопределено И ОписаниеПодпрограммы.Флаг <> "ВнешняяПроцедура" И ОписаниеПодпрограммы.Флаг <> "ВнешняяФункция" Тогда
		ТекстОшибки = НСтр("ru='Процедура или функция с указанным именем уже определена (';en='A procedure or function with the specified name is already defined ('", ТекущийЯзыкСистемы()) + Узел.СоставУзла[1].Значение + ")";
		Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 0, ТекстОшибки, Узел.СоставУзла[1].НомерСтроки));
	КонецЕсли;
	МассивАргументов = Новый Массив;
	Если Узел.СоставУзла[3].Свойство("Нетерминал") Тогда
		МассивАргументов = Узел.СоставУзла[3].Атрибуты.МассивАргументов;
		КоличествоАргументов = МассивАргументов.Количество();
	Иначе
		КоличествоАргументов = 0;
	КонецЕсли;
	ИндексПоследнего = Узел.СоставУзла.Количество() - 1;
	Если Узел.СоставУзла[0].Нетерминал = "Ключ_Функция" Тогда
		ФлагПодпрограммы = ?(Узел.СоставУзла[ИндексПоследнего].Терминал = "Ключ_Экспорт", "ЭкспортФункция", "Функция"); // 17 - экспорт функция, 1 - локальная функция
	Иначе
		ФлагПодпрограммы = ?(Узел.СоставУзла[ИндексПоследнего].Терминал = "Ключ_Экспорт", "ЭкспортПроцедура", "Процедура"); // 16 - экспорт процедура, 0 - локальная процедура
	КонецЕсли;
	ОписаниеПодпрограммы = конс_КомпиляцияКлиентСервер.ПолучитьПодпрограммуВМ(Узел.СоставУзла[1].Значение, Сем, ФлагПодпрограммы, КоличествоАргументов);
	СчетчикАргументов = 0;
	Для Каждого ОписаниеАргумента Из МассивАргументов Цикл
		ОписаниеПодпрограммы.Переменные.Вставить(ВРег(ОписаниеАргумента.Имя), Новый Структура("Адрес,Флаг,Имя", СчетчикАргументов, ОписаниеАргумента.Флаг, ОписаниеАргумента.Имя));
		ОписаниеПодпрограммы.ЗначенияПоУмолчанию.Добавить(ОписаниеАргумента.ЗначениеПоУмолчанию);
		СчетчикАргументов = СчетчикАргументов + 1;
	КонецЦикла;
	Сем.ЧтениеПодпрограммы = Истина;
	Сем.КлючТекущейПодпрограммы = ВРег(ОписаниеПодпрограммы.Имя);
	Сем.Вставить("ИдентификаторКомандыПоследнейОстановки", Новый УникальныйИдентификатор);
	Сем.ЧтениеЗаголовкаПодпрограммы = Ложь;
КонецПроцедуры

// Собирает идентификаторы команд выхода (Прервать) и продолжения (Продолжить)
// из дочерних нетерминалов узла AST и устанавливает их в атрибуты узла.
//
// Параметры:
//  Узел - Структура - узел AST, из дочерних узлов которого собираются идентификаторы
Процедура СобратьИдентификаторыВыходаИПродолжения(Узел)
	ИдентификаторыВыхода = Новый Массив;
	ИдентификаторыПродолжения = Новый Массив;
	Для Каждого ЭлементСостава Из Узел.СоставУзла Цикл
		Если ЭлементСостава.Свойство("Нетерминал") И ЭлементСостава.Атрибуты.Свойство("ИдентификаторыКомандВыхода") Тогда
			Для Каждого ИдентификаторКоманды Из ЭлементСостава.Атрибуты.ИдентификаторыКомандВыхода Цикл
				ИдентификаторыВыхода.Добавить(ИдентификаторКоманды);
			КонецЦикла;
		КонецЕсли;
		Если ЭлементСостава.Свойство("Нетерминал") И ЭлементСостава.Атрибуты.Свойство("ИдентификаторыКомандПродолжения") Тогда
			Для Каждого ИдентификаторКоманды Из ЭлементСостава.Атрибуты.ИдентификаторыКомандПродолжения Цикл
				ИдентификаторыПродолжения.Добавить(ИдентификаторКоманды);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	Если ИдентификаторыВыхода.Количество() <> 0 Тогда
		Узел.Атрибуты.Вставить("ИдентификаторыКомандВыхода", ИдентификаторыВыхода);
	КонецЕсли;
	Если ИдентификаторыПродолжения.Количество() <> 0 Тогда
		Узел.Атрибуты.Вставить("ИдентификаторыКомандПродолжения", ИдентификаторыПродолжения);
	КонецЕсли;
КонецПроцедуры

// Собирает массив подпрограмм ВМ из семантических данных.
// Для каждой подпрограммы формирует описание с переменными и значениями по умолчанию.
//
// Параметры:
//  ДанныеСем - Структура - семантические данные (Подпрограммы)
//  ПодпрограммыВМФинал - Массив - целевой массив подпрограмм ВМ
Процедура СобратьПодпрограммыВМ(ДанныеСем, ПодпрограммыВМФинал)
	// Инвертировать соответствие: адрес → описание подпрограммы
	СоответствиеПоАдресу = Новый Соответствие;
	Для Каждого Запись Из ДанныеСем.Подпрограммы Цикл
		СоответствиеПоАдресу.Вставить(Запись.Значение.Адрес, Запись.Значение);
	КонецЦикла;
	Индекс = 0;
	Пока Индекс < ДанныеСем.Подпрограммы.Количество() Цикл
		ОписаниеИсходное = СоответствиеПоАдресу[Индекс];
		ОписаниеВМ = Новый Структура("Имя,Флаг,ЧислоАргументов,ТочкаВхода,Адрес");
		ЗаполнитьЗначенияСвойств(ОписаниеВМ, ОписаниеИсходное);
		ОписаниеВМ.ТочкаВхода = ?(ОписаниеВМ.ТочкаВхода = Неопределено, 0, ОписаниеВМ.ТочкаВхода - 1);
		ПодпрограммыВМФинал.Добавить(ОписаниеВМ);
		// Собрать переменные подпрограммы с значениями по умолчанию
		ПеременныеПоАдресу = Новый Соответствие;
		Для Каждого ЗаписьПеременной Из ОписаниеИсходное.Переменные Цикл
			ПеременныеПоАдресу.Вставить(ЗаписьПеременной.Значение.Адрес, ЗаписьПеременной.Значение);
		КонецЦикла;
		ИндексПеременной = 0;
		МассивПеременных = Новый Массив;
		Пока ИндексПеременной < ОписаниеИсходное.Переменные.Количество() Цикл
			ОписаниеПеременной = Новый Структура("Инициализирована,ЗначениеПоУмолчаниюСуществует,Флаг,Имя,Значение,ЗначениеПоУмолчанию,ЗначениеПредСвойства,ИмяСвойства", Ложь, Ложь);
			ЗаполнитьЗначенияСвойств(ОписаниеПеременной, ПеременныеПоАдресу[ИндексПеременной]);
			МассивПеременных.Добавить(ОписаниеПеременной);
			КоличествоЗначенийПоУмолчанию = ОписаниеИсходное.ЗначенияПоУмолчанию.Количество();
			Если ИндексПеременной < КоличествоЗначенийПоУмолчанию Тогда
				ЗначениеПоУмолч = ОписаниеИсходное.ЗначенияПоУмолчанию[ИндексПеременной];
				Если ТипЗнч(ЗначениеПоУмолч) <> Тип("Структура") Тогда
					ОписаниеПеременной.ЗначениеПоУмолчаниюСуществует = Истина;
					ОписаниеПеременной.ЗначениеПоУмолчанию = ЗначениеПоУмолч;
				КонецЕсли;
			КонецЕсли;
			ИндексПеременной = ИндексПеременной + 1;
		КонецЦикла;
		ОписаниеВМ.Вставить("Переменные", МассивПеременных);
		Индекс = Индекс + 1;
	КонецЦикла;
КонецПроцедуры

// Проверяет корректность всех вызовов подпрограмм:
// - наличие внешних функций/процедур в глобальном контексте
// - вызов процедуры как функции
// - количество фактических параметров vs формальных
//
// Параметры:
//  ДанныеСем - Структура - семантические данные (Вызовы, Подпрограммы)
//  Ошибки - Массив - массив ошибок компиляции
Процедура ПроверитьВызовыПодпрограмм(ДанныеСем, Ошибки)
	Для Каждого ОписаниеВызова Из ДанныеСем.Вызовы Цикл
		ОписаниеПодпрограммы = ДанныеСем.Подпрограммы[ВРег(ОписаниеВызова.Терминал.Значение)];
		Если ОписаниеПодпрограммы = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ПроверитьОдинВызовПодпрограммы(ОписаниеВызова, ОписаниеПодпрограммы, ДанныеСем, Ошибки);
	КонецЦикла;
КонецПроцедуры

// Проверяет корректность одного вызова подпрограммы:
// - для внешних - наличие в глобальном контексте
// - вызов процедуры как функции
// - количество аргументов
//
// Параметры:
//  ОписаниеВызова - Структура - описание вызова с полями Терминал, КоличествоАргументов, ВызовФункции
//  ОписаниеПодпрограммы - Структура - описание подпрограммы с полями Флаг, ЗначенияПоУмолчанию
//  ДанныеСемантики - Структура - данные семантического анализа
//  Ошибки - Массив - массив ошибок компиляции для накопления
Процедура ПроверитьОдинВызовПодпрограммы(ОписаниеВызова, ОписаниеПодпрограммы, ДанныеСемантики, Ошибки)
	ФлагПодпрограммы = ОписаниеПодпрограммы.Флаг;
	// Внешние подпрограммы - проверяем наличие в глобальном контексте
	Если ФлагПодпрограммы = "ВнешняяФункция" ИЛИ ФлагПодпрограммы = "ВнешняяПроцедура" Тогда
		ПроверитьНаличиеВнешнейПодпрограммы(ОписаниеВызова, ОписаниеПодпрограммы, ДанныеСемантики, Ошибки);
		Возврат;
	КонецЕсли;
	// Вызов процедуры как функции
	Если ОписаниеВызова.ВызовФункции И (ФлагПодпрограммы = "Процедура" ИЛИ ФлагПодпрограммы = "ЭкспортПроцедура") Тогда
		конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, НСтр("ru='Обращение к процедуре как к функции (';en='Procedure called as function ('", ТекущийЯзыкСистемы()) + ОписаниеВызова.Терминал.Значение + ")", ДанныеСемантики, ОписаниеВызова.Терминал);
	КонецЕсли;
	ПроверитьКоличествоАргументовВызова(ОписаниеВызова, ОписаниеПодпрограммы, ДанныеСемантики, Ошибки);
КонецПроцедуры

// Проверяет наличие внешней подпрограммы в глобальном контексте.
//
// Параметры:
//  ОписаниеВызова - Структура - описание вызова с полем Терминал
//  ОписаниеПодпрограммы - Структура - описание подпрограммы с полем Имя
//  ДанныеСемантики - Структура - данные семантического анализа с МетодыГлобальногоКонтекста
//  Ошибки - Массив - массив ошибок для накопления
Процедура ПроверитьНаличиеВнешнейПодпрограммы(ОписаниеВызова, ОписаниеПодпрограммы, ДанныеСемантики, Ошибки)
	Если ДанныеСемантики.МетодыГлобальногоКонтекста[ВРег(ОписаниеПодпрограммы.Имя)] = Неопределено Тогда
		ТекстОшибки = НСтр("ru='Метод не найден (';en='Procedure or function with the specified name is not defined ('", ТекущийЯзыкСистемы()) + ОписаниеВызова.Терминал.Значение + ")";
		Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 1, ТекстОшибки, ОписаниеВызова.Терминал.НомерСтроки));
	КонецЕсли;
КонецПроцедуры

// Проверяет соответствие количества фактических аргументов формальным параметрам.
//
// Параметры:
//  ОписаниеВызова - Структура - описание вызова с полями Терминал, КоличествоАргументов
//  ОписаниеПодпрограммы - Структура - описание подпрограммы с полем ЗначенияПоУмолчанию
//  ДанныеСемантики - Структура - данные семантического анализа
//  Ошибки - Массив - массив ошибок компиляции для накопления
Процедура ПроверитьКоличествоАргументовВызова(ОписаниеВызова, ОписаниеПодпрограммы, ДанныеСемантики, Ошибки)
	ЗначенияПоУмолчанию = ОписаниеПодпрограммы.ЗначенияПоУмолчанию;
	КоличествоПараметров = ЗначенияПоУмолчанию.Количество();
	Если ОписаниеВызова.КоличествоАргументов > КоличествоПараметров Тогда
		конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, НСтр("ru='Слишком много фактических параметров (';en='Too many actual parameters ('", ТекущийЯзыкСистемы()) + ОписаниеВызова.Терминал.Значение + ")", ДанныеСемантики, ОписаниеВызова.Терминал);
	ИначеЕсли ОписаниеВызова.КоличествоАргументов < КоличествоПараметров Тогда
		ПроверитьНедостающиеАргументы(ОписаниеВызова, ЗначенияПоУмолчанию, КоличествоПараметров, ДанныеСемантики, Ошибки);
	Иначе
		// Количество аргументов совпадает
	КонецЕсли;
КонецПроцедуры

// Проверяет, все ли недостающие фактические аргументы имеют значения по умолчанию.
//
// Параметры:
//  ОписаниеВызова - Структура - описание вызова с полями Терминал, КоличествоАргументов
//  ЗначенияПоУмолчанию - Массив - массив значений по умолчанию для параметров подпрограммы
//  КоличествоПараметров - Число - общее количество формальных параметров
//  ДанныеСемантики - Структура - данные семантического анализа
//  Ошибки - Массив - массив ошибок компиляции для накопления
Процедура ПроверитьНедостающиеАргументы(ОписаниеВызова, ЗначенияПоУмолчанию, КоличествоПараметров, ДанныеСемантики, Ошибки)
	Индекс = ОписаниеВызова.КоличествоАргументов;
	Пока Индекс < КоличествоПараметров Цикл
		Если ТипЗнч(ЗначенияПоУмолчанию[Индекс]) = Тип("Структура") Тогда
			конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, НСтр("ru='Недостаточно фактических параметров (';en='Not enough actual parameters ('", ТекущийЯзыкСистемы()) + ОписаниеВызова.Терминал.Значение + ")", ДанныеСемантики, ОписаниеВызова.Терминал);
			Прервать;
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
КонецПроцедуры

// Определяет точку входа (адрес первой исполняемой команды) в программе.
//
// Параметры:
//  Узел - Структура - корневой узел AST-дерева программы
//  СписокКоманд - Массив - список команд ВМ
//
// Возвращаемое значение:
//  Число - адрес (индекс) первой исполняемой команды
Функция ОпределитьТочкуВходаПрограммы(Узел, СписокКоманд)
	Если Узел.СоставУзла.Количество() = 0 Тогда
		Возврат 0;
	КонецЕсли;
	СоставПрограммы = Узел.СоставУзла[0].СоставУзла;
	ПоследнийЭлемент = СоставПрограммы[СоставПрограммы.Количество() - 1];
	Если ПоследнийЭлемент.Нетерминал <> "СписокОператоров" Тогда
		Возврат СписокКоманд.Количество() - 2;
	Иначе
		Возврат СписокКоманд.Количество() - ПоследнийЭлемент.Атрибуты.КоличествоОпераций - 1;
	КонецЕсли;
КонецФункции

// Собирает финальный массив констант ВМ из семантических данных.
//
// Параметры:
//  Сем - Структура - данные семантического анализа с соответствием констант
//  КонстантыВМФинал - Массив - результирующий массив для заполнения структурами констант
Процедура СобратьКонстантыВМФинальные(Сем, КонстантыВМФинал)
	СоответствиеКонстант = Новый Соответствие;
	Для Каждого Запись Из Сем.Константы Цикл
		СоответствиеКонстант.Вставить(Запись.Значение, Запись.Ключ);
	КонецЦикла;
	Счетчик = 0;
	Пока Счетчик < Сем.Константы.Количество() Цикл
		КонстантыВМФинал.Добавить(Новый Структура("Значение", СоответствиеКонстант[Счетчик]));
		Счетчик = Счетчик + 1;
	КонецЦикла;
КонецПроцедуры

// Собирает финальный массив переменных ВМ из семантических данных.
//
// Параметры:
//  Сем - Структура - данные семантического анализа с соответствием переменных
//  ПеременныеВМФинал - Массив - результирующий массив для заполнения структурами переменных
Процедура СобратьПеременныеВМФинальные(Сем, ПеременныеВМФинал)
	СоответствиеПеременных = Новый Соответствие;
	Для Каждого Запись Из Сем.Переменные Цикл
		СоответствиеПеременных.Вставить(Запись.Значение.Адрес, Запись.Значение);
	КонецЦикла;
	Счетчик = 0;
	Пока Счетчик < Сем.Переменные.Количество() Цикл
		ПеременныеВМФинал.Добавить(Новый Структура("Имя,Флаг,Инициализирована,Адрес,ВМ,ИдентификаторВызова,Значение,ЗначениеПредСвойства,ИмяСвойства", СоответствиеПеременных[Счетчик].Имя, СоответствиеПеременных[Счетчик].Флаг, Ложь, Счетчик));
		Счетчик = Счетчик + 1;
	КонецЦикла;
КонецПроцедуры

// Разрешает аргумент команды ВМ по идентификатору и сдвигу.
//
// Параметры:
//  КомандаВМ - Структура - целевая команда ВМ, в которую записывается разрешённый аргумент
//  ДанныеКомандыИсходные - Структура - исходные данные команды с ИдентификаторАргумента и Сдвиг
//  Сем - Структура - данные семантического анализа
//  ДанныеКомандИсточник - Соответствие - соответствие идентификаторов команд и их данных
Процедура РазрешитьАргументКоманды(КомандаВМ, ДанныеКомандыИсходные, Сем, ДанныеКомандИсточник)
	Если НЕ ЗначениеЗаполнено(ДанныеКомандыИсходные.ИдентификаторАргумента) Тогда
		Возврат;
	КонецЕсли;
	Если ЗначениеЗаполнено(ДанныеКомандыИсходные.Сдвиг) Тогда
		ИдентификаторАргументаКоманды = конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторКомандыОтносительноТекущего(Сем, ДанныеКомандыИсходные.ИдентификаторАргумента, ДанныеКомандыИсходные.Сдвиг - 1);
	Иначе
		ИдентификаторАргументаКоманды = ДанныеКомандыИсходные.ИдентификаторАргумента;
	КонецЕсли;
	КомандаВМ.Аргумент = ДанныеКомандИсточник[ИдентификаторАргументаКоманды].Адрес - 1;
КонецПроцедуры

// Обновляет адреса меток при встрече команды НОМЕРСТРОКИ с ненулевым номером строки.
//
// Параметры:
//  Метки - Соответствие - соответствие меток с описаниями (АдресКоманды, НомерСтроки)
//  СчетчикАдресовКоманд - Число - текущий адрес (индекс) команды ВМ
//  ТекущийНомерСтроки - Число - текущий номер строки исходного кода
Процедура ОбновитьМеткиПоНомеруСтроки(Метки, СчетчикАдресовКоманд, ТекущийНомерСтроки)
	Для Каждого ЗаписьМетки Из Метки Цикл
		ОписаниеМетки = ЗаписьМетки.Значение;
		Если ОписаниеМетки.АдресКоманды = 0 И ОписаниеМетки.НомерСтроки <= ТекущийНомерСтроки Тогда
			ОписаниеМетки.АдресКоманды = СчетчикАдресовКоманд;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Обновляет адреса меток при встрече команды КОНЕЦ.
//
// Параметры:
//  Метки - Соответствие - соответствие меток с описаниями (АдресКоманды, ТекКоманда)
//  СчетчикАдресовКоманд - Число - текущий адрес (индекс) команды ВМ
Процедура ОбновитьМеткиПоКонцуБлока(Метки, СчетчикАдресовКоманд)
	Для Каждого ЗаписьМетки Из Метки Цикл
		ОписаниеМетки = ЗаписьМетки.Значение;
		Если ОписаниеМетки.АдресКоманды = 0 И ОписаниеМетки.ТекКоманда <= СчетчикАдресовКоманд Тогда
			ОписаниеМетки.АдресКоманды = СчетчикАдресовКоманд;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Обрабатывает все команды ВМ: разрешает аргументы, обновляет метки, формирует финальный массив.
//
// Параметры:
//  СписокКоманд - Массив - упорядоченный список идентификаторов команд ВМ
//  ДанныеКомандИсточник - Соответствие - соответствие идентификаторов команд и их данных
//  Сем - Структура - данные семантического анализа
//  КомандыВМФинал - Массив - результирующий массив финальных команд ВМ
Процедура ОбработатьКомандыВМФинализации(СписокКоманд, ДанныеКомандИсточник, Сем, КомандыВМФинал)
	СчетчикАдресовКоманд = 0;
	ТекущийНомерСтроки = 0;
	Для Каждого ИдентификаторКомандыЦикла Из СписокКоманд Цикл
		КомандаВМ = Новый Структура("ОпКод,Аргумент");
		КомандыВМФинал.Добавить(КомандаВМ);
		ДанныеКомандыИсходные = ДанныеКомандИсточник[ИдентификаторКомандыЦикла];
		ЗаполнитьЗначенияСвойств(КомандаВМ, ДанныеКомандыИсходные);
		РазрешитьАргументКоманды(КомандаВМ, ДанныеКомандыИсходные, Сем, ДанныеКомандИсточник);
		Если ДанныеКомандыИсходные.ОпКод = "НОМЕРСТРОКИ" И ДанныеКомандыИсходные.Аргумент <> 0 Тогда
			ТекущийНомерСтроки = ДанныеКомандыИсходные.Аргумент;
			ОбновитьМеткиПоНомеруСтроки(Сем.Метки, СчетчикАдресовКоманд, ТекущийНомерСтроки);
		КонецЕсли;
		Если ДанныеКомандыИсходные.ОпКод = "НОМЕРСТРОКИ" И ДанныеКомандыИсходные.Аргумент = 0 Тогда
			КомандаВМ.Аргумент = ТекущийНомерСтроки;
		КонецЕсли;
		Если ДанныеКомандыИсходные.ОпКод = "КОНЕЦ" Тогда
			ОбновитьМеткиПоКонцуБлока(Сем.Метки, СчетчикАдресовКоманд);
		КонецЕсли;
		СчетчикАдресовКоманд = СчетчикАдресовКоманд + 1;
	КонецЦикла;
КонецПроцедуры

// Собирает финальный массив меток ВМ.
//
// Параметры:
//  Сем - Структура - данные семантического анализа с массивом меток
//  МеткиВМФинал - Массив - результирующий массив для заполнения структурами меток
Процедура СобратьМеткиВМФинальные(Сем, МеткиВМФинал)
	ИндексМетки = 0;
	Пока ИндексМетки < Сем.Метки.Количество() Цикл
		ОписаниеМетки = Новый Структура("Значение,АдресКоманды");
		ЗаполнитьЗначенияСвойств(ОписаниеМетки, Сем.Метки[ИндексМетки]);
		МеткиВМФинал.Добавить(ОписаниеМетки);
		ИндексМетки = ИндексМетки + 1;
	КонецЦикла;
КонецПроцедуры

// Передача атрибутов ИмяПеременной и ИдентификаторПоследнейКоманды
// от дочернего нетерминального узла к родительскому.
// Общий паттерн для _ВыражениеПеременной и _СложноеВыражение.
//
// Параметры:
//  Узел - Структура - узел AST, принимающий атрибуты от первого дочернего узла
Процедура ПередатьАтрибутыДочернегоУзла(Узел)
	ДочернийУзел = Узел.СоставУзла[0];
	Если ДочернийУзел.Свойство("Нетерминал") Тогда
		Если ДочернийУзел.Атрибуты.Свойство("ИмяПеременной") Тогда
			Узел.Атрибуты.Вставить("ИмяПеременной", ДочернийУзел.Атрибуты.ИмяПеременной);
		КонецЕсли;
		Если ДочернийУзел.Атрибуты.Свойство("ИдентификаторПоследнейКоманды") Тогда
			Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", ДочернийУзел.Атрибуты.ИдентификаторПоследнейКоманды);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Общая логика сложного вызова: если у первого дочернего узла есть имя переменной,
// загружает её на стек. Устанавливает ИдентификаторПоследнейКоманды.
// Общий паттерн для _СложныйВызов и _СложныйВызовПроцедуры.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел AST сложного вызова
//  Ошибки - Массив - массив ошибок компиляции
Процедура ОбработатьСложныйВызовОбщий(Сем, Узел, Ошибки)
	Если Узел.СоставУзла[0].Атрибуты.Свойство("ИмяПеременной") Тогда
		Поз = Неопределено;
		Если Узел.СоставУзла[0].Атрибуты.Свойство("ИдентификаторПоследнейКоманды") Тогда
			Поз = Узел.СоставУзла[0].Атрибуты.ИдентификаторПоследнейКоманды;
		КонецЕсли;
		Данные = конс_КомпиляцияКлиентСервер.ПолучитьДанныеПеременнойВМ(Узел.СоставУзла[0].Атрибуты.ИмяПеременной, Сем, Ошибки, Узел.НомерСтроки);
		ЭмитироватьКоманду(Данные.ОпКод, Данные.Адрес, Сем, Узел, Поз);
	КонецЕсли;
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
КонецПроцедуры

// Обработка тела процедуры или функции: определение точки входа и эмиссия команд завершения.
// Общий паттерн для _Процедура и _Функция.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел AST тела подпрограммы
Процедура ОбработатьТелоПодпрограммы(Сем, Узел)
	Сем.ЧтениеПодпрограммы = Ложь;
	ИндексПоследнего = Узел.СоставУзла.Количество() - 1;
	Если ИндексПоследнего = 1 Тогда
		ТочкаВхода = Сем.КомандыВМ.Количество();
	Иначе
		ТочкаВхода = Сем.КомандыВМ.Количество() - Узел.СоставУзла[1].Атрибуты.КоличествоОпераций;
	КонецЕсли;
	Сем.Подпрограммы[Сем.КлючТекущейПодпрограммы].ТочкаВхода = ТочкаВхода;
	конс_КомпиляцияКлиентСервер.ДобавитьКомандуВМ("НОМЕРСТРОКИ", Узел.СоставУзла[ИндексПоследнего].НомерСтроки, Сем, Узел, , , , Сем.ИдентификаторКомандыПоследнейОстановки);
	конс_КомпиляцияКлиентСервер.ДобавитьКомандуВМ("КОНЕЦ", 0, Сем, Узел);
КонецПроцедуры

// Обработка ключевого слова начала подпрограммы (Процедура/Функция):
// установка флага чтения заголовка и фиксация строки первой подпрограммы.
// Общий паттерн для _Ключ_Процедура и _Ключ_Функция.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел AST ключевого слова
Процедура ОбработатьНачалоПодпрограммы(Сем, Узел)
	Сем.ЧтениеЗаголовкаПодпрограммы = Истина;
	Если Сем.СтрокаПервойПодпрограммы = 0 Тогда
		Сем.СтрокаПервойПодпрограммы = Узел.СоставУзла[0].НомерСтроки;
	КонецЕсли;
КонецПроцедуры

// Обработка добавления/удаления обработчика события.
// Общий паттерн для _ВыражениеДобавленияОбработчика и _ВыражениеУдаленияОбработчика.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел AST обработчика события
Процедура ОбработатьОбработчикСобытия(Сем, Узел)
	Адр = 0;
	Если Узел.СоставУзла[0].Терминал = "Ключ_ДобавитьОбработчик" Тогда
		Если Узел.СоставУзла[3].Свойство("Терминал") Тогда
			ОК = "ДОБОБРАБОТЧИК_ЛОК";
			Адр = конс_КомпиляцияКлиентСервер.ПолучитьПодпрограммуВМ(Узел.СоставУзла[3].Значение, Сем).Адрес;
		Иначе
			ОК = "ДОБОБРАБОТЧИК_ВНЕШ";
		КонецЕсли;
	Иначе
		Если Узел.СоставУзла[3].Свойство("Терминал") Тогда
			ОК = "УДОБРАБОТЧИК_ЛОК";
			Адр = конс_КомпиляцияКлиентСервер.ПолучитьПодпрограммуВМ(Узел.СоставУзла[3].Значение, Сем).Адрес;
		Иначе
			ОК = "УДОБРАБОТЧИК_ВНЕШ";
		КонецЕсли;
	КонецЕсли;
	ЭмитироватьКоманду(ОК, Адр, Сем, Узел);
КонецПроцедуры

// Обработка булева выражения (И/ИЛИ): эмиссия команды БУЛЕВО и логической операции.
// Общий паттерн для _ВыражениеИ и _ВыражениеИли.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел AST булева выражения
//  ОпКод - Строка - код операции ("И" или "ИЛИ")
Процедура ОбработатьБулевоВыражение(Сем, Узел, ОпКод)
	ИдБул = ЭмитироватьКоманду("БУЛЕВО", 0, Сем, Узел);
	ЭмитироватьКоманду(ОпКод, 0, Сем, Узел, Узел.СоставУзла[0].Атрибуты.ИдентификаторПоследнейКоманды, ИдБул, 1);
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
КонецПроцедуры

// Общая обработка метки: создание или обновление описания метки в семантических данных.
// Общий паттерн для _ОператорПерехода и _Метка.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел AST метки
Процедура ОбработатьМетку(Сем, Узел)
	НомерСтрокиМетки = 0;
	ЭтоОпределениеМетки = Узел.СоставУзла[0].Терминал = "Спец_Метка";
	Если ЭтоОпределениеМетки Тогда
		ИмяМетки = Узел.СоставУзла[0].Значение;
		НомерСтрокиМетки = Узел.СоставУзла[0].НомерСтроки;
	Иначе
		ИмяМетки = Узел.СоставУзла[1].Значение;
	КонецЕсли;
	АдресМетки = Сем.АдресаМеток[ИмяМетки];
	Если АдресМетки = Неопределено Тогда
		ОписаниеМетки = Новый Структура("Значение,НомерСтроки,ТекКоманда,Адрес,АдресКоманды");
		ОписаниеМетки.Значение = ИмяМетки;
		ОписаниеМетки.АдресКоманды = 0;
		ОписаниеМетки.НомерСтроки = НомерСтрокиМетки;
		ОписаниеМетки.ТекКоманда = Сем.КомандыВМ.Количество() - 1;
		ОписаниеМетки.Адрес = Сем.Метки.Количество();
		Сем.АдресаМеток.Вставить(ОписаниеМетки.Значение, ОписаниеМетки.Адрес);
		Сем.Метки.Вставить(ОписаниеМетки.Адрес, ОписаниеМетки);
	Иначе
		Если ЭтоОпределениеМетки Тогда
			ОписаниеМетки = Сем.Метки[АдресМетки];
			ОписаниеМетки.НомерСтроки = НомерСтрокиМетки;
			ОписаниеМетки.ТекКоманда = Сем.КомандыВМ.Количество() - 1;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Обработка списка аргументов вызова или конструктора:
// вставка пустых аргументов и подсчёт их количества.
// Общий паттерн для _СписокАргументовВыражения и _СписокАргументовКонструктора.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
//  Узел - Структура - узел AST списка аргументов
//  ОпКодПустогоАргумента - Строка - код операции для пустого аргумента ("ПУСТО" или "НЕОПР")
Процедура ОбработатьСписокАргументовОбщий(Сем, Узел, ОК)
	Если Узел.СоставУзла[0].Нетерминал = "Разд_Запятая" Тогда
		ЭмитироватьКоманду(ОК, 0, Сем, Узел, Узел.СоставУзла[0].Атрибуты.ИдентификаторПоследнейКоманды);
	КонецЕсли;
	Если Узел.СоставУзла[Узел.СоставУзла.Количество() - 1].Нетерминал = "Разд_Запятая" Тогда
		ЭмитироватьКоманду(ОК, 0, Сем, Узел);
	КонецЕсли;
	КоличествоАргументов = 0;
	Если Узел.СоставУзла[0].Нетерминал = "СписокАргументовВыражения" ИЛИ Узел.СоставУзла[0].Нетерминал = "СписокАргументовКонструктора" Тогда
		КоличествоАргументов = Узел.СоставУзла[0].Атрибуты.ТекущееКоличествоАргументов;
	КонецЕсли;
	КоличествоАргументов = КоличествоАргументов + ?(Узел.СоставУзла[0].Нетерминал = "Разд_Запятая", 2, 1);
	Узел.Атрибуты.Вставить("ТекущееКоличествоАргументов", КоличествоАргументов);
КонецПроцедуры

// Регистрация имени в таблице констант (если ещё не зарегистрировано).
// Общий паттерн для _ИмяМетода, _РасширенноеИмяМетода, _ОбъектОбработчика, _СложнаяПеременная и др.
//
// Параметры:
//  Имя - Строка - регистрируемое имя
//  Сем - Структура - контекст семантического анализа с таблицей констант
Процедура ЗарегистрироватьКонстанту(Имя, Сем)
	Если Сем.Константы[Имя] = Неопределено Тогда
		Сем.Константы.Вставить(Имя, Сем.Константы.Количество());
	КонецЕсли;
КонецПроцедуры

// Привязывает идентификаторы команд выхода/продолжения к целевой команде.
// Общий паттерн обработки Прервать/Продолжить в _ЦиклПока, _ЦиклДля, _ЦиклДляКаждого.
//
// Параметры:
//  МассивИдентификаторов - Массив - массив идентификаторов команд для привязки
//  Сем - Структура - контекст семантического анализа
//  ИдентификаторЦели - УникальныйИдентификатор - целевой идентификатор команды
//  Сдвиг - Число, Неопределено - сдвиг адреса (если Неопределено — не устанавливается)
Процедура ПривязатьИдентификаторыКоманд(УзелТела, Сем, ИдентификаторЦели, Сдвиг = Неопределено, ИмяСвойства = "")
	Если НЕ УзелТела.Атрибуты.Свойство(ИмяСвойства) Тогда
		Возврат;
	КонецЕсли;
	Для Каждого ИдентификаторКоманды Из УзелТела.Атрибуты[ИмяСвойства] Цикл
		ДанныеКоманды = конс_КомпиляцияКлиентСервер.ПолучитьКомандуПоИдентификатору(Сем, ИдентификаторКоманды);
		ДанныеКоманды.ИдентификаторАргумента = ИдентификаторЦели;
		Если Сдвиг <> Неопределено Тогда
			ДанныеКоманды.Сдвиг = Сдвиг;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Сброс ожидающей присваивания переменной.
// Повторяющийся паттерн в _ВыражениеЦиклаДля, _ВыражениеЦикла, _ВыражениеПрисваивания.
//
// Параметры:
//  Сем - Структура - контекст семантического анализа
Процедура СброситьПеременнуюОжидающуюПрисваивания(Сем)
	Если Сем.Свойство("ПеременнаяОжидающаяПрисваивания") Тогда
		Сем.ПеременнаяОжидающаяПрисваивания = Неопределено;
	КонецЕсли;
КонецПроцедуры

// Проверяет, является ли значение спецзначением (Неопределено, Null, Истина, Ложь),
// для которого существует специальный опкод ВМ и не требуется регистрация в таблице констант.
//
// Параметры:
//  Значение - Произвольный - проверяемое значение
//
// Возвращаемое значение:
//  Булево - Истина, если значение является спецзначением
Функция ЭтоСпецЗначениеКонстанты(Значение)
	// Используем Соответствие для проверки, т.к. оператор <> приводит типы
	// (0 <> Ложь = Ложь, 1 <> Истина = Ложь)
	СоответствиеСпецЗначений = Новый Соответствие;
	СоответствиеСпецЗначений.Вставить(Неопределено, Истина);
	СоответствиеСпецЗначений.Вставить(Null, Истина);
	СоответствиеСпецЗначений.Вставить(Истина, Истина);
	СоответствиеСпецЗначений.Вставить(Ложь, Истина);
	Возврат СоответствиеСпецЗначений[Значение] <> Неопределено;
КонецФункции

#КонецОбласти // СлужебныеПроцедурыИФункции

#Область СемантическиеДействия

Процедура _S(Сем, Узел, Компиляция, Ошибки)
	Если НЕ Узел.СоставУзла.Количество() Тогда
		ЭмитироватьКоманду("КОНЕЦ", 0, Сем, Узел);
	Иначе
		Состав = Узел.СоставУзла[0].СоставУзла;
		Если Состав[Состав.Количество() - 1].Нетерминал <> "СписокОператоров" Тогда
			ЭмитироватьКоманду("КОНЕЦ", 0, Сем, Узел);
		КонецЕсли;
	КонецЕсли;
	ЭмитироватьКоманду("КОНЕЦ", 0, Сем, Узел);
	Компиляция = Новый Структура("СтекВМ,КонстантыВМ,ПеременныеВМ,МеткиВМ,КомандыВМ,ПроцедурыФункцииВМ,ПараметрыПоУмолчаниюВМ,ТочкаВхода", Новый Массив, Новый Массив, Новый Массив, Новый Массив, Новый Массив, Новый Массив);
	СтекКоманд = Компиляция.СтекВМ;
	КонстантыВМФинал = Компиляция.КонстантыВМ;
	ПеременныеВМФинал = Компиляция.ПеременныеВМ;
	МеткиВМФинал = Компиляция.МеткиВМ;
	КомандыВМФинал = Компиляция.КомандыВМ;
	ПодпрограммыВМФинал = Компиляция.ПроцедурыФункцииВМ;
	СписокКоманд = Сем.КомандыВМ;
	СписокКоманд.Удалить(0);
	ДанныеКомандИсточник = Сем.ДанныеКомандВМ;
	Компиляция.ТочкаВхода = ОпределитьТочкуВходаПрограммы(Узел, СписокКоманд);
	СобратьКонстантыВМФинальные(Сем, КонстантыВМФинал);
	СобратьПеременныеВМФинальные(Сем, ПеременныеВМФинал);
	СобратьПодпрограммыВМ(Сем, ПодпрограммыВМФинал);
	ОбработатьКомандыВМФинализации(СписокКоманд, ДанныеКомандИсточник, Сем, КомандыВМФинал);
	СобратьМеткиВМФинальные(Сем, МеткиВМФинал);
	ПроверитьВызовыПодпрограмм(Сем, Ошибки);
КонецПроцедуры
Процедура _ОператорПерехода(Сем, Узел, Компиляция, Ошибки)
	ОбработатьМетку(Сем, Узел);
	ЭмитироватьКоманду("КМЕТКЕ", Сем.АдресаМеток[Узел.СоставУзла[1].Значение], Сем, Узел);
КонецПроцедуры
Процедура _АргументПроцедурыФункции(Сем, Узел, Компиляция, Ошибки)
	Если Узел.СоставУзла[0].Терминал = "Лит_Идентификатор" Тогда
		ФлагАргумента = "Параметр"; // обычный параметр (по ссылке)
		ИмяАргумента = Узел.СоставУзла[0].Значение;
	Иначе
		ФлагАргумента = "ПараметрЗнач"; // параметр по значению (Знач)
		ИмяАргумента = Узел.СоставУзла[1].Значение;
	КонецЕсли;
	ИндексПоследнегоЭлемента = Узел.СоставУзла.Количество() - 1;
	ЗначениеПоУмолчаниюАргумента = Новый Структура;
	Если Узел.СоставУзла[ИндексПоследнегоЭлемента].Свойство("Нетерминал") Тогда
		ЗначениеПоУмолчаниюАргумента = Узел.СоставУзла[ИндексПоследнегоЭлемента].Атрибуты.ЗначениеКонстанты;
		Если Узел.СоставУзла[ИндексПоследнегоЭлемента - 1].Свойство("Нетерминал") И Узел.СоставУзла[ИндексПоследнегоЭлемента - 1].СоставУзла[0].Терминал = "Оп_Минус" Тогда
			ЗначениеПоУмолчаниюАргумента = -ЗначениеПоУмолчаниюАргумента;
		КонецЕсли;
	КонецЕсли;
	ОписаниеАргумента = Новый Структура("Имя,Флаг,ЗначениеПоУмолчанию", ИмяАргумента, ФлагАргумента, ЗначениеПоУмолчаниюАргумента);
	Узел.Атрибуты.Вставить("Аргумент", ОписаниеАргумента);
КонецПроцедуры
Процедура _Процедура(Сем, Узел, Компиляция, Ошибки)
	ОбработатьТелоПодпрограммы(Сем, Узел);
КонецПроцедуры
Процедура _ЗаголовокПроцедуры(Сем, Узел, Компиляция, Ошибки)
	ОбработатьЗаголовокПодпрограммы(Сем, Узел, Ошибки);
КонецПроцедуры
Процедура _ЗаголовокФункции(Сем, Узел, Компиляция, Ошибки)
	ОбработатьЗаголовокПодпрограммы(Сем, Узел, Ошибки);
КонецПроцедуры
Процедура _Ключ_Процедура(Сем, Узел, Компиляция, Ошибки)
	ОбработатьНачалоПодпрограммы(Сем, Узел);
КонецПроцедуры
Процедура _Метка(Сем, Узел, Компиляция, Ошибки)
	ОбработатьМетку(Сем, Узел);
КонецПроцедуры
Процедура _ВыражениеЦиклаДля(Сем, Узел, Компиляция, Ошибки)
	СброситьПеременнуюОжидающуюПрисваивания(Сем);
	Имя = Узел.СоставУзла[0].Атрибуты.ИмяПеременной;
	Данные = конс_КомпиляцияКлиентСервер.ПолучитьДанныеПеременнойВМ(Имя, Сем, Ошибки, Узел.НомерСтроки, Истина);
	АдрВст = Сем.КомандыВМ.Количество() - Узел.СоставУзла[2].Атрибуты.КоличествоОпераций;
	ЭмитироватьКоманду(Данные.ОпКод, Данные.Адрес, Сем, Узел, АдрВст);
	ЭмитироватьКоманду("ПРИСВОИТЬ", 0, Сем, Узел);
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
	Сем.СчетчикЦиклов = Сем.СчетчикЦиклов + 1;
КонецПроцедуры
Процедура _БлокИсключение(Сем, Узел, Компиляция, Ошибки)
	Сем.СчетчикБлоков = Сем.СчетчикБлоков - 1;
КонецПроцедуры
Процедура _ТернарноеВыражение(Сем, Узел, Компиляция, Ошибки)
	ИдПослИстина = Узел.СоставУзла[4].Атрибуты.ИдентификаторПоследнейКоманды;
	ИдПослЛожь = Узел.СоставУзла[6].Атрибуты.ИдентификаторПоследнейКоманды;
	ИдПослУсл = Узел.СоставУзла[2].Атрибуты.ИдентификаторПоследнейКоманды;
	ИдПерехода = ЭмитироватьКоманду("ПЕРЕХОД", 0, Сем, Узел, ИдПослИстина, ИдПослЛожь, 1);
	ЭмитироватьКоманду("ПЕРЕХОДЛОЖЬ", 0, Сем, Узел, ИдПослУсл, конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторКомандыОтносительноТекущего(Сем, ИдПерехода, 1));
КонецПроцедуры
Процедура _Условие(Сем, Узел, Компиляция, Ошибки)
	Если Узел.СоставУзла[0].Свойство("Нетерминал") Тогда
		ЭмитироватьКоманду("НОМЕРСТРОКИ", Узел.СоставУзла[1].НомерСтроки, Сем, Узел, Узел.СоставУзла[0].Атрибуты.ИдентификаторПоследнейКоманды);
	КонецЕсли;
	СобратьИдентификаторыВыходаИПродолжения(Узел);
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
КонецПроцедуры
Процедура _НачалоПопытки(Сем, Узел, Компиляция, Ошибки)
	Сем.СчетчикБлоков = Сем.СчетчикБлоков + 1;
	Сем.СчетчикПопыток = Сем.СчетчикПопыток + 1;
КонецПроцедуры
Процедура _Выражение(Сем, Узел, Компиляция, Ошибки)
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[0], Сем, Ошибки, Узел);
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
КонецПроцедуры
Процедура _ВыражениеУдаленияОбработчика(Сем, Узел, Компиляция, Ошибки)
	ОбработатьОбработчикСобытия(Сем, Узел);
КонецПроцедуры
Процедура _ОбъектОбработчика(Сем, Узел, Компиляция, Ошибки)
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[0], Сем, Ошибки, Узел);
	Если Узел.СоставУзла.Количество() > 1 Тогда
		Имя = Узел.СоставУзла[2].Значение;
		ЗарегистрироватьКонстанту(Имя, Сем);
		ЭмитироватьКоманду("КОНСТ", Сем.Константы[Имя], Сем, Узел);
	КонецЕсли;
КонецПроцедуры
Процедура _ВыражениеПеременной(Сем, Узел, Компиляция, Ошибки)
	ПередатьАтрибутыДочернегоУзла(Узел);
КонецПроцедуры
Процедура _СложноеВыражение(Сем, Узел, Компиляция, Ошибки)
	ПередатьАтрибутыДочернегоУзла(Узел);
КонецПроцедуры
Процедура _СложнаяПеременная(Сем, Узел, Компиляция, Ошибки)
	ПозВст = Неопределено;
	Если Узел.СоставУзла[0].Свойство("Нетерминал") И Узел.СоставУзла[0].Атрибуты.Свойство("ИдентификаторПоследнейКоманды") Тогда
		ПозВст = Узел.СоставУзла[0].Атрибуты.ИдентификаторПоследнейКоманды;
	КонецЕсли;
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[0], Сем, Ошибки, Узел, ПозВст);
	Если Узел.СоставУзла[1].Терминал = "Разд_Точка" Тогда
		Имя = Узел.СоставУзла[2].Атрибуты.ИмяПеременной;
		ЗарегистрироватьКонстанту(Имя, Сем);
		ЭмитироватьКоманду("СВОЙСТВО", Сем.Константы[Имя], Сем, Узел);
	Иначе
		ЭмитироватьКоманду("ИНДЕКС", 0, Сем, Узел);
	КонецЕсли;
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
КонецПроцедуры
Процедура _СложныйВызов(Сем, Узел, Компиляция, Ошибки)
	ОбработатьСложныйВызовОбщий(Сем, Узел, Ошибки);
КонецПроцедуры
Процедура _ВыражениеВыполнить(Сем, Узел, Компиляция, Ошибки)
	ЭмитироватьКоманду("ВЫПОЛНИТЬ", 0, Сем, Узел);
КонецПроцедуры
Процедура _ОператорУсловия(Сем, Узел, Компиляция, Ошибки)
	ИдСтрока = ЭмитироватьКоманду("НОМЕРСТРОКИ", Узел.СоставУзла[Узел.СоставУзла.Количество() - 1].НомерСтроки, Сем, Узел, Сем.КомандыВМ.Количество());
	ТекВетвь = Узел.СоставУзла[0];
	Пока ТекВетвь.Свойство("Нетерминал") Цикл
		Инд = ?(ТекВетвь.СоставУзла[ТекВетвь.СоставУзла.Количество() - 1].Свойство("Нетерминал"), ТекВетвь.СоставУзла.Количество() - 3, ТекВетвь.СоставУзла.Количество() - 2);
		ИдПослУсл = ТекВетвь.СоставУзла[Инд].Атрибуты.ИдентификаторПоследнейКоманды;
		Инд = ?(ТекВетвь.СоставУзла[ТекВетвь.СоставУзла.Количество() - 1].Свойство("Нетерминал"), ТекВетвь.СоставУзла.Количество() - 1, ТекВетвь.СоставУзла.Количество() - 2);
		ИдПослТела = ТекВетвь.СоставУзла[Инд].Атрибуты.ИдентификаторПоследнейКоманды;
		ИдПерехода = ЭмитироватьКоманду("ПЕРЕХОД", 0, Сем, Узел, ИдПослТела, ИдСтрока);
		ЭмитироватьКоманду("ПЕРЕХОДЛОЖЬ", 0, Сем, Узел, ИдПослУсл, конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторКомандыОтносительноТекущего(Сем, ИдПерехода, 1));
		ТекВетвь = ТекВетвь.СоставУзла[0];
	КонецЦикла;
	СобратьИдентификаторыВыходаИПродолжения(Узел);
КонецПроцедуры
Процедура _ВыражениеПрисваивания(Сем, Узел, Компиляция, Ошибки)
	ЭмитироватьКоманду("ПРИСВОИТЬ", 0, Сем, Узел);
	СброситьПеременнуюОжидающуюПрисваивания(Сем);
КонецПроцедуры
Процедура _ВыражениеИ(Сем, Узел, Компиляция, Ошибки)
	ОбработатьБулевоВыражение(Сем, Узел, "И");
КонецПроцедуры
Процедура _ВыражениеЦикла(Сем, Узел, Компиляция, Ошибки)
	// --- Подготовка ---
	СброситьПеременнуюОжидающуюПрисваивания(Сем);
	Имя = Узел.СоставУзла[0].Атрибуты.ИмяПеременной;
	ДанныеПерем = конс_КомпиляцияКлиентСервер.ПолучитьДанныеПеременнойВМ(Имя, Сем, Ошибки, Узел.НомерСтроки, Истина);
	ДанныеИтер = конс_КомпиляцияКлиентСервер.ПолучитьДанныеПеременнойВМ("0" + Имя, Сем, Ошибки, Узел.НомерСтроки, Истина);
	АдрВст = Сем.КомандыВМ.Количество() - Узел.СоставУзла[2].Атрибуты.КоличествоОпераций;
	
	// --- Эмиссия команд ---
	ИдВрем = ЭмитироватьКоманду("ПОМВРЕМ", 0, Сем, Узел, АдрВст);
	ЭмитироватьКоманду("ЗАГРВРЕМ", 0, Сем, Узел, ИдВрем);
	ЭмитироватьКоманду("ИТЕРАТОР", 0, Сем, Узел);
	ЭмитироватьКоманду("ПРИСВОИТЬ", 0, Сем, Узел);
	
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
	Сем.СчетчикЦиклов = Сем.СчетчикЦиклов + 1;
КонецПроцедуры
Процедура _Оператор(Сем, Узел, Компиляция, Ошибки)
	НТ = Узел.СоставУзла[0].Нетерминал;
	Если НТ <> "Метка" И НТ <> "ВыражениеПеременной" И НТ <> "ОператорПопытки" Тогда
		ЭмитироватьКоманду("НОМЕРСТРОКИ", Узел.НомерСтроки, Сем, Узел, Сем.КомандыВМ.Количество() - Узел.Атрибуты.КоличествоОпераций);
	КонецЕсли;
	СобратьИдентификаторыВыходаИПродолжения(Узел);
	Узел.Атрибуты.Вставить("ЭтоОбъявлениеПеременных", ?(НТ = "ВыражениеПеременной", Истина, Ложь));
КонецПроцедуры
Процедура _ВыражениеДобавленияОбработчика(Сем, Узел, Компиляция, Ошибки)
	ОбработатьОбработчикСобытия(Сем, Узел);
КонецПроцедуры
Процедура _Функция(Сем, Узел, Компиляция, Ошибки)
	ОбработатьТелоПодпрограммы(Сем, Узел);
КонецПроцедуры
Процедура _ВыражениеСравнения(Сем, Узел, Компиляция, Ошибки)
	Терм = Узел.СоставУзла[1].СоставУзла[0].Терминал;
	Если Терм = "Оп_Равно" Тогда
		ОпКод = "РАВНО";
	ИначеЕсли Терм = "Оп_Меньше" Тогда
		ОпКод = "МЕНЬШЕ";
	ИначеЕсли Терм = "Оп_Больше" Тогда
		ОпКод = "БОЛЬШЕ";
	ИначеЕсли Терм = "Оп_МеньшеРавно" Тогда
		ОпКод = "МЕНЬШЕРАВНО";
	ИначеЕсли Терм = "Оп_БольшеРавно" Тогда
		ОпКод = "БОЛЬШЕРАВНО";
	Иначе
		ОпКод = "НЕРАВНО";
	КонецЕсли;
	ЭмитироватьКоманду(ОпКод, 0, Сем, Узел);
КонецПроцедуры
Процедура _ВыражениеУмноженияДеления(Сем, Узел, Компиляция, Ошибки)
	Терм = Узел.СоставУзла[1].СоставУзла[0].Терминал;
	Если Терм = "Оп_Делить" Тогда
		ОпКод = "РАЗДЕЛИТЬ";
	ИначеЕсли Терм = "Оп_Умножить" Тогда
		ОпКод = "УМНОЖИТЬ";
	Иначе
		ОпКод = "ОСТАТОК";
	КонецЕсли;
	ЭмитироватьКоманду(ОпКод, 0, Сем, Узел);
КонецПроцедуры
Процедура _СписокОператоров(Сем, Узел, Компиляция, Ошибки)
	СобратьИдентификаторыВыходаИПродолжения(Узел);
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
	Нетерминал = Неопределено;
	ПервыйЭлементСостава = Узел.СоставУзла[0];
	Если ПервыйЭлементСостава.Свойство("Нетерминал", Нетерминал) Тогда
		Если Нетерминал = "Оператор" Тогда
			Узел.Атрибуты.Вставить("ЭтоОбъявлениеПеременных", ПервыйЭлементСостава.Атрибуты.ЭтоОбъявлениеПеременных);
		ИначеЕсли Узел.СоставУзла.Количество() = 3 Тогда
			Узел.Атрибуты.Вставить("ЭтоОбъявлениеПеременных", ПервыйЭлементСостава.Атрибуты.ЭтоОбъявлениеПеременных И Узел.СоставУзла[2].Атрибуты.ЭтоОбъявлениеПеременных);
		Иначе
			Узел.Атрибуты.Вставить("ЭтоОбъявлениеПеременных", ПервыйЭлементСостава.Атрибуты.ЭтоОбъявлениеПеременных);
		КонецЕсли;
	ИначеЕсли Узел.СоставУзла.Количество() = 2 Тогда
		Узел.Атрибуты.Вставить("ЭтоОбъявлениеПеременных", Узел.СоставУзла[1].Атрибуты.ЭтоОбъявлениеПеременных);
	Иначе
		Узел.Атрибуты.Вставить("ЭтоОбъявлениеПеременных", Истина);
	КонецЕсли;
	Узел.СоставУзла = Новый Массив;
КонецПроцедуры
Процедура _УнарноеВыражение(Сем, Узел, Компиляция, Ошибки)
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[1], Сем, Ошибки, Узел);
	ОпКод = ?(Узел.СоставУзла[0].СоставУзла[0].Терминал = "Оп_Плюс", "ЧИСЛО", "МИНУС");
	ЭмитироватьКоманду(ОпКод, 0, Сем, Узел);
КонецПроцедуры
Процедура _ВыражениеВозврата(Сем, Узел, Компиляция, Ошибки)
	Если НЕ Сем.ЧтениеПодпрограммы Тогда
		ТекстОшибки = НСтр("ru='Оператор Возврат (Return) не может употребляться вне процедуры или функции';en='Return operator may not be used outside procedure or function'", ТекущийЯзыкСистемы());
		конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, ТекстОшибки, Сем, Узел.СоставУзла[0]);
		Возврат;
	КонецЕсли;
	Флаг = Сем.Подпрограммы[Сем.КлючТекущейПодпрограммы].Флаг;
	Если Флаг = "Функция" ИЛИ Флаг = "ЭкспортФункция" Тогда
		ЭмитироватьКоманду("ВОЗВРАТ", 0, Сем, Узел);
	ИначеЕсли Узел.СоставУзла.Количество() > 1 Тогда
		конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, НСтр("ru='Процедура не может возвращать значение';en='Procedure cannot return a value'", ТекущийЯзыкСистемы()), Сем, Узел.СоставУзла[0]);
		Возврат;
	КонецЕсли;
	ЭмитироватьКоманду("КОНЕЦБЛОКА", Сем.СчетчикБлоков, Сем, Узел);
	ЭмитироватьКоманду("ПЕРЕХОД", 0, Сем, Узел, , Сем.ИдентификаторКомандыПоследнейОстановки);
КонецПроцедуры
Процедура _Переменная(Сем, Узел, Компиляция, Ошибки)
	Узел.Атрибуты.Вставить("ИмяПеременной", Узел.СоставУзла[0].Значение);
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
КонецПроцедуры
Процедура _СложныйВызовПроцедуры(Сем, Узел, Компиляция, Ошибки)
	ОбработатьСложныйВызовОбщий(Сем, Узел, Ошибки);
КонецПроцедуры
Процедура _ВыражениеИли(Сем, Узел, Компиляция, Ошибки)
	ОбработатьБулевоВыражение(Сем, Узел, "ИЛИ");
КонецПроцедуры
Процедура _Ключ_Функция(Сем, Узел, Компиляция, Ошибки)
	ОбработатьНачалоПодпрограммы(Сем, Узел);
КонецПроцедуры
Процедура _ВыражениеПродолжить(Сем, Узел, Компиляция, Ошибки)
	Если Сем.СчетчикЦиклов = 0 Тогда
		конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, НСтр("ru='Оператор Продолжить (Continue) может употребляться только внутри цикла';en='Continue operator may be used only within loop'", ТекущийЯзыкСистемы()), Сем, Узел.СоставУзла[0]);
	КонецЕсли;
	ИдПрод = Новый Массив;
	ИдПрод.Добавить(ЭмитироватьКоманду("ПЕРЕХОД", 0, Сем, Узел));
	Узел.Атрибуты.Вставить("ИдентификаторыКомандПродолжения", ИдПрод);
КонецПроцедуры
Процедура _РасширеннаяПеременная(Сем, Узел, Компиляция, Ошибки)
	Узел.Атрибуты.Вставить("ИмяПеременной", Узел.СоставУзла[0].Значение);
КонецПроцедуры
// Разрешает переменную присваивания: определяет список переменных, создаёт при необходимости,
// возвращает флаг переменной. Устанавливает атрибут ИмяПеременной на узле.
//
// Параметры:
//  Узел - Структура - узел AST с составом, содержащим имя переменной
//  Сем - Структура - данные семантического анализа
//
// Возвращаемое значение:
//  Строка, Неопределено - флаг переменной ("Внешняя", "НеявнаяЛокальная", "НеявнаяМодульная") или Неопределено
Функция РазрешитьПеременнуюПрисваивания(Узел, Сем)
	ИмяПеременнойПрисваивания = Узел.СоставУзла[0].Атрибуты.ИмяПеременной;
	Если Сем.ЧтениеПодпрограммы Тогда
		СписокПеременныхПрисваивания = Сем.Подпрограммы[Сем.КлючТекущейПодпрограммы].Переменные;
	Иначе
		СписокПеременныхПрисваивания = Сем.Переменные;
	КонецЕсли;
	ФлагПеременнойПрисваивания = Неопределено;
	Если СписокПеременныхПрисваивания[ВРег(ИмяПеременнойПрисваивания)] = Неопределено Тогда
		АдресНовойПеременнойПрисваивания = СписокПеременныхПрисваивания.Количество();
		Если конс_КомпиляцияКлиентСервер.ЭтоВнешняяПеременная(ИмяПеременнойПрисваивания) Тогда
			ФлагПеременнойПрисваивания = "Внешняя";
		ИначеЕсли Сем.ЧтениеПодпрограммы И Сем.Переменные[ВРег(ИмяПеременнойПрисваивания)] <> Неопределено Тогда
			ФлагПеременнойПрисваивания = Сем.Переменные[ВРег(ИмяПеременнойПрисваивания)].Флаг;
		Иначе
			ФлагПеременнойПрисваивания = ?(Сем.ЧтениеПодпрограммы, "НеявнаяЛокальная", "НеявнаяМодульная");
		КонецЕсли;
		СписокПеременныхПрисваивания.Вставить(ВРег(ИмяПеременнойПрисваивания), Новый Структура("Адрес,Флаг,Имя", АдресНовойПеременнойПрисваивания, ФлагПеременнойПрисваивания, ИмяПеременнойПрисваивания));
	КонецЕсли;
	Узел.Атрибуты.Вставить("ИмяПеременной", ИмяПеременнойПрисваивания);
	Возврат ФлагПеременнойПрисваивания;
КонецФункции
Процедура _РезультатПрисваивания(Сем, Узел, Компиляция, Ошибки)
	Флаг = Неопределено;
	Если Узел.СоставУзла[0].Атрибуты.Свойство("ИмяПеременной") Тогда
		Флаг = РазрешитьПеременнуюПрисваивания(Узел, Сем);
	КонецЕсли;
	Если Узел.СоставУзла[0].Свойство("Нетерминал") И Узел.СоставУзла[0].Атрибуты.Свойство("ИмяПеременной") Тогда
		Данные = конс_КомпиляцияКлиентСервер.ПолучитьДанныеПеременнойВМ(Узел.СоставУзла[0].Атрибуты.ИмяПеременной, Сем, Ошибки, Узел.НомерСтроки);
		ЭмитироватьКоманду(Данные.ОпКод, Данные.Адрес, Сем, Узел);
	КонецЕсли;
	// Флаг ставим ПОСЛЕ загрузки левой части, чтобы проверка сработала только для правой части выражения
	Если Флаг = "НеявнаяЛокальная" Тогда
		Сем.Вставить("ПеременнаяОжидающаяПрисваивания", ВРег(Узел.Атрибуты.ИмяПеременной));
	КонецЕсли;
КонецПроцедуры
Процедура _ОператорСложенияВычитания(Сем, Узел, Компиляция, Ошибки)
КонецПроцедуры
Процедура _ЦиклПока(Сем, Узел, Компиляция, Ошибки)
	// --- Подготовка контекста ---
	ЕстьТело = Узел.СоставУзла.Количество() = 5;
	СтрокаКонца = ?(ЕстьТело, Узел.СоставУзла[4].НомерСтроки, Узел.СоставУзла[3].НомерСтроки);
	ИдПослТела = ?(ЕстьТело, Узел.СоставУзла[3].Атрибуты.ИдентификаторПоследнейКоманды, Узел.СоставУзла[1].Атрибуты.ИдентификаторПоследнейКоманды);
	ИдПослУсл = Узел.СоставУзла[1].Атрибуты.ИдентификаторПоследнейКоманды;
	КолОпер = Узел.СоставУзла[1].Атрибуты.КоличествоОпераций;
	
	// --- Эмиссия команд цикла ---
	ИдСтрока = ЭмитироватьКоманду("НОМЕРСТРОКИ", СтрокаКонца, Сем, Узел, ИдПослТела);
	ИдВозврата = ЭмитироватьКоманду("ПЕРЕХОД", 0, Сем, Узел, ИдСтрока, ИдПослУсл, -КолОпер);
	ИдУсловия = ЭмитироватьКоманду("НОМЕРСТРОКИ", 0, Сем, Узел, ИдПослУсл);
	ЭмитироватьКоманду("ПЕРЕХОДЛОЖЬ", 0, Сем, Узел, ИдУсловия, ИдВозврата, 1);
	
	// --- Привязка выхода/продолжения ---
	Если ЕстьТело Тогда
		ПривязатьИдентификаторыКоманд(Узел.СоставУзла[3], Сем, ИдВозврата, 1, "ИдентификаторыКомандВыхода");
		ПривязатьИдентификаторыКоманд(Узел.СоставУзла[3], Сем, ИдПослУсл, -КолОпер, "ИдентификаторыКомандПродолжения");
	КонецЕсли;
	
	Сем.СчетчикЦиклов = Сем.СчетчикЦиклов - 1;
КонецПроцедуры
Процедура _Модуль(Сем, Узел, Компиляция, Ошибки)
	Если Узел.СоставУзла.Количество() > 1 Тогда
		ПервыйЭлементМодуля = Узел.СоставУзла[0];
		Если ПервыйЭлементМодуля.Нетерминал = "СписокОператоров" И ПервыйЭлементМодуля.Атрибуты.ЭтоОбъявлениеПеременных = Ложь Тогда
			Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 0, НСтр("ru='Определения процедур и функций должны размещаться перед операторами тела модуля';en='Definitions of procedures and functions must be placed before the statements of the module body'", ТекущийЯзыкСистемы()), Сем.СтрокаПервойПодпрограммы));
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры
Процедура _СписокПроцедурФункций(Сем, Узел, Компиляция, Ошибки)
КонецПроцедуры
Процедура _ОперандИли(Сем, Узел, Компиляция, Ошибки)
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[0], Сем, Ошибки, Узел);
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
КонецПроцедуры
Процедура _ВыражениеКонструктора(Сем, Узел, Компиляция, Ошибки)
	КолАрг = 0;
	Именован = Узел.СоставУзла[1].Терминал = "Лит_Идентификатор";
	Если Именован Тогда
		Если Узел.СоставУзла.Количество() = 5 Тогда
			КолАрг = Узел.СоставУзла[3].Атрибуты.ТекущееКоличествоАргументов;
		КонецЕсли;
		ЭмитироватьКоманду("ЧИСЛОАРГ", КолАрг, Сем, Узел);
	Иначе
		КолАрг = ?(Узел.СоставУзла.Количество() = 6, 2, 1);
		Если КолАрг = 1 Тогда
			ЭмитироватьКоманду("НЕОПР", 0, Сем, Узел);
		КонецЕсли;
	КонецЕсли;
	Если Именован Тогда
		ЗарегистрироватьКонстанту(Узел.СоставУзла[1].Значение, Сем);
		ЭмитироватьКоманду("НОВЫЙ_П", Сем.Константы[Узел.СоставУзла[1].Значение], Сем, Узел);
	Иначе
		ЭмитироватьКоманду("НОВЫЙ_2", 0, Сем, Узел);
	КонецЕсли;
КонецПроцедуры
Процедура _ОперандИ(Сем, Узел, Компиляция, Ошибки)
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[0], Сем, Ошибки, Узел);
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
КонецПроцедуры
Процедура _Ключ_Пока(Сем, Узел, Компиляция, Ошибки)
	Сем.СчетчикЦиклов = Сем.СчетчикЦиклов + 1;
КонецПроцедуры
Процедура _ЦиклДляКаждого(Сем, Узел, Компиляция, Ошибки)
	// --- Подготовка контекста цикла ---
	ИдПослВыр = Узел.СоставУзла[2].Атрибуты.ИдентификаторПоследнейКоманды;
	ИдСтрока = ЭмитироватьКоманду("НОМЕРСТРОКИ", 0, Сем, Узел, ИдПослВыр);
	
	ЕстьТело = Узел.СоставУзла.Количество() = 6;
	СтрокаКонца = ?(ЕстьТело, Узел.СоставУзла[5].НомерСтроки, Узел.СоставУзла[4].НомерСтроки);
	ИдПослТела = ?(ЕстьТело, Узел.СоставУзла[4].Атрибуты.ИдентификаторПоследнейКоманды, Неопределено);
	ИдДоВыхода = конс_КомпиляцияКлиентСервер.ОпределитьИдентификаторКомандыДоВыхода(ЕстьТело, ИдПослВыр, ИдПослТела, ИдСтрока);
	ИдКонца = ЭмитироватьКоманду("НОМЕРСТРОКИ", СтрокаКонца, Сем, Узел, ИдДоВыхода);
	
	// --- Данные переменной и итератора ---
	ИмяПерем = Узел.СоставУзла[2].СоставУзла[0].Атрибуты.ИмяПеременной;
	ДанныеПерем = конс_КомпиляцияКлиентСервер.ПолучитьДанныеПеременнойВМ(ИмяПерем, Сем, Ошибки, Узел.НомерСтроки);
	ДанныеИтер = конс_КомпиляцияКлиентСервер.ПолучитьДанныеПеременнойВМ("0" + ИмяПерем, Сем, Ошибки, Узел.НомерСтроки);
	
	// --- Инициализация итератора: iterator = GetIterator(collection) ---
	Ид = ЭмитироватьКоманду(ДанныеИтер.ОпКод, ДанныеИтер.Адрес, Сем, Узел, ИдСтрока);
	Ид = ЭмитироватьКоманду("ЗАГРВРЕМ", 0, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ПРИСВОИТЬ", 0, Сем, Узел, Ид);
	
	// --- Проверка условия: if (!iterator.MoveNext()) goto end ---
	Ид = ЭмитироватьКоманду(ДанныеИтер.ОпКод, ДанныеИтер.Адрес, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("СЛЕДУЮЩИЙ", 0, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ПЕРЕХОДЛОЖЬ", 0, Сем, Узел, Ид, ИдКонца, 2);
	
	// --- Присваивание значения: variable = iterator.Current ---
	Ид = ЭмитироватьКоманду(ДанныеПерем.ОпКод, ДанныеПерем.Адрес, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду(ДанныеИтер.ОпКод, ДанныеИтер.Адрес, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ПРИСВОИТЬ", 0, Сем, Узел, Ид);
	
	// --- Сброс итератора после присваивания: iterator = Undefined ---
	Ид = ЭмитироватьКоманду(ДанныеИтер.ОпКод, ДанныеИтер.Адрес, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("НЕОПР", 0, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ПРИСВОИТЬ", 0, Сем, Узел, Ид);
	
	// --- Переход к следующей итерации ---
	ИдПерехода = ЭмитироватьКоманду("ПЕРЕХОД", 0, Сем, Узел, ИдКонца, ИдСтрока);
	
	// --- Очистка после цикла: извлечение временной переменной ---
	Ид = ЭмитироватьКоманду("ИЗВЛВРЕМ", 1, Сем, Узел, ИдПерехода);
	
	// --- Финализация итератора: iterator = Undefined (2 раза для полной очистки) ---
	Ид = ЭмитироватьКоманду(ДанныеИтер.ОпКод, ДанныеИтер.Адрес, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("НЕОПР", 0, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ПРИСВОИТЬ", 0, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду(ДанныеИтер.ОпКод, ДанныеИтер.Адрес, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("НЕОПР", 0, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ПРИСВОИТЬ", 0, Сем, Узел, Ид);
	
	// --- Привязка команд выхода и продолжения из тела цикла ---
	Если ЕстьТело Тогда
		ПривязатьИдентификаторыКоманд(Узел.СоставУзла[4], Сем, ИдПерехода, 1, "ИдентификаторыКомандВыхода");
		ПривязатьИдентификаторыКоманд(Узел.СоставУзла[4], Сем, ИдПерехода, , "ИдентификаторыКомандПродолжения");
	КонецЕсли;
	
	Сем.СчетчикЦиклов = Сем.СчетчикЦиклов - 1;
КонецПроцедуры
Процедура _СписокАргументовПроцедурыФункции(Сем, Узел, Компиляция, Ошибки)
	МассивАргументовСписка = Новый Массив;
	Если Узел.СоставУзла.Количество() = 3 Тогда
		Для Каждого ЭлементАргумента Из Узел.СоставУзла[0].Атрибуты.МассивАргументов Цикл
			МассивАргументовСписка.Добавить(ЭлементАргумента);
		КонецЦикла;
		МассивАргументовСписка.Добавить(Узел.СоставУзла[2].Атрибуты.Аргумент);
	Иначе
		МассивАргументовСписка.Добавить(Узел.СоставУзла[0].Атрибуты.Аргумент);
	КонецЕсли;
	Узел.Атрибуты.Вставить("МассивАргументов", МассивАргументовСписка);
КонецПроцедуры
Процедура _ОперандСложенияВычитания(Сем, Узел, Компиляция, Ошибки)
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[0], Сем, Ошибки, Узел);
КонецПроцедуры
Процедура _ВыражениеВызватьИсключение(Сем, Узел, Компиляция, Ошибки)
	Если Сем.СчетчикПопыток = 0 И Узел.СоставУзла.Количество() = 1 Тогда
		Текст = НСтр("ru='Оператор ВызватьИсключение (Raise) без аргументов может употребляться только при обработке исключения';en='Raise operator may be used without arguments only when handling exception'", ТекущийЯзыкСистемы());
		конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, Текст, Сем, Узел.СоставУзла[0]);
	КонецЕсли;
	ЭмитироватьКоманду("ИСКЛЮЧЕНИЕ", Узел.СоставУзла.Количество() - 1, Сем, Узел);
КонецПроцедуры
Процедура _ВыражениеСложенияВычитания(Сем, Узел, Компиляция, Ошибки)
	ОпКод = ?(Узел.СоставУзла[1].СоставУзла[0].Терминал = "Оп_Плюс", "СЛОЖИТЬ", "ВЫЧЕСТЬ");
	ЭмитироватьКоманду(ОпКод, 0, Сем, Узел);
КонецПроцедуры
// Эмитирует команду ВМ для вызова встроенной функции.
// Обрабатывает специальные случаи (СРЕД, КОДСИМВОЛА, ОКР, ФОРМАТ, МАКС, МИН).
//
// Параметры:
//  Сем - Структура - данные семантического анализа
//  Узел - Структура - узел AST с атрибутами вызова (КоличествоАргументов)
//  ОписаниеВстроенной - Соответствие - соответствие количества аргументов и опкодов встроенной функции
//  ИмяФункцииВерхнийРегистр - Строка - имя встроенной функции в верхнем регистре
Процедура ЭмитироватьВстроеннуюФункцию(Сем, Узел, Опис, Имя)
	ОК = Опис[Узел.Атрибуты.КоличествоАргументов];
	Если ОК <> Неопределено Тогда
		ЭмитироватьКоманду(ОК, 0, Сем, Узел);
	ИначеЕсли Имя = "СРЕД" Тогда
		ЭмитироватьКоманду("КОНСТ", конс_КомпиляцияКлиентСервер.ПолучитьАдресКонстантыВМ(-1, Сем), Сем, Узел);
		ЭмитироватьКоманду("СРЕД", 0, Сем, Узел);
	ИначеЕсли Имя = "КОДСИМВОЛА" Тогда
		ЭмитироватьКоманду("КОНСТ", конс_КомпиляцияКлиентСервер.ПолучитьАдресКонстантыВМ(1, Сем), Сем, Узел);
		ЭмитироватьКоманду("КОДСИМВОЛА", 0, Сем, Узел);
	ИначеЕсли Имя = "ОКР" Тогда
		ЭмитироватьКоманду("КОНСТ", конс_КомпиляцияКлиентСервер.ПолучитьАдресКонстантыВМ(0, Сем), Сем, Узел);
		ЭмитироватьКоманду("ОКР_2", 0, Сем, Узел);
	ИначеЕсли Имя = "ФОРМАТ" Тогда
		ЭмитироватьКоманду("НЕОПР", 0, Сем, Узел);
		ЭмитироватьКоманду("ФОРМАТ", 0, Сем, Узел);
	ИначеЕсли Имя = "МАКС" Тогда
		ЭмитироватьКоманду("МАКС", 0, Сем, Узел);
	ИначеЕсли Имя = "МИН" ИЛИ Имя = "MIN" Тогда
		ЭмитироватьКоманду("МИН", 0, Сем, Узел);
	КонецЕсли;
КонецПроцедуры
Процедура _Вызов(Сем, Узел, Компиляция, Ошибки)
	ПосчитатьАргументыВызова(Сем, Узел);
	Имя = ВРег(Узел.СоставУзла[0].Значение);
	Опис = Сем.ИменаВстроенныхФункций[Имя];
	Если Опис = Неопределено Тогда
		ФлагГлоб = Сем.МетодыГлобальногоКонтекста[Имя];
		ФлагВн = конс_КомпиляцияКлиентСервер.ОпределитьФлагВнешнейПодпрограммы(ФлагГлоб, "ВнешняяФункция", 32);
		Адр = конс_КомпиляцияКлиентСервер.ПолучитьПодпрограммуВМ(Узел.СоставУзла[0].Значение, Сем, ФлагВн, Узел.Атрибуты.КоличествоАргументов).Адрес;
		ЭмитироватьКоманду("ВЫЗЛОК", Адр, Сем, Узел);
		ЭмитироватьКоманду("РЕЗФУНК", 0, Сем, Узел);
		ЭмитироватьКоманду("НОМЕРСТРОКИ", Узел.НомерСтроки, Сем, Узел);
	Иначе
		ЭмитироватьВстроеннуюФункцию(Сем, Узел, Опис, Имя);
	КонецЕсли;
	ОписВыз = Новый Структура("Терминал,КоличествоАргументов,ВызовФункции", Узел.СоставУзла[0], Узел.Атрибуты.КоличествоАргументов, Узел.Нетерминал = "Вызов");
	Сем.Вызовы.Добавить(ОписВыз);
КонецПроцедуры
Процедура _ОператорПопытки(Сем, Узел, Компиляция, Ошибки)
	// --- Подготовка контекста ---
	СтрокаКонца = Узел.СоставУзла[Узел.СоставУзла.Количество() - 1].НомерСтроки;
	ТелоИсключ = Узел.СоставУзла[Узел.СоставУзла.Количество() - 2];
	АдресНачала = Сем.КомандыВМ.Количество() - Узел.Атрибуты.КоличествоОпераций;
	
	// --- Эмиссия: НОМЕРСТРОКИ, КОНЕЦПОПЫТКИ ---
	ИдСтрока = ЭмитироватьКоманду("НОМЕРСТРОКИ", СтрокаКонца, Сем, Узел);
	ИдКонецПоп = ЭмитироватьКоманду("КОНЕЦПОПЫТКИ", 0, Сем, Узел, ИдСтрока);
	
	// --- Эмиссия: ПОПЫТКА (с вычислением сдвига для исключения) ---
	Если ТелоИсключ.Нетерминал = "СписокОператоров" Тогда
		ИдПопытка = ЭмитироватьКоманду("ПОПЫТКА", 0, Сем, Узел, АдресНачала, ИдСтрока, -ТелоИсключ.Атрибуты.КоличествоОпераций);
	Иначе
		ИдПопытка = ЭмитироватьКоманду("ПОПЫТКА", 0, Сем, Узел, АдресНачала, ИдСтрока);
	КонецЕсли;
	
	// --- Эмиссия: НОМЕРСТРОКИ для обработчика ---
	Если Узел.СоставУзла[1].Нетерминал = "БлокИсключение" Тогда
		ИдСтрокаОбр = ЭмитироватьКоманду("НОМЕРСТРОКИ", СтрокаКонца, Сем, Узел, ИдПопытка);
	ИначеЕсли Узел.СоставУзла[1].Атрибуты.КоличествоОпераций = 0 Тогда
		ИдСтрокаОбр = ЭмитироватьКоманду("НОМЕРСТРОКИ", СтрокаКонца, Сем, Узел, ИдПопытка);
	Иначе
		ИдСтрокаОбр = ЭмитироватьКоманду("НОМЕРСТРОКИ", СтрокаКонца, Сем, Узел, Узел.СоставУзла[1].Атрибуты.ИдентификаторПоследнейКоманды);
	КонецЕсли;
	
	// --- Эмиссия: КОНЕЦБЛОКА, ПЕРЕХОД к концу попытки ---
	ИдКонецБлока = ЭмитироватьКоманду("КОНЕЦБЛОКА", 1, Сем, Узел, ИдСтрокаОбр);
	ЭмитироватьКоманду("ПЕРЕХОД", 1, Сем, Узел, ИдКонецБлока, ИдКонецПоп, 1);
	
	СобратьИдентификаторыВыходаИПродолжения(Узел);
	Сем.СчетчикПопыток = Сем.СчетчикПопыток - 1;
КонецПроцедуры
Процедура _ВыражениеНе(Сем, Узел, Компиляция, Ошибки)
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[1], Сем, Ошибки, Узел);
	ЭмитироватьКоманду("НЕ", 0, Сем, Узел);
КонецПроцедуры
Процедура _ИмяМетода(Сем, Узел, Компиляция, Ошибки)
	ЗарегистрироватьКонстанту(Узел.СоставУзла[0].Значение, Сем);
КонецПроцедуры
Процедура _ОперандУмноженияДеления(Сем, Узел, Компиляция, Ошибки)
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[0], Сем, Ошибки, Узел);
КонецПроцедуры
Процедура _ОператорСравнения(Сем, Узел, Компиляция, Ошибки)
КонецПроцедуры
Процедура _ЦиклДля(Сем, Узел, Компиляция, Ошибки)
	// --- Подготовка данных счётчика ---
	ИмяСчетчика = Узел.СоставУзла[1].СоставУзла[0].Атрибуты.ИмяПеременной;
	ДанныеСчетчика = конс_КомпиляцияКлиентСервер.ПолучитьДанныеПеременнойВМ(ИмяСчетчика, Сем, Ошибки, Узел.НомерСтроки);
	ИдПослВыр = Узел.СоставУзла[3].Атрибуты.ИдентификаторПоследнейКоманды;
	
	// --- Инициализация: сохранить границу во временную переменную ---
	Ид = ЭмитироватьКоманду("ПОМВРЕМ", 0, Сем, Узел, Узел.СоставУзла[1].Атрибуты.ИдентификаторПоследнейКоманды);
	ЭмитироватьКоманду("ЗАГРВРЕМ", 0, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ПРИСВОИТЬ", 0, Сем, Узел, ИдПослВыр);
	
	// --- Проверка условия: счётчик >= граница ---
	ИдСтрока = ЭмитироватьКоманду("НОМЕРСТРОКИ", 0, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ЗАГРВРЕМ", 0, Сем, Узел, ИдСтрока);
	Ид = ЭмитироватьКоманду(ДанныеСчетчика.ОпКод, ДанныеСчетчика.Адрес, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("БОЛЬШЕРАВНО", 0, Сем, Узел, Ид);
	ИдПереходЛожь = ЭмитироватьКоманду("ПЕРЕХОДЛОЖЬ", 0, Сем, Узел, Ид);
	
	// --- Контекст тела цикла ---
	ЕстьТело = Узел.СоставУзла.Количество() = 7;
	ИдПослТела = ?(ЕстьТело, Узел.СоставУзла[5].Атрибуты.ИдентификаторПоследнейКоманды, Неопределено);
	СтрокаКонца = ?(ЕстьТело, Узел.СоставУзла[6].НомерСтроки, Узел.СоставУзла[5].НомерСтроки);
	ИдДоВыхода = конс_КомпиляцияКлиентСервер.ОпределитьИдентификаторКомандыДоВыхода(ЕстьТело, ИдПослВыр, ИдПослТела, ИдПереходЛожь);
	
	// --- Инкремент и переход к началу цикла ---
	Ид = ЭмитироватьКоманду("НОМЕРСТРОКИ", СтрокаКонца, Сем, Узел, ИдДоВыхода);
	Ид = ЭмитироватьКоманду(ДанныеСчетчика.ОпКод, ДанныеСчетчика.Адрес, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ИНКРЕМЕНТ", 0, Сем, Узел, Ид);
	Ид = ЭмитироватьКоманду("ПЕРЕХОД", 0, Сем, Узел, Ид, ИдСтрока);
	ИдИзвлечьВрем = ЭмитироватьКоманду("ИЗВЛВРЕМ", 1, Сем, Узел, Ид);
	
	// --- Привязка ПЕРЕХОДЛОЖЬ к завершению цикла ---
	ДанныеПереходЛожь = конс_КомпиляцияКлиентСервер.ПолучитьКомандуПоИдентификатору(Сем, ИдПереходЛожь);
	ДанныеПереходЛожь.ИдентификаторАргумента = ИдИзвлечьВрем;
	
	// --- Привязка выхода/продолжения из тела цикла ---
	Если ЕстьТело Тогда
		ПривязатьИдентификаторыКоманд(Узел.СоставУзла[5], Сем, ИдИзвлечьВрем, , "ИдентификаторыКомандВыхода");
		ПривязатьИдентификаторыКоманд(Узел.СоставУзла[5], Сем, ИдДоВыхода, 2, "ИдентификаторыКомандПродолжения");
	КонецЕсли;
	
	Сем.СчетчикЦиклов = Сем.СчетчикЦиклов - 1;
КонецПроцедуры
Процедура _ОперандСравнения(Сем, Узел, Компиляция, Ошибки)
	ЗагрузитьПеременнуюНаСтек(Узел.СоставУзла[0], Сем, Ошибки, Узел);
КонецПроцедуры
Процедура _ВыражениеПрервать(Сем, Узел, Компиляция, Ошибки)
	Если Сем.СчетчикЦиклов = 0 Тогда
		конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, НСтр("ru='Оператор Прервать (Break) может употребляться только внутри цикла';en='Break operator may be used only within loop'", ТекущийЯзыкСистемы()), Сем, Узел.СоставУзла[0]);
	КонецЕсли;
	ИдВых = Новый Массив;
	ИдВых.Добавить(ЭмитироватьКоманду("ПЕРЕХОД", 0, Сем, Узел));
	Узел.Атрибуты.Вставить("ИдентификаторыКомандВыхода", ИдВых);
КонецПроцедуры
Процедура _СписокАргументовКонструктора(Сем, Узел, Компиляция, Ошибки)
	ОбработатьСписокАргументовОбщий(Сем, Узел, "НЕОПР");
КонецПроцедуры
Процедура _РасширенноеИмяМетода(Сем, Узел, Компиляция, Ошибки)
	ЗарегистрироватьКонстанту(Узел.СоставУзла[0].Значение, Сем);
КонецПроцедуры
Процедура _СписокАргументовВыражения(Сем, Узел, Компиляция, Ошибки)
	ОбработатьСписокАргументовОбщий(Сем, Узел, "ПУСТО");
КонецПроцедуры
// Определяет значение константы из узла AST (число, дата, булево, Null, Неопределено, строка).
//
// Параметры:
//  Узел - Структура - узел AST, содержащий литерал константы
//
// Возвращаемое значение:
//  Число, Дата, Булево, Null, Неопределено, Строка - значение константы соответствующего типа
Функция ОпределитьЗначениеКонстантыИзУзла(Узел)
	Если НЕ Узел.СоставУзла[0].Свойство("Терминал") Тогда
		Возврат СтрЗаменить(Узел.СоставУзла[0].Атрибуты.ТекСтрока, """""", """");
	КонецЕсли;
	Если Узел.СоставУзла[0].Терминал = "Лит_Число" Тогда
		Возврат Число(Узел.СоставУзла[0].Значение);
	ИначеЕсли Узел.СоставУзла[0].Терминал = "Лит_Дата" Тогда
		МассивЦифр = СтрРазделить("0,1,2,3,4,5,6,7,8,9", ",");
		ПозицияВДате = 1;
		ТекстДаты = Сред(Узел.СоставУзла[0].Значение, 2, СтрДлина(Узел.СоставУзла[0].Значение) - 2);
		ДлинаТекстаДаты = СтрДлина(ТекстДаты);
		ОчищеннаяДата = "";
		Пока ПозицияВДате <= ДлинаТекстаДаты Цикл
			ТекущийСимволДаты = Сред(ТекстДаты, ПозицияВДате, 1);
			Если МассивЦифр.Найти(ТекущийСимволДаты) <> Неопределено Тогда
				ОчищеннаяДата = ОчищеннаяДата + ТекущийСимволДаты;
			КонецЕсли;
			ПозицияВДате = ПозицияВДате + 1;
		КонецЦикла;
		Возврат Дата(ОчищеннаяДата);
	ИначеЕсли Узел.СоставУзла[0].Терминал = "Лит_Истина" Тогда
		Возврат Истина;
	ИначеЕсли Узел.СоставУзла[0].Терминал = "Лит_Ложь" Тогда
		Возврат Ложь;
	ИначеЕсли Узел.СоставУзла[0].Терминал = "Лит_Неопределено" Тогда
		Возврат Неопределено;
	ИначеЕсли Узел.СоставУзла[0].Терминал = "Лит_Null" Тогда
		Возврат Null;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции
// Эмитирует команду ВМ для загрузки константы на стек.
// Спецзначения (Неопределено, Null, Истина, Ложь) имеют собственные опкоды.
//
// Параметры:
//  Сем - Структура - данные семантического анализа с таблицей констант
//  Узел - Структура - узел AST с атрибутом ЗначениеКонстанты
Процедура ЭмитироватьКомандуКонстанты(Сем, Узел)
	Терм = Неопределено;
	Если Узел.СоставУзла[0].Свойство("Терминал", Терм) Тогда
		Если Терм = "Лит_Неопределено" Тогда
			ЭмитироватьКоманду("НЕОПР", 0, Сем, Узел);
		ИначеЕсли Терм = "Лит_Истина" Тогда
			ЭмитироватьКоманду("ИСТИНА", 0, Сем, Узел);
		ИначеЕсли Терм = "Лит_Ложь" Тогда
			ЭмитироватьКоманду("ЛОЖЬ", 0, Сем, Узел);
		ИначеЕсли Терм = "Лит_Null" Тогда
			ЭмитироватьКоманду("НУЛЬ", 0, Сем, Узел);
		Иначе
			ЭмитироватьКоманду("КОНСТ", Сем.Константы[Узел.Атрибуты.ЗначениеКонстанты], Сем, Узел);
		КонецЕсли;
	Иначе
		ЭмитироватьКоманду("КОНСТ", Сем.Константы[Узел.Атрибуты.ЗначениеКонстанты], Сем, Узел);
	КонецЕсли;
КонецПроцедуры
Процедура _ПервичноеВыражение(Сем, Узел, Компиляция, Ошибки)
	ЗначениеКонстанты = ОпределитьЗначениеКонстантыИзУзла(Узел);
	Узел.Атрибуты.Вставить("ЗначениеКонстанты", ЗначениеКонстанты);
	Если НЕ Сем.ЧтениеЗаголовкаПодпрограммы Тогда
		Если НЕ ЭтоСпецЗначениеКонстанты(ЗначениеКонстанты) Тогда
			конс_КомпиляцияКлиентСервер.ПолучитьАдресКонстантыВМ(ЗначениеКонстанты, Сем);
		КонецЕсли;
		ЭмитироватьКомандуКонстанты(Сем, Узел);
	КонецЕсли;
КонецПроцедуры
Процедура _ВызовМетодаПроцедуры(Сем, Узел, Компиляция, Ошибки)
	ПосчитатьАргументыВызова(Сем, Узел);
	Адр = Сем.Константы[Узел.СоставУзла[0].СоставУзла[0].Значение];
	ЭмитироватьКоманду("ВЫЗПРОЦ", Адр, Сем, Узел);
	ЭмитироватьКоманду("НОМЕРСТРОКИ", 0, Сем, Узел);
КонецПроцедуры
// Определяет имя и флаг переменной при объявлении через Перем.
//
// Параметры:
//  Узел - Структура - узел AST объявления переменной
//  Сем - Структура - данные семантического анализа
//
// Возвращаемое значение:
//  Структура - структура с полями Имя (Строка) и Флаг (Строка)
Функция ОпределитьИмяИФлагПеременнойОбъявления(Узел, Сем)
	Если Узел.СоставУзла[0].Свойство("Терминал") Тогда
		ИмяПеременной = Узел.СоставУзла[0].Значение;
		Если Сем.ЧтениеПодпрограммы Тогда
			ФлагПеременной = "НеявнаяЛокальная";
		Иначе
			ФлагПеременной = ?(Узел.СоставУзла.Количество() = 2, "ЯвнаяМодульная", "НеявнаяМодульная");
		КонецЕсли;
	Иначе
		ИмяПеременной = Узел.СоставУзла[2].Значение;
		Если Сем.ЧтениеПодпрограммы Тогда
			ФлагПеременной = "НеявнаяЛокальная";
		Иначе
			ФлагПеременной = ?(Узел.СоставУзла.Количество() = 4, "ЯвнаяМодульная", "НеявнаяМодульная");
		КонецЕсли;
	КонецЕсли;
	Возврат Новый Структура("Имя,Флаг", ИмяПеременной, ФлагПеременной);
КонецФункции
Процедура _СписокПеременных(Сем, Узел, Компиляция, Ошибки)
	Если Сем.РежимВыполнить Тогда
		ТекстОшибкиОбъявления = НСтр("ru='Объявления переменных должны быть расположены в начале модуля, процедуры или функции';en='Variable declarations must be placed at beginning of module, procedure, or function'", ТекущийЯзыкСистемы());
		Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 0, ТекстОшибкиОбъявления));
	КонецЕсли;
	ДанныеОбъявления = ОпределитьИмяИФлагПеременнойОбъявления(Узел, Сем);
	ИмяПеременнойОбъявления = ДанныеОбъявления.Имя;
	ФлагПеременнойОбъявления = ДанныеОбъявления.Флаг;
	Если конс_КомпиляцияКлиентСервер.ЭтоВнешняяПеременная(ИмяПеременнойОбъявления) Тогда
		ТекстОшибкиДубликата = НСтр("ru='Переменная с указанным именем уже определена (';en='A variable with this name is already defined ('", ТекущийЯзыкСистемы()) + ИмяПеременнойОбъявления + ")";
		Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 0, ТекстОшибкиДубликата, Узел.НомерСтроки));
	КонецЕсли;
	Если Сем.ЧтениеПодпрограммы Тогда
		СписокПеременныхОбъявления = Сем.Подпрограммы[Сем.КлючТекущейПодпрограммы].Переменные;
	Иначе
		СписокПеременныхОбъявления = Сем.Переменные;
	КонецЕсли;
	Если СписокПеременныхОбъявления[ВРег(ИмяПеременнойОбъявления)] = Неопределено Тогда
		АдресНовойПеременнойОбъявления = СписокПеременныхОбъявления.Количество();
		СписокПеременныхОбъявления.Вставить(ВРег(ИмяПеременнойОбъявления), Новый Структура("Адрес,Флаг,Имя", АдресНовойПеременнойОбъявления, ФлагПеременнойОбъявления, ИмяПеременнойОбъявления));
	КонецЕсли;
КонецПроцедуры
// Проверяет допустимость перехода между типами подстрок многострочной строки.
// Типы: 0 = начало ("|..."), 1 = середина закрытая ("|..."), 2 = середина открытая ("|...),
//        3 = полная строка ("...").
//
// Параметры:
//  ТипПодстроки - Число - тип текущей подстроки (0-3)
//  ТипПредыдущейПодстроки - Число - тип предыдущей подстроки (0-3)
//
// Возвращаемое значение:
//  Булево - Истина, если переход между типами подстрок допустим
Функция ПроверитьДопустимостьПереходаПодстрок(ТипПодстроки, ТипПредыдущейПодстроки)
	Если ТипПодстроки = 0 Тогда
		Возврат ТипПредыдущейПодстроки = 1 ИЛИ ТипПредыдущейПодстроки = 3;
	ИначеЕсли ТипПодстроки = 1 Тогда
		Возврат ТипПредыдущейПодстроки = 0 ИЛИ ТипПредыдущейПодстроки = 2;
	ИначеЕсли ТипПодстроки = 2 Тогда
		Возврат ТипПредыдущейПодстроки = 0 ИЛИ ТипПредыдущейПодстроки = 2;
	ИначеЕсли ТипПодстроки = 3 Тогда
		Возврат ТипПредыдущейПодстроки = 1 ИЛИ ТипПредыдущейПодстроки = 3;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции
// Определяет значение подстроки после удаления служебных символов (начальная кавычка и/или конечная).
//
// Параметры:
//  ЗначениеСтроки - Строка - исходный текст подстроки со служебными символами
//  ТипПодстроки - Число - тип подстроки (0-3), определяющий какие символы удалять
//
// Возвращаемое значение:
//  Строка - очищенное значение подстроки без служебных кавычек
Функция ОпределитьЗначениеПодстрокиПродолжения(ЗначениеСтроки, ТипПодстроки)
	Если ТипПодстроки = 0 ИЛИ ТипПодстроки = 2 Тогда
		Возврат Сред(ЗначениеСтроки, 2);
	ИначеЕсли ТипПодстроки = 1 ИЛИ ТипПодстроки = 3 Тогда
		Возврат Сред(ЗначениеСтроки, 2, СтрДлина(ЗначениеСтроки) - 2);
	Иначе
		Возврат ЗначениеСтроки;
	КонецЕсли;
КонецФункции
// Обрабатывает продолжение многострочной строки (когда текущая строка не первая).
//
// Параметры:
//  Узел - Структура - узел AST строки с текущей и предыдущей подстрокой
//  Сем - Структура - данные семантического анализа
//  Ошибки - Массив - массив ошибок компиляции для накопления
Процедура ОбработатьПродолжениеМногострочнойСтроки(Узел, Сем, Ошибки)
	ЗначениеСтроки = Узел.СоставУзла[1].Значение;
	ПредыдущийУзелСтроки = Узел.СоставУзла[0];
	ТипПодстроки = конс_КомпиляцияКлиентСервер.ОпределитьТипПодстроки(ЗначениеСтроки);
	ТипПредыдущейПодстроки = ПредыдущийУзелСтроки.Атрибуты.ТипПодстроки;
	Если ПроверитьДопустимостьПереходаПодстрок(ТипПодстроки, ТипПредыдущейПодстроки) Тогда
		ЗначениеСтроки = ОпределитьЗначениеПодстрокиПродолжения(ЗначениеСтроки, ТипПодстроки);
	Иначе
		конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, НСтр("ru='Неправильно задана многострочная строка';en='Incorrect multiline string specified'", ТекущийЯзыкСистемы()), Сем, Узел.СоставУзла[1]);
	КонецЕсли;
	Узел.Атрибуты.Вставить("ТипПодстроки", ТипПодстроки);
	Узел.Атрибуты.Вставить("ТекСтрока", ПредыдущийУзелСтроки.Атрибуты.ТекСтрока + Символы.ПС + ЗначениеСтроки);
КонецПроцедуры
Процедура _Строка(Сем, Узел, Компиляция, Ошибки)
	Если Узел.СоставУзла[0].Свойство("Терминал") Тогда
		ЗначениеСтроки = Узел.СоставУзла[0].Значение;
		ТипПодстроки = конс_КомпиляцияКлиентСервер.ОпределитьТипПодстроки(ЗначениеСтроки);
		Если ТипПодстроки = 0 Тогда
			ЗначениеСтроки = Сред(ЗначениеСтроки, 2);
		ИначеЕсли ТипПодстроки = 3 Тогда
			ЗначениеСтроки = Сред(ЗначениеСтроки, 2, СтрДлина(ЗначениеСтроки) - 2);
		Иначе
			конс_КомпиляцияКлиентСервер.ДобавитьОшибкуКомпиляции(Ошибки, НСтр("ru='Неправильно задана многострочная строка';en='Incorrect multiline string specified'", ТекущийЯзыкСистемы()), Сем, Узел.СоставУзла[0]);
		КонецЕсли;
		Узел.Атрибуты.Вставить("ТипПодстроки", ТипПодстроки);
		Узел.Атрибуты.Вставить("ТекСтрока", ЗначениеСтроки);
	Иначе
		ОбработатьПродолжениеМногострочнойСтроки(Узел, Сем, Ошибки);
	КонецЕсли;
КонецПроцедуры
Процедура _ВызовПроцедуры(Сем, Узел, Компиляция, Ошибки)
	ПосчитатьАргументыВызова(Сем, Узел);
	Флаг = Сем.МетодыГлобальногоКонтекста[ВРег(Узел.СоставУзла[0].Значение)];
	ФлагВн = конс_КомпиляцияКлиентСервер.ОпределитьФлагВнешнейПодпрограммы(Флаг, "ВнешняяПроцедура", 33);
	Адр = конс_КомпиляцияКлиентСервер.ПолучитьПодпрограммуВМ(Узел.СоставУзла[0].Значение, Сем, ФлагВн, Узел.Атрибуты.КоличествоАргументов).Адрес;
	ЭмитироватьКоманду("ВЫЗЛОК", Адр, Сем, Узел);
	ЭмитироватьКоманду("НОМЕРСТРОКИ", 0, Сем, Узел);
	Опис = Новый Структура("Терминал,КоличествоАргументов,ВызовФункции", Узел.СоставУзла[0], Узел.Атрибуты.КоличествоАргументов, Узел.Нетерминал = "Вызов");
	Сем.Вызовы.Добавить(Опис);
КонецПроцедуры
Процедура _ОператорУмноженияДеления(Сем, Узел, Компиляция, Ошибки)
КонецПроцедуры
Процедура _ВызовМетода(Сем, Узел, Компиляция, Ошибки)
	ПосчитатьАргументыВызова(Сем, Узел);
	Адр = Сем.Константы[Узел.СоставУзла[0].СоставУзла[0].Значение];
	ЭмитироватьКоманду("ВЫЗФУНК", Адр, Сем, Узел);
	ЭмитироватьКоманду("РЕЗФУНК", 0, Сем, Узел);
	ЭмитироватьКоманду("НОМЕРСТРОКИ", Узел.НомерСтроки, Сем, Узел);
КонецПроцедуры
Процедура _Разд_Запятая(Сем, Узел, Компиляция, Ошибки)
	Узел.Атрибуты.Вставить("ИдентификаторПоследнейКоманды", конс_КомпиляцияКлиентСервер.ПолучитьИдентификаторПоследнейКоманды(Сем));
КонецПроцедуры

#КонецОбласти // СемантическиеДействия

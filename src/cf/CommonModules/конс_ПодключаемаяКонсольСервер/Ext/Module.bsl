////////////////////////////////////////////////////////////////////////////////
// конс_ПодключаемаяКонсольСервер: Серверные процедуры и функции консоли кода
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область Инициализация

// Инициализирует редактор на сервере.
// Вызывать в ПриСозданииНаСервере формы.
// 
// Автоматически создаёт все служебные реквизиты формы и привязывает поле HTML.
// На форме должен быть только элемент ПолеHTML без привязки к реквизиту.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с полем HTML
//   ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы для хранилища
//   ПараметрыИнициализации - Структура, Строка, ЭлементФормы, Неопределено - параметры инициализации:
//     - Если Строка: имя элемента ПолеHTML на форме
//     - Если ЭлементФормы: элемент ПолеHTML (имя извлекается автоматически)
//     - Если Структура: дополнительные параметры:
//       * Версия - Строка - версия обработки для кэширования исходников
//       * ИмяПоляHTML - Строка - имя элемента ПолеHTML на форме (по умолчанию "HTML")
//       * ПереопределитьНастройки - Структура - настройки, которые переопределят значения из хранилища
//     - Если Неопределено: используется элемент с именем "HTML"
//
// Пример:
//   // С именем поля по умолчанию ("HTML"):
//   конс_ПодключаемаяКонсольСервер.ИнициализироватьРедактор(ЭтотОбъект, УникальныйИдентификатор);
//
//   // С передачей имени элемента напрямую:
//   конс_ПодключаемаяКонсольСервер.ИнициализироватьРедактор(ЭтотОбъект, УникальныйИдентификатор, "ПолеРедактора");
//
//   // С передачей элемента формы:
//   конс_ПодключаемаяКонсольСервер.ИнициализироватьРедактор(ЭтотОбъект, УникальныйИдентификатор, Элементы.ПолеРедактора);
//
//   // С передачей структуры параметров:
//   Параметры = Новый Структура("ИмяПоляHTML, Версия", "ПолеРедактора", "2.0");
//   конс_ПодключаемаяКонсольСервер.ИнициализироватьРедактор(ЭтотОбъект, УникальныйИдентификатор, Параметры);
//
Процедура ИнициализироватьРедактор(Форма, ИдентификаторФормы, ПараметрыИнициализации = Неопределено) Экспорт
	
	// Нормализуем параметры инициализации
	ПараметрыСтруктура = НормализоватьПараметрыИнициализации(Форма, ПараметрыИнициализации);
	
	// Определяем имя поля HTML
	Если ПараметрыСтруктура.Свойство("ИмяПоляHTML") И ЗначениеЗаполнено(ПараметрыСтруктура.ИмяПоляHTML) Тогда
		ИмяПоляHTML = ПараметрыСтруктура.ИмяПоляHTML;
	Иначе
		ИмяПоляHTML = "HTML";
	КонецЕсли;
	
	// Автоматически добавляем служебные реквизиты и привязываем поле HTML
	ДобавитьСлужебныеРеквизиты(Форма, ИмяПоляHTML);
	
	// Версия для кэширования исходников
	Если ПараметрыСтруктура.Свойство("Версия") И ЗначениеЗаполнено(ПараметрыСтруктура.Версия) Тогда
		Форма.конс_СтруктураПараметровРедактораКода.ВерсияОбработки = ПараметрыСтруктура.Версия;
	Иначе
		Форма.конс_СтруктураПараметровРедактораКода.ВерсияОбработки = "1.0";
	КонецЕсли;
	
	// Добавляем хеш макета к версии для автоматического обновления при изменении исходников
	ХешМакета = конс_ПодключаемаяКонсольПовтИсп.ПолучитьХешМакетаИсходников();
	Если ЗначениеЗаполнено(ХешМакета) Тогда
		Форма.конс_СтруктураПараметровРедактораКода.ВерсияОбработки =
			Форма.конс_СтруктураПараметровРедактораКода.ВерсияОбработки + "_" + ХешМакета;
	КонецЕсли;
	
	// Получаем данные макета с исходниками
	ДанныеМакета = конс_ПодключаемаяКонсольПовтИсп.ПолучитьДанныеМакетаИсходников();
	Если ДанныеМакета <> Неопределено Тогда
		Форма.конс_СтруктураПараметровРедактораКода.АдресМакета = ПоместитьВоВременноеХранилище(ДанныеМакета, ИдентификаторФормы);
	КонецЕсли;
	
	// Получаем коллекцию общих модулей для автодополнения (сериализуем в JSON)
	Попытка
		КоллекцияОбщихМодулей = ПолучитьКоллекциюОбщихМодулей();
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, КоллекцияОбщихМодулей);
		Форма.конс_СтруктураПараметровРедактораКода.АдресОбщихМодулей = ПоместитьВоВременноеХранилище(ЗаписьJSON.Закрыть(), ИдентификаторФормы);
	Исключение
		// Игнорируем ошибку - автодополнение общих модулей не критично
	КонецПопытки;
	
	// Загружаем настройки пользователя
	Настройки = ПолучитьНастройкиИзХранилища();
	
	// Переопределяем настройки, если заданы
	Если ПараметрыСтруктура.Свойство("ПереопределитьНастройки") Тогда
		Для Каждого КлючЗначение Из ПараметрыСтруктура.ПереопределитьНастройки Цикл
			Если Настройки.Свойство(КлючЗначение.Ключ) Тогда
				Настройки.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Сохраняем настройки в форму
	Форма.конс_СтруктураПараметровРедактораКода.АдресНастроек = ПоместитьВоВременноеХранилище(Настройки, ИдентификаторФормы);
	
	// Включаем отображение подсказки контекста в виде кнопки
	Элемент = Форма.Элементы.Найти(ИмяПоляHTML);
	Если Элемент <> Неопределено Тогда
		Элемент.ОтображениеПодсказки = ОтображениеПодсказки.Кнопка;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет служебные реквизиты формы для работы редактора.
// Вызывается автоматически при инициализации.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка - имя элемента ПолеHTML на форме
//
Процедура ДобавитьСлужебныеРеквизиты(Форма, ИмяПоляHTML)
	
	НовыеРеквизиты = Новый Массив;
	
	// Единственный служебный реквизит - структура со всеми параметрами
	Если Не ЕстьРеквизит(Форма, "конс_СтруктураПараметровРедактораКода") Тогда
		НовыеРеквизиты.Добавить(Новый РеквизитФормы("конс_СтруктураПараметровРедактораКода", Новый ОписаниеТипов)); // Произвольный тип
	КонецЕсли;
	
	Если НовыеРеквизиты.Количество() > 0 Тогда
		Форма.ИзменитьРеквизиты(НовыеРеквизиты);
	КонецЕсли;
	
	// Получаем путь к данным элемента ПолеHTML (должен быть привязан к реквизиту формы пользователем)
	Элемент = Форма.Элементы.Найти(ИмяПоляHTML);
	ПутьКДанным = "";
	Если Элемент <> Неопределено И ЗначениеЗаполнено(Элемент.ПутьКДанным) Тогда
		ПутьКДанным = Элемент.ПутьКДанным;
	КонецЕсли;
	
	// Инициализируем структуру параметров со всеми необходимыми полями
	Форма.конс_СтруктураПараметровРедактораКода = Новый Структура;
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("ИмяПоляHTML", ИмяПоляHTML);
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("ПутьКДаннымПоляHTML", ПутьКДанным);
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("ВерсияОбработки", "");
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("ИсходникиЗагружены", Ложь);
	// Адреса временного хранилища
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("АдресМакета", "");
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("АдресОбщихМодулей", "");
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("АдресНастроек", "");
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("АдресХраненияПеременных", "");
	// JSON-данные
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("JSONПеременных", "");
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("JSONФункций", "");
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("JSONСниппетов", "");
	// Адрес значений переменных для контекста отладчика (хранятся во ВременномХранилище)
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("АдресЗначенийПеременных", "");
	// Отладка
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("АдресВМ", "");
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("АдресПеременных", "");
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("СоответствиеНомеровСтрок", Новый Соответствие);
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("ОстановкаПоОшибке", Ложь);
	// Описания переменных для подсказки контекста (Соответствие: ИмяПеременной → Структура("Тип, Описание"))
	Форма.конс_СтруктураПараметровРедактораКода.Вставить("ОписанияПеременных", Новый Соответствие);
	
КонецПроцедуры

// Проверяет наличие реквизита формы.
Функция ЕстьРеквизит(Форма, ИмяРеквизита)
	
	Попытка
		Значение = Форма[ИмяРеквизита];
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Нормализует параметры инициализации.
// Преобразует строку или элемент формы в структуру с ключом ИмяПоляHTML.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с полем HTML
//   ПараметрыИнициализации - Строка, ЭлементФормы, Структура, Неопределено - параметры инициализации
//
// Возвращаемое значение:
//   Структура - нормализованные параметры с ключом ИмяПоляHTML
//
Функция НормализоватьПараметрыИнициализации(Форма, ПараметрыИнициализации)
	
	Если ПараметрыИнициализации = Неопределено Тогда
		Возврат Новый Структура;
	КонецЕсли;
	
	Если ТипЗнч(ПараметрыИнициализации) = Тип("Структура") Тогда
		Возврат ПараметрыИнициализации;
	КонецЕсли;
	
	Если ТипЗнч(ПараметрыИнициализации) = Тип("Строка") Тогда
		Возврат Новый Структура("ИмяПоляHTML", ПараметрыИнициализации);
	КонецЕсли;
	
	// Передан элемент формы - извлекаем его имя
	Попытка
		ИмяЭлемента = ПараметрыИнициализации.Имя;
		Возврат Новый Структура("ИмяПоляHTML", ИмяЭлемента);
	Исключение
		// Не удалось получить имя - возвращаем пустую структуру
		Возврат Новый Структура;
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область РаботаСНастройками

// Получает все настройки редактора кода для текущего пользователя.
// 
// Возвращаемое значение:
//   Структура - Настройки редактора:
//     * Тема - Строка - название темы ("СветлаяТема", "ТёмнаяТема" и т.д.)
//     * БыстрыеПодсказки - Булево - включены ли быстрые подсказки
//     * КартаКода - Булево - отображать ли карту кода
//     * ПробелыИТабуляции - Булево - отображать ли пробелы и табуляции
//     * СтрокаСостояния - Булево - отображать ли строку состояния
//     * ПутьКИсходникамКонфигурации - Строка - путь к каталогу с исходниками
//     * ПутьКШаблонамКода - Строка - путь к файлу шаблонов
//     * ПоказыватьПеременные - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим показа переменных
//     * СохранятьКодПриВыполнении - Булево - сохранять ли код при выполнении
//
Функция ПолучитьНастройкиИзХранилища() Экспорт
	
	Настройки = НастройкиПоУмолчанию();
	
	Попытка
		СохраненныеНастройки = ХранилищеОбщихНастроек.Загрузить("конс_ПодключаемаяКонсольКода", "НастройкиРедактора");
		
		Если ТипЗнч(СохраненныеНастройки) = Тип("Структура") Тогда
			Для Каждого КлючЗначение Из СохраненныеНастройки Цикл
				Если Настройки.Свойство(КлючЗначение.Ключ) Тогда
					Настройки.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Исключение
		// Используем настройки по умолчанию
	КонецПопытки;
	
	Возврат Настройки;
	
КонецФункции

// Сохраняет настройки редактора кода для текущего пользователя.
// 
// Параметры:
//   Настройки - Структура - Структура с настройками редактора (см. ПолучитьНастройкиИзХранилища)
//
Процедура СохранитьНастройкиВХранилище(Настройки) Экспорт
	
	Попытка
		ХранилищеОбщихНастроек.Сохранить("конс_ПодключаемаяКонсольКода", "НастройкиРедактора", Настройки);
	Исключение
		ВызватьИсключение "Не удалось сохранить настройки редактора: " + ОписаниеОшибки();
	КонецПопытки;
	
КонецПроцедуры

// Возвращает настройки редактора по умолчанию.
// 
// Возвращаемое значение:
//   Структура - Настройки по умолчанию
//
Функция НастройкиПоУмолчанию() Экспорт
	
	Настройки = Новый Структура;
	Настройки.Вставить("Тема", "СветлаяТема");
	Настройки.Вставить("БыстрыеПодсказки", Истина);
	Настройки.Вставить("КартаКода", Истина);
	Настройки.Вставить("ПробелыИТабуляции", Ложь);
	Настройки.Вставить("СтрокаСостояния", Истина);
	Настройки.Вставить("ПутьКИсходникамКонфигурации", "");
	Настройки.Вставить("ПутьКШаблонамКода", "");
	Настройки.Вставить("ПоказыватьПеременные", Перечисления.конс_РежимПоказаПеременных.ВТабло);
	Настройки.Вставить("СохранятьКодПриВыполнении", Ложь);
	Настройки.Вставить("ЯзыкПодсказок", "ru");
	Настройки.Вставить("ОтключитьВстроенныеСниппеты", Ложь);
	Возврат Настройки;
	
КонецФункции

#КонецОбласти

#Область РаботаСМетаданными

// Возвращает описание коллекции общих модулей для автодополнения.
// 
// Возвращаемое значение:
//   Массив - Массив структур с описанием модулей:
//     * Имя - Строка
//     * Синоним - Строка
//     * Контекст - Строка ("Клиент", "Сервер", "ВызовСервера")
//
Функция ПолучитьКоллекциюОбщихМодулей() Экспорт
	
	// Формат для bsl_console: Структура, где ключ - имя модуля, значение - пустая структура
	КоллекцияМодулей = Новый Структура;
	
	Для Каждого ОбщийМодуль Из Метаданные.ОбщиеМодули Цикл
		// Добавляем только неглобальные модули (глобальные вызываются без имени модуля)
		Если Не ОбщийМодуль.Глобальный Тогда
			КоллекцияМодулей.Вставить(ОбщийМодуль.Имя, Новый Структура);
		КонецЕсли;
	КонецЦикла;
	
	Возврат КоллекцияМодулей;
	
КонецФункции

// Возвращает список коллекций метаданных для автодополнения.
// 
// Возвращаемое значение:
//   Структура - Описание метаданных для редактора:
//     * Справочники - Массив
//     * Документы - Массив
//     * Регистры - Массив
//     и т.д.
//
Функция ПолучитьМетаданныеДляРедактора() Экспорт
	
	РезультатМетаданных = Новый Структура;
	
	// Справочники
	Справочники = Новый Массив;
	Для Каждого Справочник Из Метаданные.Справочники Цикл
		Справочники.Добавить(Новый Структура("Имя, Синоним", Справочник.Имя, Справочник.Синоним));
	КонецЦикла;
	РезультатМетаданных.Вставить("Справочники", Справочники);
	
	// Документы
	Документы = Новый Массив;
	Для Каждого Документ Из Метаданные.Документы Цикл
		Документы.Добавить(Новый Структура("Имя, Синоним", Документ.Имя, Документ.Синоним));
	КонецЦикла;
	РезультатМетаданных.Вставить("Документы", Документы);
	
	// Перечисления
	Перечисления = Новый Массив;
	Для Каждого Перечисление Из Метаданные.Перечисления Цикл
		ЗначенияПеречисления = Новый Массив;
		Для Каждого ЗначениеПеречисления Из Перечисление.ЗначенияПеречисления Цикл
			ЗначенияПеречисления.Добавить(ЗначениеПеречисления.Имя);
		КонецЦикла;
		Перечисления.Добавить(Новый Структура("Имя, Синоним, Значения",
			Перечисление.Имя, Перечисление.Синоним, ЗначенияПеречисления));
	КонецЦикла;
	РезультатМетаданных.Вставить("Перечисления", Перечисления);
	
	// Регистры сведений
	РегистрыСведений = Новый Массив;
	Для Каждого РегистрСведений Из Метаданные.РегистрыСведений Цикл
		РегистрыСведений.Добавить(Новый Структура("Имя, Синоним", РегистрСведений.Имя, РегистрСведений.Синоним));
	КонецЦикла;
	РезультатМетаданных.Вставить("РегистрыСведений", РегистрыСведений);
	
	// Регистры накопления
	РегистрыНакопления = Новый Массив;
	Для Каждого РегистрНакопления Из Метаданные.РегистрыНакопления Цикл
		РегистрыНакопления.Добавить(Новый Структура("Имя, Синоним", РегистрНакопления.Имя, РегистрНакопления.Синоним));
	КонецЦикла;
	РезультатМетаданных.Вставить("РегистрыНакопления", РегистрыНакопления);
	
	Возврат РезультатМетаданных;
	
КонецФункции

// Получает данные метаданных по запросу для контекстной подсказки.
// 
// Параметры:
//   ПараметрыЗапроса - Строка - строка запроса метаданных (например, "справочники", "справочники.номенклатура")
//
// Возвращаемое значение:
//   Структура, Неопределено - результат запроса:
//     * Данные - Строка - JSON с данными метаданных
//     * АдресОбновления - Строка - адрес для обновления в редакторе
//
Функция ПолучитьДанныеМетаданныхПоЗапросу(ПараметрыЗапроса) Экспорт
	
	Если СтрНайти(ПараметрыЗапроса, ".") > 0 Тогда
		
		ЧастиЗапроса = СтрРазделить(ПараметрыЗапроса, ".");
		
		Если ЧастиЗапроса[0] = "module" Тогда
			// Запрос структуры модуля
			Если ЧастиЗапроса.Количество() = 2 Тогда
				Возврат ПолучитьСтруктуруОбщегоМодуля(ЧастиЗапроса[1]);
			Иначе
				// Модуль менеджера или объекта - требует более сложной логики
				Возврат Неопределено;
			КонецЕсли;
		Иначе
			// Запрос конкретного объекта метаданных (например, справочники.номенклатура)
			Возврат ПолучитьОписаниеОбъектаМетаданных(ПараметрыЗапроса);
		КонецЕсли;
		
	Иначе
		// Запрос списка объектов коллекции (например, справочники)
		Возврат ПолучитьСписокОбъектовМетаданных(ПараметрыЗапроса);
	КонецЕсли;
	
КонецФункции

// Получает список объектов определённой коллекции метаданных.
Функция ПолучитьСписокОбъектовМетаданных(ИмяКоллекции)
	
	// Получаем имя коллекции для редактора
	ИмяКоллекцииДляРедактора = ПолучитьИмяКоллекцииДляРедактора(ИмяКоллекции);
	
	Если Не ЗначениеЗаполнено(ИмяКоллекцииДляРедактора) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем правильное имя свойства метаданных
	ИмяСвойстваМетаданных = ПолучитьИмяСвойстваМетаданных(ИмяКоллекции);
	
	Если Не ЗначениеЗаполнено(ИмяСвойстваМетаданных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем коллекцию через прямой доступ
	Попытка
		Коллекция = Метаданные[ИмяСвойстваМетаданных];
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если Коллекция = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Формируем структуру с именами объектов (как в референсе)
	СписокОбъектов = Новый Структура;
	
	Для НомерОбъекта = 0 По Коллекция.Количество() - 1 Цикл
		ОбъектМетаданных = Коллекция.Получить(НомерОбъекта);
		СписокОбъектов.Вставить(ОбъектМетаданных.Имя, Новый Структура);
	КонецЦикла;
	
	// Формируем JSON
	Файл = Новый ЗаписьJSON;
	Файл.УстановитьСтроку();
	ЗаписатьJSON(Файл, СписокОбъектов);
	ДанныеJSON = Файл.Закрыть();
	
	// Определяем адрес обновления
	АдресОбновления = ИмяКоллекцииДляРедактора + ".items";
	
	Возврат Новый Структура("Данные, АдресОбновления", ДанныеJSON, АдресОбновления);
	
КонецФункции

// Получает описание конкретного объекта метаданных.
Функция ПолучитьОписаниеОбъектаМетаданных(ПолноеИмя)
	
	Части = СтрРазделить(ПолноеИмя, ".");
	
	Если Части.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИмяКоллекции = Части[0];
	ИмяОбъекта = Части[1];
	
	// Получаем имя коллекции для редактора
	ИмяКоллекцииДляРедактора = ПолучитьИмяКоллекцииДляРедактора(ИмяКоллекции);
	
	Если Не ЗначениеЗаполнено(ИмяКоллекцииДляРедактора) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем правильное имя свойства метаданных
	ИмяСвойстваМетаданных = ПолучитьИмяСвойстваМетаданных(ИмяКоллекции);
	
	Если Не ЗначениеЗаполнено(ИмяСвойстваМетаданных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем объект метаданных через прямой доступ
	Попытка
		ОбъектМетаданных = Метаданные[ИмяСвойстваМетаданных].Найти(ИмяОбъекта);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МетаПолноеИмя = ОбъектМетаданных.ПолноеИмя();
	
	// Собираем структуру объекта
	СтруктураОбъекта = Новый Структура;
	ЗаполнитьСтруктуруОбъектаМетаданных(СтруктураОбъекта, ОбъектМетаданных, МетаПолноеИмя);
	
	// Формируем JSON
	Файл = Новый ЗаписьJSON;
	Файл.УстановитьСтроку();
	ЗаписатьJSON(Файл, СтруктураОбъекта);
	ДанныеJSON = Файл.Закрыть();
	
	// Определяем адрес обновления
	АдресОбновления = ИмяКоллекцииДляРедактора + ".items." + ОбъектМетаданных.Имя;
	
	Возврат Новый Структура("Данные, АдресОбновления", ДанныеJSON, АдресОбновления);
	
КонецФункции

// Заполняет структуру объекта метаданных для автодополнения.
Процедура ЗаполнитьСтруктуруОбъектаМетаданных(СтруктураОбъекта, ОбъектМетаданных, ПолноеИмя)
	
	Связи = Новый Соответствие;
	ОписаниеРеквизитов = Новый Структура;
	ОписаниеРесурсов = Новый Структура;
	ОписаниеПредопределенных = Новый Структура;
	ОписаниеТабличныхЧастей = Новый Структура;
	ДополнительныеСвойства = Новый Структура;
	
	// Проверяем тип метаданных - для перечислений особая обработка
	Если ИмяМетаданных(ПолноеИмя) = "Перечисление" Тогда
		// Заполняем значения перечисления
		ЗаполнитьОписаниеЗначенийПеречисления(ОбъектМетаданных, ОписаниеРеквизитов);
	Иначе
		// Стандартные реквизиты
		Попытка
			Для Каждого Реквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
				ДобавитьОписаниеРеквизита(ОписаниеРеквизитов, Реквизит, Связи);
			КонецЦикла;
		Исключение
			// Нет стандартных реквизитов
		КонецПопытки;
		
		// Реквизиты объекта
		Попытка
			Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
				ДобавитьОписаниеРеквизита(ОписаниеРеквизитов, Реквизит, Связи);
			КонецЦикла;
		Исключение
			// Нет реквизитов
		КонецПопытки;
		
		// Измерения и ресурсы (для регистров)
		ЗаполнитьОписаниеИзмеренийРесурсов(ОбъектМетаданных, ПолноеИмя, ОписаниеРеквизитов,
			ОписаниеРесурсов, ДополнительныеСвойства, Связи);
		
		// Табличные части
		ЗаполнитьОписаниеТабличныхЧастей(ОбъектМетаданных, ПолноеИмя, ОписаниеРеквизитов,
			ОписаниеТабличныхЧастей, Связи);
		
		// Предопределенные элементы
		ЗаполнитьОписаниеПредопределенных(ОбъектМетаданных, ПолноеИмя, ОписаниеПредопределенных);
	КонецЕсли;
	
	// Формируем итоговую структуру
	СтруктураОбъекта.Вставить("properties", ОписаниеРеквизитов);
	
	Для Каждого Обход Из ДополнительныеСвойства Цикл
		СтруктураОбъекта.Вставить(Обход.Ключ, Обход.Значение);
	КонецЦикла;
	
	Если ОписаниеРесурсов.Количество() > 0 Тогда
		СтруктураОбъекта.Вставить("resources", ОписаниеРесурсов);
	КонецЕсли;
	
	Если ОписаниеПредопределенных.Количество() > 0 Тогда
		СтруктураОбъекта.Вставить("predefined", ОписаниеПредопределенных);
	КонецЕсли;
	
	Если ОписаниеТабличныхЧастей.Количество() > 0 Тогда
		СтруктураОбъекта.Вставить("tabulars", ОписаниеТабличныхЧастей);
	КонецЕсли;
	
КонецПроцедуры

// Добавляет описание реквизита в структуру.
Процедура ДобавитьОписаниеРеквизита(ОписаниеРеквизитов, Реквизит, Связи)
	
	Связь = ПолучитьСвязьСОбъектомМетаданных(Реквизит, Связи);
	
	ОписаниеРеквизита = Новый Структура("name", Реквизит.Синоним);
	
	Если ЗначениеЗаполнено(Связь) Тогда
		ОписаниеРеквизита.Вставить("ref", Связь);
	КонецЕсли;
	
	ОписаниеРеквизитов.Вставить(Реквизит.Имя, ОписаниеРеквизита);
	
КонецПроцедуры

// Получает связь реквизита с объектом метаданных для навигации.
Функция ПолучитьСвязьСОбъектомМетаданных(Реквизит, Связи)
	
	Связь = "";
	Типы = Реквизит.Тип.Типы();
	Индекс = 0;
	
	Пока Индекс < Типы.Количество() И Не ЗначениеЗаполнено(Связь) Цикл
		
		Тип = Типы[Индекс];
		СвязьТипа = Связи[Тип];
		
		Если СвязьТипа = Неопределено Тогда
			
			ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
			
			Если ОбъектМетаданных <> Неопределено Тогда
				
				Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
					Связь = "catalogs." + ОбъектМетаданных.Имя;
				ИначеЕсли Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
					Связь = "documents." + ОбъектМетаданных.Имя;
				Иначе
					Связь = "";
				КонецЕсли;
				
			КонецЕсли;
			
			Связи[Тип] = Связь;
			
		Иначе
			Связь = СвязьТипа;
		КонецЕсли;
		
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
	Возврат Связь;
	
КонецФункции

// Заполняет описание значений перечисления.
Процедура ЗаполнитьОписаниеЗначенийПеречисления(ОбъектМетаданных, ОписаниеРеквизитов)
	
	Для НомерРеквизита = 0 По ОбъектМетаданных.ЗначенияПеречисления.Количество() - 1 Цикл
		Реквизит = ОбъектМетаданных.ЗначенияПеречисления.Получить(НомерРеквизита);
		ОписаниеРеквизитов.Вставить(Реквизит.Имя, Новый Структура("name", Реквизит.Синоним));
	КонецЦикла;
	
КонецПроцедуры

// Возвращает имя типа метаданных по полному имени.
Функция ИмяМетаданных(ПолноеИмя)
	
	Части = СтрРазделить(ПолноеИмя, ".");
	Возврат Части[0];
	
КонецФункции

// Проверяет наличие табличных частей у объекта метаданных.
Функция ОбъектМетаданныхИмеетТЧ(ПолноеИмя)
	
	ИмяТипа = ИмяМетаданных(ПолноеИмя);
	
	Возврат ИмяТипа = "Справочник"
		Или ИмяТипа = "Документ"
		Или ИмяТипа = "ПланВидовХарактеристик"
		Или ИмяТипа = "ПланСчетов"
		Или ИмяТипа = "ПланВидовРасчета"
		Или ИмяТипа = "БизнесПроцесс"
		Или ИмяТипа = "Задача"
		Или ИмяТипа = "ПланОбмена";
	
КонецФункции

// Проверяет наличие измерений у объекта метаданных.
Функция ОбъектМетаданныхИмеетИзмерения(ПолноеИмя)
	
	ИмяТипа = ИмяМетаданных(ПолноеИмя);
	
	Возврат ИмяТипа = "РегистрСведений"
		Или ИмяТипа = "РегистрНакопления"
		Или ИмяТипа = "РегистрБухгалтерии"
		Или ИмяТипа = "РегистрРасчета";
	
КонецФункции

// Проверяет наличие предопределенных элементов.
Функция ОбъектМетаданныхИмеетПредопределенные(ПолноеИмя)
	
	ИмяТипа = ИмяМетаданных(ПолноеИмя);
	
	Возврат ИмяТипа = "Справочник"
		Или ИмяТипа = "ПланВидовХарактеристик"
		Или ИмяТипа = "ПланСчетов"
		Или ИмяТипа = "ПланВидовРасчета";
	
КонецФункции

// Заполняет описание измерений и ресурсов регистра.
Процедура ЗаполнитьОписаниеИзмеренийРесурсов(ОбъектМетаданных, ПолноеИмя, ОписаниеРеквизитов,
	ОписаниеРесурсов, ДополнительныеСвойства, Связи)
	
	Если Не ОбъектМетаданныхИмеетИзмерения(ПолноеИмя) Тогда
		Возврат;
	КонецЕсли;
	
	Для НомерРеквизита = 0 По ОбъектМетаданных.Измерения.Количество() - 1 Цикл
		Реквизит = ОбъектМетаданных.Измерения.Получить(НомерРеквизита);
		ДобавитьОписаниеРеквизита(ОписаниеРеквизитов, Реквизит, Связи);
	КонецЦикла;
	
	Для НомерРеквизита = 0 По ОбъектМетаданных.Ресурсы.Количество() - 1 Цикл
		Реквизит = ОбъектМетаданных.Ресурсы.Получить(НомерРеквизита);
		ДобавитьОписаниеРеквизита(ОписаниеРесурсов, Реквизит, Связи);
	КонецЦикла;
	
	// Тип регистра
	ТипРегистра = "";
	
	Если ИмяМетаданных(ПолноеИмя) = "РегистрСведений" Тогда
		
		Непериодический = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
		
		Если ОбъектМетаданных.ПериодичностьРегистраСведений = Непериодический Тогда
			ТипРегистра = "nonperiodical";
		Иначе
			ТипРегистра = "periodical";
		КонецЕсли;
		
	ИначеЕсли ИмяМетаданных(ПолноеИмя) = "РегистрНакопления" Тогда
		
		Если ОбъектМетаданных.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			ТипРегистра = "balance";
		Иначе
			ТипРегистра = "turnovers";
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТипРегистра) Тогда
		ДополнительныеСвойства.Вставить("type", ТипРегистра);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет описание табличных частей.
Процедура ЗаполнитьОписаниеТабличныхЧастей(ОбъектМетаданных, ПолноеИмя,
	ОписаниеРеквизитов, ОписаниеТабличныхЧастей, Связи)
	
	Если Не ОбъектМетаданныхИмеетТЧ(ПолноеИмя) Тогда
		Возврат;
	КонецЕсли;
	
	Для НомерРеквизита = 0 По ОбъектМетаданных.ТабличныеЧасти.Количество() - 1 Цикл
		
		ТабличнаяЧасть = ОбъектМетаданных.ТабличныеЧасти.Получить(НомерРеквизита);
		ОписаниеРеквизитов.Вставить(ТабличнаяЧасть.Имя, Новый Структура("name", "ТЧ: " + ТабличнаяЧасть.Синоним));
		
		ОписаниеТабличнойЧасти = Новый Структура;
		
		Для Каждого РеквизитТЧ Из ТабличнаяЧасть.СтандартныеРеквизиты Цикл
			ОписаниеТабличнойЧасти.Вставить(РеквизитТЧ.Имя, РеквизитТЧ.Синоним);
		КонецЦикла;
		
		Для НомерРеквизитаТЧ = 0 По ТабличнаяЧасть.Реквизиты.Количество() - 1 Цикл
			РеквизитТЧ = ТабличнаяЧасть.Реквизиты.Получить(НомерРеквизитаТЧ);
			ДобавитьОписаниеРеквизита(ОписаниеТабличнойЧасти, РеквизитТЧ, Связи);
		КонецЦикла;
		
		СтруктураТабличнойЧасти = Новый Структура;
		СтруктураТабличнойЧасти.Вставить("properties", ОписаниеТабличнойЧасти);
		
		Если ОписаниеТабличнойЧасти.Количество() > 0 Тогда
			ОписаниеТабличныхЧастей.Вставить(ТабличнаяЧасть.Имя, СтруктураТабличнойЧасти);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет описание предопределенных элементов.
Процедура ЗаполнитьОписаниеПредопределенных(ОбъектМетаданных, ПолноеИмя, ОписаниеПредопределенных)
	
	Если Не ОбъектМетаданныхИмеетПредопределенные(ПолноеИмя) Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		Предопределенные = ОбъектМетаданных.ПолучитьИменаПредопределенных();
		
		Для Каждого Имя Из Предопределенные Цикл
			ОписаниеПредопределенных.Вставить(Имя, "");
		КонецЦикла;
	Исключение
		// Нет предопределенных
	КонецПопытки;
	
КонецПроцедуры

// Получает структуру общего модуля для автодополнения.
Функция ПолучитьСтруктуруОбщегоМодуля(ИмяМодуля)
	
	// Находим модуль
	МодульМетаданных = Неопределено;
	
	Для Каждого ОбщийМодуль Из Метаданные.ОбщиеМодули Цикл
		Если НРег(ОбщийМодуль.Имя) = НРег(ИмяМодуля) Тогда
			МодульМетаданных = ОбщийМодуль;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если МодульМетаданных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем экспортные методы модуля (базовая информация)
	СтруктураМодуля = Новый Структура;
	СтруктураМодуля.Вставить("name", МодульМетаданных.Имя);
	СтруктураМодуля.Вставить("description", МодульМетаданных.Синоним);
	
	// Для полного анализа требуется парсинг текста модуля
	// Пока возвращаем базовую структуру
	
	// Формируем JSON
	Файл = Новый ЗаписьJSON;
	Файл.УстановитьСтроку();
	ЗаписатьJSON(Файл, СтруктураМодуля);
	ДанныеJSON = Файл.Закрыть();
	
	АдресОбновления = "module." + МодульМетаданных.Имя;
	
	Возврат Новый Структура("Данные, АдресОбновления", ДанныеJSON, АдресОбновления);
	
КонецФункции

// Получает информацию об общем модуле для загрузки из исходников.
// 
// Параметры:
//   ИмяМодуля - Строка - имя модуля
//
// Возвращаемое значение:
//   Структура, Неопределено - информация о модуле:
//     * ИмяВКонфигураторе - Строка - точное имя модуля в конфигураторе
//     * Глобальный - Булево - является ли модуль глобальным
//
Функция ПолучитьИнформациюОбщегоМодуля(ИмяМодуля) Экспорт
	
	// Находим модуль по имени (без учета регистра)
	Для Каждого ОбщийМодуль Из Метаданные.ОбщиеМодули Цикл
		Если НРег(ОбщийМодуль.Имя) = НРег(ИмяМодуля) Тогда
			Возврат Новый Структура("ИмяВКонфигураторе, Глобальный",
				ОбщийМодуль.Имя,
				ОбщийМодуль.Глобальный);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Получает информацию об объекте метаданных для загрузки модуля из исходников.
// 
// Параметры:
//   КоллекцияМетаданных - Строка - имя коллекции (обработки, справочники и т.д.)
//   ИмяОбъекта - Строка - имя объекта метаданных
//
// Возвращаемое значение:
//   Структура, Неопределено - информация об объекте:
//     * ИмяКаталога - Строка - имя каталога в выгрузке (DataProcessors, Catalogs и т.д.)
//     * ИмяОбъектаВКонфигураторе - Строка - точное имя объекта в конфигураторе
//     * ИмяКоллекцииРедактора - Строка - имя коллекции для редактора (dataProc, catalogs и т.д.)
//
Функция ПолучитьИнформациюОбъектаМетаданных(КоллекцияМетаданных, ИмяОбъекта) Экспорт
	
	Маппинг = ПолучитьМаппингКоллекцийМетаданных();
	
	// Определяем коллекцию метаданных
	ИмяКоллекцииМетаданных = Маппинг.СвойстваМетаданных.Получить(НРег(КоллекцияМетаданных));
	Если ИмяКоллекцииМетаданных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем коллекцию из метаданных
	Попытка
		Коллекция = Метаданные[ИмяКоллекцииМетаданных];
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	// Ищем объект в коллекции (без учета регистра)
	ОбъектМетаданных = Неопределено;
	Для Каждого Элемент Из Коллекция Цикл
		Если НРег(Элемент.Имя) = НРег(ИмяОбъекта) Тогда
			ОбъектМетаданных = Элемент;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Формируем результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяКаталога", Маппинг.ИменаКаталогов.Получить(ИмяКоллекцииМетаданных));
	Результат.Вставить("ИмяОбъектаВКонфигураторе", ОбъектМетаданных.Имя);
	Результат.Вставить("ИмяКоллекцииРедактора", ПолучитьИмяКоллекцииДляРедактора(КоллекцияМетаданных));
	
	Возврат Результат;
	
КонецФункции

// Читает текст общего модуля из файла исходников.
// 
// Параметры:
//   КаталогИсходногоКода - Строка - путь к каталогу с исходниками
//   ИмяМодуля - Строка - имя модуля
//
// Возвращаемое значение:
//   Структура, Неопределено - данные модуля
//
Функция ПрочитатьТекстОбщегоМодуля(КаталогИсходногоКода, ИмяМодуля) Экспорт
	
	// Получаем информацию о модуле
	ИнформацияМодуля = ПолучитьИнформациюОбщегоМодуля(ИмяМодуля);
	Если ИнформацияМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Нормализуем путь
	КаталогИсходногоКода = НормализоватьПутьКИсходникам(КаталогИсходногоКода);
	
	// Формируем путь к файлу модуля
	РазделительПути = ПолучитьРазделительПути();
	ФайлМодуля = СтрШаблон("%1CommonModules%2%3%2Ext%2Module.bsl",
		КаталогИсходногоКода, РазделительПути, ИнформацияМодуля.ИмяВКонфигураторе);
	
	// Читаем текст модуля
	ТекстМодуля = ПрочитатьТекстФайла(ФайлМодуля);
	Если ТекстМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("ИмяМодуля", ИнформацияМодуля.ИмяВКонфигураторе);
	Результат.Вставить("ТекстМодуля", ТекстМодуля);
	Результат.Вставить("Глобальный", ИнформацияМодуля.Глобальный);
	
	Возврат Результат;
	
КонецФункции

// Читает текст модуля объекта (менеджера или объекта) из файла исходников.
// 
// Параметры:
//   КаталогИсходногоКода - Строка - путь к каталогу с исходниками
//   ТипМодуля - Строка - "manager" или "object"
//   КоллекцияМетаданных - Строка - имя коллекции
//   ИмяОбъекта - Строка - имя объекта метаданных
//
// Возвращаемое значение:
//   Структура, Неопределено - данные модуля
//
Функция ПрочитатьТекстМодуляОбъекта(КаталогИсходногоКода, ТипМодуля, КоллекцияМетаданных, ИмяОбъекта) Экспорт
	
	// Получаем информацию об объекте
	ИнформацияОбъекта = ПолучитьИнформациюОбъектаМетаданных(КоллекцияМетаданных, ИмяОбъекта);
	Если ИнформацияОбъекта = Неопределено Тогда

		Возврат Неопределено;
	КонецЕсли;
	
	// Нормализуем путь
	КаталогИсходногоКода = НормализоватьПутьКИсходникам(КаталогИсходногоКода);
	
	// Определяем имя файла модуля
	ИмяФайлаМодуля = ?(НРег(ТипМодуля) = "manager", "ManagerModule", "ObjectModule");
	
	// Формируем путь к файлу модуля
	РазделительПути = ПолучитьРазделительПути();
	ФайлМодуля = СтрШаблон("%1%2%3%4%3Ext%3%5.bsl",
		КаталогИсходногоКода,
		ИнформацияОбъекта.ИмяКаталога,
		РазделительПути,
		ИнформацияОбъекта.ИмяОбъектаВКонфигураторе,
		ИмяФайлаМодуля);
	
	// Читаем текст модуля
	ТекстМодуля = ПрочитатьТекстФайла(ФайлМодуля);
	Если ТекстМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Формируем адрес загрузки для parseMetadataModule
	АдресЗагрузки = СтрШаблон("%1.items.%2.%3",
		ИнформацияОбъекта.ИмяКоллекцииРедактора,
		ИнформацияОбъекта.ИмяОбъектаВКонфигураторе,
		НРег(ТипМодуля));

	Результат = Новый Структура;
	Результат.Вставить("ТекстМодуля", ТекстМодуля);
	Результат.Вставить("АдресЗагрузки", АдресЗагрузки);
	
	Возврат Результат;
	
КонецФункции

// Нормализует путь к исходникам (добавляет разделитель в конце).
Функция НормализоватьПутьКИсходникам(Путь)
	
	Путь = СокрЛП(Путь);
	РазделительПути = ПолучитьРазделительПути();
	
	Если Прав(Путь, 1) <> РазделительПути Тогда
		Путь = Путь + РазделительПути;
	КонецЕсли;
	
	Возврат Путь;
	
КонецФункции

// Читает текст из файла.
Функция ПрочитатьТекстФайла(ПутьКФайлу)
	
	Файл = Новый Файл(ПутьКФайлу);
	Если Не Файл.Существует() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Текст = Новый ТекстовыйДокумент();
		Текст.Прочитать(ПутьКФайлу, КодировкаТекста.UTF8);
		Возврат Текст.ПолучитьТекст();
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

// Возвращает единый маппинг коллекций метаданных.
// Содержит все соответствия для работы с метаданными.
//
// Возвращаемое значение:
//   Структура:
//     * СвойстваМетаданных - Соответствие - имена свойств Метаданные.ХХХ
//     * ИменаРедактора - Соответствие - имена для редактора (bsl_console)
//     * ИменаКаталогов - Соответствие - имена каталогов выгрузки
//
Функция ПолучитьМаппингКоллекцийМетаданных()
	
	// Свойства Метаданные.XXX
	СвойстваМетаданных = Новый Соответствие;
	// Имена для редактора (bsl_console)
	ИменаРедактора = Новый Соответствие;
	// Имена каталогов выгрузки
	ИменаКаталогов = Новый Соответствие;
	
	// Справочники
	СвойстваМетаданных.Вставить("справочники", "Справочники");
	СвойстваМетаданных.Вставить("catalogs", "Справочники");
	ИменаРедактора.Вставить("справочники", "catalogs");
	ИменаРедактора.Вставить("catalogs", "catalogs");
	ИменаКаталогов.Вставить("Справочники", "Catalogs");
	
	// Документы
	СвойстваМетаданных.Вставить("документы", "Документы");
	СвойстваМетаданных.Вставить("documents", "Документы");
	ИменаРедактора.Вставить("документы", "documents");
	ИменаРедактора.Вставить("documents", "documents");
	ИменаКаталогов.Вставить("Документы", "Documents");
	
	// Перечисления
	СвойстваМетаданных.Вставить("перечисления", "Перечисления");
	СвойстваМетаданных.Вставить("enums", "Перечисления");
	ИменаРедактора.Вставить("перечисления", "enums");
	ИменаРедактора.Вставить("enums", "enums");
	
	// Регистры сведений
	СвойстваМетаданных.Вставить("регистрысведений", "РегистрыСведений");
	СвойстваМетаданных.Вставить("informationregisters", "РегистрыСведений");
	ИменаРедактора.Вставить("регистрысведений", "infoRegs");
	ИменаРедактора.Вставить("informationregisters", "infoRegs");
	ИменаКаталогов.Вставить("РегистрыСведений", "InformationRegisters");
	
	// Регистры накопления
	СвойстваМетаданных.Вставить("регистрынакопления", "РегистрыНакопления");
	СвойстваМетаданных.Вставить("accumulationregisters", "РегистрыНакопления");
	ИменаРедактора.Вставить("регистрынакопления", "accumRegs");
	ИменаРедактора.Вставить("accumulationregisters", "accumRegs");
	ИменаКаталогов.Вставить("РегистрыНакопления", "AccumulationRegisters");
	
	// Обработки
	СвойстваМетаданных.Вставить("обработки", "Обработки");
	СвойстваМетаданных.Вставить("dataprocessors", "Обработки");
	ИменаРедактора.Вставить("обработки", "dataProc");
	ИменаРедактора.Вставить("dataprocessors", "dataProc");
	ИменаКаталогов.Вставить("Обработки", "DataProcessors");
	
	// Отчеты
	СвойстваМетаданных.Вставить("отчеты", "Отчеты");
	СвойстваМетаданных.Вставить("reports", "Отчеты");
	ИменаРедактора.Вставить("отчеты", "reports");
	ИменаРедактора.Вставить("reports", "reports");
	ИменаКаталогов.Вставить("Отчеты", "Reports");
	
	// Планы счетов
	СвойстваМетаданных.Вставить("планысчетов", "ПланыСчетов");
	СвойстваМетаданных.Вставить("chartsofaccounts", "ПланыСчетов");
	ИменаРедактора.Вставить("планысчетов", "сhartsOfAccounts");
	ИменаРедактора.Вставить("chartsofaccounts", "сhartsOfAccounts");
	
	// Планы видов характеристик
	СвойстваМетаданных.Вставить("планывидовхарактеристик", "ПланыВидовХарактеристик");
	СвойстваМетаданных.Вставить("chartsofcharacteristictypes", "ПланыВидовХарактеристик");
	ИменаРедактора.Вставить("планывидовхарактеристик", "chartsOfCharacteristicTypes");
	ИменаРедактора.Вставить("chartsofcharacteristictypes", "chartsOfCharacteristicTypes");
	ИменаКаталогов.Вставить("ПланыВидовХарактеристик", "ChartsOfCharacteristicTypes");
	
	// Планы видов расчета
	СвойстваМетаданных.Вставить("планывидоврасчета", "ПланыВидовРасчета");
	СвойстваМетаданных.Вставить("chartsofcalculationtypes", "ПланыВидовРасчета");
	ИменаРедактора.Вставить("планывидоврасчета", "chartsOfCalculationTypes");
	ИменаРедактора.Вставить("chartsofcalculationtypes", "chartsOfCalculationTypes");
	
	// Планы обмена
	СвойстваМетаданных.Вставить("планыобмена", "ПланыОбмена");
	СвойстваМетаданных.Вставить("exchangeplans", "ПланыОбмена");
	ИменаРедактора.Вставить("планыобмена", "exchangePlans");
	ИменаРедактора.Вставить("exchangeplans", "exchangePlans");
	ИменаКаталогов.Вставить("ПланыОбмена", "ExchangePlans");
	
	// Константы
	СвойстваМетаданных.Вставить("константы", "Константы");
	СвойстваМетаданных.Вставить("constants", "Константы");
	ИменаРедактора.Вставить("константы", "constants");
	ИменаРедактора.Вставить("constants", "constants");
	
	// Регистры бухгалтерии
	СвойстваМетаданных.Вставить("регистрыбухгалтерии", "РегистрыБухгалтерии");
	СвойстваМетаданных.Вставить("accountingregisters", "РегистрыБухгалтерии");
	ИменаРедактора.Вставить("регистрыбухгалтерии", "accountRegs");
	ИменаРедактора.Вставить("accountingregisters", "accountRegs");
	
	// Регистры расчета
	СвойстваМетаданных.Вставить("регистрырасчета", "РегистрыРасчета");
	СвойстваМетаданных.Вставить("calculationregisters", "РегистрыРасчета");
	ИменаРедактора.Вставить("регистрырасчета", "calcRegs");
	ИменаРедактора.Вставить("calculationregisters", "calcRegs");
	
	// Бизнес-процессы
	СвойстваМетаданных.Вставить("бизнеспроцессы", "БизнесПроцессы");
	СвойстваМетаданных.Вставить("businessprocesses", "БизнесПроцессы");
	ИменаРедактора.Вставить("бизнеспроцессы", "businessProcesses");
	ИменаРедактора.Вставить("businessprocesses", "businessProcesses");
	ИменаКаталогов.Вставить("БизнесПроцессы", "BusinessProcesses");
	
	// Задачи
	СвойстваМетаданных.Вставить("задачи", "Задачи");
	СвойстваМетаданных.Вставить("tasks", "Задачи");
	ИменаРедактора.Вставить("задачи", "tasks");
	ИменаРедактора.Вставить("tasks", "tasks");
	ИменаКаталогов.Вставить("Задачи", "Tasks");
	
	// Внешние источники данных
	СвойстваМетаданных.Вставить("внешниеисточникиданных", "ВнешниеИсточникиДанных");
	СвойстваМетаданных.Вставить("externaldatasources", "ВнешниеИсточникиДанных");
	ИменаРедактора.Вставить("внешниеисточникиданных", "externalDataSources");
	ИменаРедактора.Вставить("externaldatasources", "externalDataSources");
	
	Возврат Новый Структура("СвойстваМетаданных, ИменаРедактора, ИменаКаталогов",
		СвойстваМетаданных, ИменаРедактора, ИменаКаталогов);
	
КонецФункции

// Получает имя коллекции для редактора (в формате bsl_console).
Функция ПолучитьИмяКоллекцииДляРедактора(ИмяКоллекции)
	
	Маппинг = ПолучитьМаппингКоллекцийМетаданных();
	Результат = Маппинг.ИменаРедактора.Получить(НРег(ИмяКоллекции));
	
	Возврат ?(Результат = Неопределено, "", Результат);
	
КонецФункции

// Получает правильное имя свойства коллекции метаданных из строки в любом регистре.
Функция ПолучитьИмяСвойстваМетаданных(ИмяКоллекции)
	
	Маппинг = ПолучитьМаппингКоллекцийМетаданных();
	Возврат Маппинг.СвойстваМетаданных.Получить(НРег(ИмяКоллекции));
	
КонецФункции

#КонецОбласти

#Область ВыполнениеКода

// Выполняет код на сервере и возвращает результат.
// 
// Параметры:
//   Код - Строка - BSL-код для выполнения
//   РежимПоказаПеременных - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим отображения результатов
//
// Возвращаемое значение:
//   Структура - Результат выполнения:
//     * Успешно - Булево
//     * ОписаниеОшибки - Строка - текст ошибки (для обратной совместимости)
//     * ИнформацияОбОшибке - Структура, Неопределено - полная информация об ошибке:
//         ** Описание - Строка
//         ** НомерСтроки - Число
//         ** НомерКолонки - Число
//         ** ИмяМодуля - Строка
//         ** ИсходнаяСтрока - Строка
//         ** Причина - Структура, Неопределено
//     * ИсходнаяСтрока - Строка (устаревшее, используйте ИнформацияОбОшибке)
//     * ОписаниеПеременных - Строка (JSON)
//     * АдресХраненияПеременных - Строка
//
Функция ВыполнитьКодНаСервере(Код, РежимПоказаПеременных) Экспорт
	
	// Используем уникальные имена переменных, чтобы избежать конфликтов с пользовательским кодом
	// (Выполнить() разделяет область видимости локальных переменных с вызывающей процедурой)
	_конс_Результат_ = НовыйРезультатВыполнения();
	ЗначенияПеременных = Новый Структура;
	
	Попытка
		Выполнить(Код);
		_конс_Результат_.Успешно = Истина;
		
		_конс_АдресПеременных_ = "";
		Попытка
			_конс_Результат_.РежимПоказаПеременных = РежимПоказаПеременных;
			Если РежимПоказаПеременных = Перечисления.конс_РежимПоказаПеременных.ВТабло Тогда
				_конс_Результат_.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, _конс_АдресПеременных_);
			ИначеЕсли РежимПоказаПеременных = Перечисления.конс_РежимПоказаПеременных.ВПодсказках Тогда
				_конс_Результат_.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляПодсказок(ЗначенияПеременных);
			КонецЕсли;
			_конс_Результат_.АдресХраненияПеременных = _конс_АдресПеременных_;
		Исключение
			_конс_Результат_.ОписаниеПеременных = "";
		КонецПопытки;
		
	Исключение
		_конс_ИнфоОшибки_ = ИнформацияОбОшибке();
		
		// Полная информация об ошибке (новый формат)
		_конс_Результат_.ИнформацияОбОшибке = РазобратьИнформациюОбОшибкеСервер(_конс_ИнфоОшибки_);

	КонецПопытки;
	
	Возврат _конс_Результат_;
	
КонецФункции

// Возвращает структуру результата выполнения кода.
// 
// Возвращаемое значение:
//   Структура - Пустая структура результата
//
Функция НовыйРезультатВыполнения() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успешно", Ложь);
	Результат.Вставить("ИсходнаяСтрока", "");
	Результат.Вставить("ОписаниеОшибки", "");
	Результат.Вставить("ИнформацияОбОшибке", Неопределено);
	Результат.Вставить("ОписаниеПеременных", "");
	Результат.Вставить("АдресХраненияПеременных", "");
	Результат.Вставить("РежимПоказаПеременных", Перечисления.конс_РежимПоказаПеременных.НеОтображать);
	
	Возврат Результат;
	
КонецФункции

// Разбирает ИнформациюОбОшибке в структуру.
// 
// Параметры:
//   ИнфоОшибки - ИнформацияОбОшибке
//
// Возвращаемое значение:
//   Структура - Описание ошибки
//
Функция РазобратьИнформациюОбОшибкеСервер(ИнфоОшибки) Экспорт
	
	Если ИнфоОшибки = Неопределено Тогда
		Возврат НовоеОписаниеОшибки();
	КонецЕсли;
	
	// Получаем полный стек ошибки и парсим его с конца к началу
	ПолныйТекст = ПодробноеПредставлениеОшибки(ИнфоОшибки);
	
	Возврат РазобратьСтекОшибкиСервер(ПолныйТекст, ИнфоОшибки.Описание);
	
КонецФункции

// Разбирает стек ошибки из ПодробноеПредставлениеОшибки.
// Идёт с конца к началу, находит строку выполняемого кода {(номер)}.
// 
// Параметры:
//   ПолныйТекст - Строка - результат ПодробноеПредставлениеОшибки
//   ОписаниеОшибки - Строка - текст ошибки (первопричина, используется как fallback)
//
// Возвращаемое значение:
//   Структура - разобранная информация об ошибке
//
Функция РазобратьСтекОшибкиСервер(ПолныйТекст, ОписаниеОшибки)
	
	Результат = Новый Структура;
	Результат.Вставить("Описание", ОписаниеОшибки);
	Результат.Вставить("НомерСтроки", 0);
	Результат.Вставить("НомерКолонки", 1);
	Результат.Вставить("ЭтоВыполняемыйКод", Ложь);
	Результат.Вставить("ИмяМодуля", "");
	Результат.Вставить("ИсходнаяСтрока", "");
	Результат.Вставить("СтекВызовов", Новый Массив); // Внешние вызовы (причина)
	Результат.Вставить("Причина", Неопределено);
	Результат.Вставить("НомерСтрокиОригинала", 0);
	
	// Разбиваем на строки
	СтрокиСтека = СтрРазделить(ПолныйТекст, Символы.ПС, Ложь);
	
	// Ищем "по причине:" - это триггер для поиска вложенной ошибки
	ИндексПоПричине = -1;
	Для Индекс = 0 По СтрокиСтека.ВГраница() Цикл
		Если СтрНайти(НРег(СтрокиСтека[Индекс]), "по причине:") > 0 Тогда
			ИндексПоПричине = Индекс;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// Есть вложенная ошибка - ищем после "по причине:"
	Если ИндексПоПричине >= 0 Тогда
		// Ищем первую строку с {<...>(...)} после "по причине:"
		Для Индекс = ИндексПоПричине + 1 По СтрокиСтека.ВГраница() Цикл
			Строка = СтрокиСтека[Индекс];
			ТриммированнаяСтрока = СокрЛ(Строка);
			
			Если СтрНачинаетсяС(ТриммированнаяСтрока, "{<") Тогда
				// Извлекаем позицию из формата {<Модуль>(строка,колонка)}
				Позиция = ИзвлечьПозициюИзМодульнойОшибкиСервер(Строка);
				Результат.НомерСтроки = Позиция.НомерСтроки;
				Результат.НомерКолонки = Позиция.НомерКолонки;
				Результат.ИмяМодуля = Позиция.ИмяМодуля;
				Результат.ЭтоВыполняемыйКод = Истина;
				
				// Описание: от этой строки и далее до конца блока
				Результат.Описание = ИзвлечьОписаниеОшибкиИзСтрокСервер(СтрокиСтека, Индекс);
				
				// Извлекаем исходную строку (после }:)
				ПозицияДвоеточия = СтрНайти(Строка, "}:");
				Если ПозицияДвоеточия > 0 Тогда
					Результат.ИсходнаяСтрока = СокрЛП(Сред(Строка, ПозицияДвоеточия + 2));
					Результат.НомерСтрокиОригинала = 0;
				КонецЕсли;
				
				Возврат Результат;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Обычная ошибка - ищем {(номер)} с конца к началу
	ИндексСтрокиКода = -1;
	Индекс = СтрокиСтека.ВГраница();
	Пока Индекс >= 0 Цикл
		Строка = СтрокиСтека[Индекс];
		ТриммированнаяСтрока = СокрЛ(Строка);
		
		Если СтрНачинаетсяС(ТриммированнаяСтрока, "{(") Тогда
			ИндексСтрокиКода = Индекс;
			
			Позиция = ИзвлечьПозициюВыполняемогоКодаСервер(Строка);
			Результат.НомерСтроки = Позиция.НомерСтроки;
			Результат.НомерКолонки = Позиция.НомерКолонки;
			Результат.ЭтоВыполняемыйКод = Истина;
			
			ПозицияДвоеточия = СтрНайти(Строка, "}:");
			Если ПозицияДвоеточия > 0 Тогда
				Результат.ИсходнаяСтрока = СокрЛП(Сред(Строка, ПозицияДвоеточия + 2));
				Результат.НомерСтрокиОригинала = 0;
			КонецЕсли;
			
			Прервать;
		КонецЕсли;
		
		Индекс = Индекс - 1;
	КонецЦикла;
	
	// Описание: от начала до строки с ошибкой (или до "по причине:")
	Если ИндексСтрокиКода >= 0 Тогда
		КонечныйИндекс = ?(ИндексПоПричине >= 0, ИндексПоПричине - 1, ИндексСтрокиКода);
		Результат.Описание = ИзвлечьОписаниеОтНачалаДоИндексаСервер(СтрокиСтека, КонечныйИндекс);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Извлекает описание ошибки от начала массива до указанного индекса.
// Делегирует в общий клиент-серверный модуль.
//
Функция ИзвлечьОписаниеОтНачалаДоИндексаСервер(СтрокиСтека, КонечныйИндекс)
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.ИзвлечьОписаниеОтНачалаДоИндекса(СтрокиСтека, КонечныйИндекс);
	
КонецФункции

// Извлекает многострочное описание ошибки из массива строк.
// Делегирует в общий клиент-серверный модуль.
//
Функция ИзвлечьОписаниеОшибкиИзСтрокСервер(СтрокиСтека, ИндексНачала)
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.ИзвлечьОписаниеОшибкиИзСтрок(СтрокиСтека, ИндексНачала);
	
КонецФункции

// Извлекает позицию из описания ошибки выполняемого кода.
// Делегирует в общий клиент-серверный модуль.
// Формат: {(строка,колонка)}:...
//
Функция ИзвлечьПозициюВыполняемогоКодаСервер(ОписаниеОшибки)
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.ИзвлечьПозициюВыполняемогоКода(ОписаниеОшибки);
	
КонецФункции

// Извлекает позицию из описания ошибки с именем модуля.
// Делегирует в общий клиент-серверный модуль.
// Формат: {<ИмяМодуля>(строка,колонка)}:...
//
Функция ИзвлечьПозициюИзМодульнойОшибкиСервер(ОписаниеОшибки)
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.ИзвлечьПозициюИзМодульнойОшибки(ОписаниеОшибки);
	
КонецФункции

// Извлекает координаты (строка, колонка) из строки формата "N, M".
// Делегирует в общий клиент-серверный модуль.
//
Процедура ИзвлечьКоординатыИзСтроки(СтрокаКоординат, Результат)
	
	конс_ПодключаемаяКонсольКлиентСервер.ИзвлечьКоординатыИзСтроки(СтрокаКоординат, Результат);
	
КонецПроцедуры

// Создает пустую структуру описания ошибки.
// Делегирует в общий клиент-серверный модуль.
//
Функция НовоеОписаниеОшибки() Экспорт
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.НовоеОписаниеОшибки();
	
КонецФункции

#КонецОбласти

#Область ВнешнееВыполнениеКода

// Создаёт контекст для внешнего выполнения кода.
// Контекст содержит временное хранилище для переменных и другие служебные данные.
// 
// Параметры:
//   ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы для привязки хранилища
//   РежимПоказаПеременных - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим отображения переменных
//
// Возвращаемое значение:
//   Структура - контекст выполнения:
//     * АдресХраненияПеременных - Строка - адрес временного хранилища для переменных
//     * РежимПоказаПеременных - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим отображения
//     * КодИнициализацииПеременных - Строка - код для объявления ЗначенияПеременных
//
// Пример:
//   // На сервере создаём контекст
//   Контекст = конс_ПодключаемаяКонсольСервер.СоздатьКонтекстВыполнения(
//       УникальныйИдентификатор, Перечисления.конс_РежимПоказаПеременных.ВТабло);
//   
//   // На клиенте используем
//   Код = Контекст.КодИнициализацииПеременных + ИсходныйКод + КодСбораПеременных;
//   Попытка
//       Выполнить(Код);
//   Исключение
//       // Обработка ошибки
//   КонецПопытки;
//
Функция СоздатьКонтекстВыполнения(ИдентификаторФормы, РежимПоказаПеременных = Неопределено) Экспорт
	
	Если РежимПоказаПеременных = Неопределено Тогда
		РежимПоказаПеременных = Перечисления.конс_РежимПоказаПеременных.ВТабло;
	КонецЕсли;
	
	Контекст = Новый Структура;
	
	// Создаём временное хранилище для переменных
	ДанныеХранилища = Новый Структура;
	ДанныеХранилища.Вставить("ХранилищеПеременных", Новый Структура);
	ДанныеХранилища.Вставить("КэшСсылок", Новый Соответствие);
	
	АдресХраненияПеременных = ПоместитьВоВременноеХранилище(ДанныеХранилища, ИдентификаторФормы);
	
	Контекст.Вставить("АдресХраненияПеременных", АдресХраненияПеременных);
	Контекст.Вставить("РежимПоказаПеременных", РежимПоказаПеременных);
	Контекст.Вставить("КодИнициализацииПеременных", "ЗначенияПеременных = Новый Структура;" + Символы.ПС);
	
	Возврат Контекст;
	
КонецФункции

// Формирует результат выполнения на основе контекста и информации об ошибке.
// Вызывается после внешнего Выполнить для обработки результата.
// 
// Параметры:
//   ЗначенияПеременных - Структура - значения переменных после выполнения
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Неопределено - ошибка выполнения или Неопределено при успехе
//   АдресХраненияПеременных - Строка - адрес хранилища из контекста
//   РежимПоказаПеременных - Число - режим отображения переменных
// Формирует результат выполнения на основе контекста и информации об ошибке.
// Вызывается после внешнего Выполнить для обработки результата.
// 
// Параметры:
//   ЗначенияПеременных - Структура - значения переменных после выполнения
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Структура, Неопределено - ошибка выполнения или Неопределено при успехе.
//                        Может быть ИнформацияОбОшибке (при серверном вызове) 
//                        или Структура (при передаче с клиента, полученная через РазобратьИнформациюОбОшибкеКлиент)
//   АдресХраненияПеременных - Строка - адрес хранилища из контекста
//   РежимПоказаПеременных - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим отображения переменных
//
// Возвращаемое значение:
//   Структура - результат выполнения (см. НовыйРезультатВыполнения)
//
// Пример:
//   ЗначенияПеременных = Новый Структура;
//   ИнфоОшибки = Неопределено;
//   
//   Попытка
//       Выполнить(КодСПеременными);
//   Исключение
//       ИнфоОшибки = ИнформацияОбОшибке();
//   КонецПопытки;
//   
//   Результат = конс_ПодключаемаяКонсольСервер.СформироватьРезультатВыполнения(
//       ЗначенияПеременных, ИнфоОшибки, Контекст.АдресХраненияПеременных, Контекст.РежимПоказаПеременных);
//
Функция СформироватьРезультатВыполнения(ЗначенияПеременных, ИнформацияОбОшибке, АдресХраненияПеременных, РежимПоказаПеременных) Экспорт
	
	Результат = НовыйРезультатВыполнения();
	Результат.РежимПоказаПеременных = РежимПоказаПеременных;
	
	Если ИнформацияОбОшибке = Неопределено Тогда
		Результат.Успешно = Истина;
		
		// Сериализуем переменные в соответствии с режимом
		Попытка
			Если РежимПоказаПеременных = Перечисления.конс_РежимПоказаПеременных.ВТабло Тогда
				// Режим табло
				АдресПеременных = АдресХраненияПеременных;
				Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, АдресПеременных);
				Результат.АдресХраненияПеременных = АдресПеременных;
			ИначеЕсли РежимПоказаПеременных = Перечисления.конс_РежимПоказаПеременных.ВПодсказках Тогда
				// Режим подсказок
				Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляПодсказок(ЗначенияПеременных);
				Результат.АдресХраненияПеременных = АдресХраненияПеременных;
			Иначе
				Результат.ОписаниеПеременных = "";
			КонецЕсли;
		Исключение
			Результат.ОписаниеПеременных = "";
		КонецПопытки;
	Иначе
		// Если передана структура (с клиента) - используем как есть
		// Если передан ИнформацияОбОшибке (серверный вызов) - разбираем
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("Структура") Тогда
			Результат.ИнформацияОбОшибке = ИнформацияОбОшибке;
		Иначе
			Результат.ИнформацияОбОшибке = РазобратьИнформациюОбОшибкеСервер(ИнформацияОбОшибке);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Освобождает контекст выполнения и удаляет временное хранилище.
// 
// Параметры:
//   АдресХраненияПеременных - Строка - адрес хранилища из контекста
//
Процедура ОсвободитьКонтекстВыполнения(АдресХраненияПеременных) Экспорт
	
	Если ЭтоАдресВременногоХранилища(АдресХраненияПеременных) Тогда
		УдалитьИзВременногоХранилища(АдресХраненияПеременных);
	КонецЕсли;
	
КонецПроцедуры

// Формирует код для сбора значений переменных.
// 
// Параметры:
//   ИменаПеременных - Массив - массив имён переменных для сбора
//
// Возвращаемое значение:
//   Строка - код BSL для сбора переменных в структуру ЗначенияПеременных
//
Функция СформироватьКодСбораПеременных(ИменаПеременных) Экспорт
	
	Если ИменаПеременных = Неопределено Или ИменаПеременных.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ПС = Символы.ПС;
	Код = "";
	
	Для Каждого Имя Из ИменаПеременных Цикл
		Код = Код + ПС + "Попытка ЗначенияПеременных.Вставить(""" + Имя + """, Вычислить(""" + Имя + """)); Исключение КонецПопытки;";
	КонецЦикла;
	
	Возврат Код;
	
КонецФункции

// Создаёт временное хранилище для переменных внешнего выполнения.
// 
// Параметры:
//   ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы для привязки хранилища
//
// Возвращаемое значение:
//   Строка - адрес временного хранилища
//
Функция СоздатьВременноеХранилищеПеременных(ИдентификаторФормы) Экспорт
	
	// Создаём пустую структуру - она будет заменена при выполнении кода
	Возврат ПоместитьВоВременноеХранилище(Новый Структура, ИдентификаторФормы);
	
КонецФункции

// Обрабатывает результат внешнего выполнения кода.
// Получает переменные из хранилища и формирует структуру результата.
// 
// Параметры:
//   АдресХраненияПеременных - Строка - адрес хранилища с переменными
//   ИнформацияОбОшибке - Структура, Неопределено - разобранная информация об ошибке
//   РежимПоказаПеременных - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим отображения переменных
//
// Возвращаемое значение:
//   Структура - результат выполнения
//
Функция ОбработатьРезультатВнешнегоВыполнения(АдресХраненияПеременных, ИнформацияОбОшибке, РежимПоказаПеременных) Экспорт
	
	Результат = НовыйРезультатВыполнения();
	Результат.РежимПоказаПеременных = РежимПоказаПеременных;
	
	Если ИнформацияОбОшибке <> Неопределено Тогда
		// Была ошибка выполнения
		Результат.ИнформацияОбОшибке = ИнформацияОбОшибке;
		Возврат Результат;
	КонецЕсли;
	
	Результат.Успешно = Истина;
	
	// Получаем переменные из хранилища
	ЗначенияПеременных = Новый Структура;
	Если ЭтоАдресВременногоХранилища(АдресХраненияПеременных) Тогда
		ДанныеИзХранилища = ПолучитьИзВременногоХранилища(АдресХраненияПеременных);
		Если ТипЗнч(ДанныеИзХранилища) = Тип("Структура") Тогда
			ЗначенияПеременных = ДанныеИзХранилища;
		КонецЕсли;
	КонецЕсли;
	
	// Сериализуем переменные в соответствии с режимом
	Попытка
		Если РежимПоказаПеременных = Перечисления.конс_РежимПоказаПеременных.ВТабло Тогда
			// Режим табло
			АдресПеременных = "";
			Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, АдресПеременных);
			Результат.АдресХраненияПеременных = АдресПеременных;
		ИначеЕсли РежимПоказаПеременных = Перечисления.конс_РежимПоказаПеременных.ВПодсказках Тогда
			// Режим подсказок
			Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляПодсказок(ЗначенияПеременных);
		Иначе
			Результат.ОписаниеПеременных = "";
		КонецЕсли;
	Исключение
		Результат.ОписаниеПеременных = "";
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ВыводВТабло

// Получает описание переменных отладки для табло из данных ВМ.
// Извлекает переменные из адреса данных отладки (ДанныеОтладки["Переменные"])
// и сериализует их в формат табло.
// 
// Параметры:
//   АдресПеременных - Строка - адрес данных отладки во временном хранилище
//   АдресХраненияПеременных - Строка - возвращаемый адрес хранилища переменных табло
//
// Возвращаемое значение:
//   Строка - JSON-описание переменных для табло
//
Функция ПолучитьОписаниеПеременныхОтладки(АдресПеременных, АдресХраненияПеременных) Экспорт
	
	Если Не ЗначениеЗаполнено(АдресПеременных) Тогда
		Возврат "{}";
	КонецЕсли;
	
	Попытка
		ДанныеОтладки = ПолучитьИзВременногоХранилища(АдресПеременных);
	Исключение
		Возврат "{}";
	КонецПопытки;
	
	Если ДанныеОтладки = Неопределено Тогда
		Возврат "{}";
	КонецЕсли;
	
	СоответствиеПеременных = Неопределено;
	Если ТипЗнч(ДанныеОтладки) = Тип("Соответствие") Тогда
		СоответствиеПеременных = ДанныеОтладки["Переменные"];
	КонецЕсли;
	
	Если СоответствиеПеременных = Неопределено Тогда
		Возврат "{}";
	КонецЕсли;
	
	// Преобразуем Соответствие переменных в Структуру
	ЗначенияПеременных = Новый Структура;
	Для Каждого КлючЗначение Из СоответствиеПеременных Цикл
		Попытка
			ЗначенияПеременных.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
		Исключение
			// Имена с недопустимыми символами для ключей структуры пропускаем
		КонецПопытки;
	КонецЦикла;
	
	Возврат ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, АдресХраненияПеременных);
	
КонецФункции

// Получает описание переменных для вывода в табло.
// 
// Параметры:
//   ЗначенияПеременных - Структура - переменные и их значения
//   АдресХраненияПеременных - Строка - возвращаемый адрес хранилища
//
// Возвращаемое значение:
//   Строка - JSON-описание переменных для табло
//
Функция ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, АдресХраненияПеременных) Экспорт
	
	Описание = Новый Структура;
	КэшСсылок = Новый Соответствие;
	ХранилищеПеременных = Новый Структура;
	
	Для Каждого КлючЗначение Из ЗначенияПеременных Цикл
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Попытка
			Переменная = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Значение, КлючЗначение.Ключ, "", КэшСсылок);
		Исключение
			Переменная = Новый Структура;
			Переменная.Вставить("label", КлючЗначение.Ключ);
			Переменная.Вставить("value", "<ошибка получения значения>");
			Переменная.Вставить("type", "Ошибка");
			Переменная.Вставить("path", "");
			Переменная.Вставить("class", "final");
		КонецПопытки;
		Описание.Вставить(ИдентификаторПеременной, Переменная);
		Попытка
			ХранилищеПеременных.Вставить(ИдентификаторПеременной, КлючЗначение.Значение);
		Исключение
			ХранилищеПеременных.Вставить(ИдентификаторПеременной, Неопределено);
		КонецПопытки;
	КонецЦикла;
	
	Данные = Новый Структура;
	Данные.Вставить("ХранилищеПеременных", ХранилищеПеременных);
	Данные.Вставить("КэшСсылок", КэшСсылок);
	
	АдресХраненияПеременных = ПоместитьВоВременноеХранилище(Данные, Новый УникальныйИдентификатор);
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	ЗаписатьJSON(Запись, Описание);
	
	Возврат Запись.Закрыть();
	
КонецФункции

// Получает описание переменных для всплывающих подсказок.
// 
// Параметры:
//   ЗначенияПеременных - Структура - переменные и их значения
//
// Возвращаемое значение:
//   Строка - JSON-описание переменных для подсказок
//
Функция ПолучитьОписаниеПеременныхДляПодсказок(ЗначенияПеременных) Экспорт
	
	Описание = Новый Структура;
	КэшСсылок = Новый Соответствие;
	
	Для Каждого КлючЗначение Из ЗначенияПеременных Цикл
		Представление = ПолучитьПредставлениеПеременной(КлючЗначение.Значение, -1, КэшСсылок);
		Описание.Вставить(КлючЗначение.Ключ, Представление);
	КонецЦикла;
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	ЗаписатьJSON(Запись, Описание);
	
	Возврат Запись.Закрыть();
	
КонецФункции

#КонецОбласти

#Область Отладка

// Компилирует BSL-код и инициализирует виртуальную машину для отладки.
// 
// Параметры:
//   ИсходныйКод - Строка - исходный код BSL
//   ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы для привязки хранилища
//   ЗначенияПеременных - Соответствие, Неопределено - значения внешних переменных для контекста отладчика.
//                        Ключ - имя переменной (в верхнем регистре), Значение - сериализуемое значение.
//                        Заполняется автоматически через ДобавитьПеременную при передаче значений объектов.
//
// Возвращаемое значение:
//   Структура:
//     * Успех - Булево
//     * Ошибки - Массив
//     * АдресВМ - Строка - адрес виртуальной машины во временном хранилище
//     * АдресПеременных - Строка - адрес переменных во временном хранилище
//
Функция СкомпилироватьИЗапуститьОтладку(ИсходныйКод, ИдентификаторФормы, ЗначенияПеременных = Неопределено, ПредварительныеЛексемыJSON = "") Экспорт
	
	Результат = Новый Структура("Успех, Ошибки, АдресВМ, АдресПеременных", Ложь, Новый Массив, "", "");
	
	ДанныеТаблицПерехода = конс_ТаблицыПереходовПовтИсп.ПолучитьДанныеТаблицПерехода();
	
	// Формируем внешние переменные для компилятора (список имён)
	ВнешниеПеременные = Неопределено;
	Если ЗначенияПеременных <> Неопределено И ЗначенияПеременных.Количество() > 0 Тогда
		ИменаПеременных = Новый Массив;
		Для Каждого КлючЗначение Из ЗначенияПеременных Цикл
			ИменаПеременных.Добавить(КлючЗначение.Ключ);
		КонецЦикла;
		ВнешниеПеременные = Новый Структура("Параметры", ИменаПеременных);
	КонецЕсли;
	
	ДанныеКомпиляции = конс_КомпиляцияКлиентСервер.ВыполнитьКомпиляцию(
		ИсходныйКод, ДанныеТаблицПерехода, , ВнешниеПеременные, ПредварительныеЛексемыJSON);
	
	Если Не ДанныеКомпиляции.ВыполнениеВозможно Тогда
		Результат.Ошибки = ДанныеКомпиляции.Ошибки;
		Возврат Результат;
	КонецЕсли;
	
	АдресТаблицПерехода = ПоместитьВоВременноеХранилище(
		ДанныеТаблицПерехода, ИдентификаторФормы);
	
	ПараметрыСреды = Новый Структура;
	ПараметрыСреды.Вставить("ИдентификаторФормы", ИдентификаторФормы);
	ПараметрыСреды.Вставить("АдресВМ", "");
	ПараметрыСреды.Вставить("АдресПеременных", "");
	ПараметрыСреды.Вставить("АдресТаблицПерехода", АдресТаблицПерехода);
	ПараметрыСреды.Вставить("ВариантВстроенногоЯзыка", "ru");
	ПараметрыСреды.Вставить("ЗначенияВнешнихПеременных", ЗначенияПеременных);
	
	конс_ВМ_КлиентСервер.СоздатьВМ(ДанныеКомпиляции, ПараметрыСреды);
	
	АдресВМ = ПараметрыСреды.АдресВМ;
	АдресПеременных = ПараметрыСреды.АдресПеременных;
	
	Результат.Успех = Истина;
	Результат.АдресВМ = АдресВМ;
	Результат.АдресПеременных = АдресПеременных;
	Возврат Результат;
	
КонецФункции

// Продолжает выполнение виртуальной машины до следующей точки останова.
// 
// Параметры:
//   АдресВМ - Строка - адрес ВМ во временном хранилище
//   АдресПеременных - Строка - адрес переменных во временном хранилище
//   ТочкиОстанова - Соответствие - соответствие номеров строк-точек останова
//   МаксимальнаяГлубинаОстановки - Число, Неопределено - максимальная глубина стека вызовов для остановки (для "Шагнуть через")
//   ОстановкаПоОшибке - Булево - останавливать ли при ошибке
//
Процедура ПродолжитьОтладку(АдресВМ, АдресПеременных, ТочкиОстанова, МаксимальнаяГлубинаОстановки = Неопределено, ОстановкаПоОшибке = Истина) Экспорт
	
	конс_ВМ_КлиентСервер.ПродолжитьОтладку(
		АдресВМ, АдресПеременных, ОстановкаПоОшибке, ТочкиОстанова, МаксимальнаяГлубинаОстановки);
	
КонецПроцедуры

// Получает текущее состояние виртуальной машины.
// 
// Параметры:
//   АдресВМ - Строка - адрес ВМ во временном хранилище
//
// Возвращаемое значение:
//   Структура - состояние ВМ
//
Функция ПолучитьСостояниеОтладки(АдресВМ) Экспорт
	
	Возврат конс_ВМ_КлиентСервер.ПолучитьСостояниеВМ(АдресВМ);
	
КонецФункции

// Завершает выполнение виртуальной машины.
// 
// Параметры:
//   АдресВМ - Строка - адрес ВМ во временном хранилище
//
Процедура ЗавершитьОтладкуВМ(АдресВМ) Экспорт
	
	конс_ВМ_КлиентСервер.ЗавершитьОтладку(АдресВМ);
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Вычисляет хеш двоичных данных для контроля версий.
// Используется для определения изменений в макете с исходниками редактора.
//
// Параметры:
//   ДвоичныеДанные - ДвоичныеДанные - данные для хеширования
//
// Возвращаемое значение:
//   Строка - хеш в формате Base64, безопасный для имён файлов
//
Функция ВычислитьХешДанных(ДвоичныеДанные) Экспорт
	
	Хеш = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеш.Добавить(ДвоичныеДанные);
	ХешСтрока = Base64Строка(Хеш.ХешСумма);
	
	// Заменяем символы, недопустимые в именах файлов
	ХешСтрока = СтрЗаменить(ХешСтрока, "+", "-");
	ХешСтрока = СтрЗаменить(ХешСтрока, "/", "_");
	ХешСтрока = СтрЗаменить(ХешСтрока, "=", "");
	
	Возврат ХешСтрока;
	
КонецФункции

Функция НовыйИдентификаторПеременной()
	
	Возврат "var_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
	
КонецФункции

// Получает краткую структуру переменной для табло.
//
Функция ПолучитьКраткуюСтруктуруПеременной(Значение, Имя, ПутьКДанным, КэшСсылок)
	
	Представление = "";
	ТипЗнч = ТипЗнч(Значение);
	Картинка = "";
	Класс = "";
	
	Если ТипЗнч = Тип("Число") Тогда
		Представление = Строка(Значение);
		Картинка = "int.png";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Строка") Тогда
		Представление = Значение;
		Картинка = "string.png";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Булево") Тогда
		Представление = Строка(Значение);
		Картинка = "boolean.png";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Дата") Тогда
		Представление = Строка(Значение);
		Картинка = "date.png";
		Класс = "final";
	ИначеЕсли Значение = Неопределено Тогда
		Представление = "Неопределено";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Null") Тогда
		Картинка = "null.png";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Структура") Или ТипЗнч = Тип("Соответствие") Тогда
		Представление = СтрШаблон("%1 (%2)", Строка(ТипЗнч), Значение.Количество());
		Картинка = "array.png";
		Если Значение.Количество() = 0 Тогда
			Класс = "final";
		КонецЕсли;
	ИначеЕсли ТипЗнч = Тип("Массив") Или ТипЗнч = Тип("СписокЗначений") Тогда
		Представление = СтрШаблон("%1 (%2)", Строка(ТипЗнч), Значение.Количество());
		Картинка = "array.png";
		Если Значение.Количество() = 0 Тогда
			Класс = "final";
		КонецЕсли;
	ИначеЕсли ТипЗнч = Тип("ТаблицаЗначений") Тогда
		Представление = СтрШаблон("%1 (%2)", Строка(ТипЗнч), Значение.Количество());
		Картинка = "table.png";
		Если Значение.Количество() = 0 Тогда
			Класс = "final";
		КонецЕсли;
	ИначеЕсли ТипЗнч = Тип("ДеревоЗначений") Тогда
		Представление = СтрШаблон("%1 (%2)", Строка(ТипЗнч), Значение.Строки.Количество());
		Картинка = "tree.png";
		Если Значение.Строки.Количество() = 0 Тогда
			Класс = "final";
		КонецЕсли;
	ИначеЕсли ТипЗнч = Тип("Запрос") Тогда
		Представление = Строка(ТипЗнч);
		Картинка = "query.png";
	ИначеЕсли ЭтоСсылка(Значение) Тогда
		Попытка
			Если Не Значение.Пустая() Тогда
				Ссылка = ПолучитьНавигационнуюСсылку(Значение);
				Представление = СтрШаблон("<a href='%1'>%2</a>", Ссылка, Строка(Значение));
			Иначе
				Представление = "";
			КонецЕсли;
		Исключение
			Представление = Строка(Значение);
		КонецПопытки;
		Картинка = ОпределитьИконкуСсылки(Значение);
	ИначеЕсли ЭтоОбъект(Значение) Тогда
		Попытка
			Представление = Строка(ТипЗнч);
		Исключение
			Представление = Строка(ТипЗнч);
		КонецПопытки;
		Картинка = ОпределитьИконкуСсылки(Значение);
	Иначе
		// Попытка определить итерируемую коллекцию (табличные части, результаты запросов и т.д.)
		ЭтоКоллекция = Ложь;
		Попытка
			Количество = Значение.Количество();
			ЭтоКоллекция = Истина;
		Исключение
		КонецПопытки;
		
		Если ЭтоКоллекция Тогда
			Представление = СтрШаблон("%1 (%2)", Строка(ТипЗнч), Количество);
			Картинка = "table.png";
			Если Количество = 0 Тогда
				Класс = "final";
			КонецЕсли;
		Иначе
			// Попытка определить объект с метаданными (строки табличных частей и т.д.)
			ЕстьМетаданные = Ложь;
			Попытка
				МетаданныеТипа = Метаданные.НайтиПоТипу(ТипЗнч);
				Если МетаданныеТипа <> Неопределено Тогда
					ЕстьМетаданные = МетаданныеТипа.Реквизиты.Количество() > 0;
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Попытка
				Представление = Строка(Значение);
			Исключение
				Представление = Строка(ТипЗнч);
			КонецПопытки;
			
			Если Не ЕстьМетаданные Тогда
				Класс = "final";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Переменная = Новый Структура;
	Переменная.Вставить("label", Имя);
	Переменная.Вставить("value", Представление);
	Переменная.Вставить("type", Строка(ТипЗнч));
	Переменная.Вставить("path", ПутьКДанным);
	Переменная.Вставить("class", Класс);
	
	Если ЗначениеЗаполнено(Картинка) Тогда
		Переменная.Вставить("icon", Картинка);
	КонецЕсли;
	
	Возврат Переменная;
	
КонецФункции

// Получает текстовое представление переменной для подсказок.
//
Функция ПолучитьПредставлениеПеременной(Значение, Знач Смещение, КэшСсылок)
	
	Представление = "";
	ТипЗнч = ТипЗнч(Значение);
	
	Смещение = Смещение + 1;
	
	Если ТипЗнч = Тип("Число") Или ТипЗнч = Тип("Строка")
		Или ТипЗнч = Тип("Булево") Или ТипЗнч = Тип("Дата") Тогда
		Представление = Строка(Значение);
	ИначеЕсли Значение = Неопределено Тогда
		Представление = "Неопределено";
	ИначеЕсли ТипЗнч = Тип("Null") Тогда
		Представление = "Null";
	ИначеЕсли ТипЗнч = Тип("Структура") Или ТипЗнч = Тип("Соответствие") Тогда
		Представление = ПолучитьПредставлениеСтруктурыСоответствия(Значение, Смещение, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("Массив") Или ТипЗнч = Тип("СписокЗначений") Тогда
		Представление = ПолучитьПредставлениеМассиваСписка(Значение, Смещение, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("ТаблицаЗначений") Тогда
		Представление = СтрШаблон("**Таблица значений (%1):**", Значение.Количество());
	ИначеЕсли ТипЗнч = Тип("ДеревоЗначений") Тогда
		Представление = СтрШаблон("**Дерево значений (%1):**", Значение.Строки.Количество());
	ИначеЕсли ТипЗнч = Тип("Запрос") Тогда
		Представление = "**Запрос**";
	ИначеЕсли ЭтоСсылка(Значение) Тогда
		Попытка
			Если Не Значение.Пустая() Тогда
				НавСсылка = ПолучитьНавигационнуюСсылку(Значение);
				Представление = СтрШаблон("[%1](%2)", Строка(Значение), НавСсылка);
			Иначе
				Представление = "";
			КонецЕсли;
		Исключение
			Представление = Строка(Значение);
		КонецПопытки;
	Иначе
		Попытка
			Представление = Строка(Значение);
		Исключение
			Представление = Строка(ТипЗнч);
		КонецПопытки;
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

Функция ПолучитьПредставлениеСтруктурыСоответствия(Значение, Смещение, КэшСсылок)
	
	Строки = Новый Массив;
	Строки.Добавить(СтрШаблон("**%1 (%2)**:", ТипЗнч(Значение), Значение.Количество()));
	
	Для Каждого КлючЗначение Из Значение Цикл
		Маркер = ДополнитьСтроку("- ", Смещение * 4, " ");
		Строки.Добавить(Маркер + КлючЗначение.Ключ + ": " + ПолучитьПредставлениеПеременной(КлючЗначение.Значение, Смещение, КэшСсылок));
	КонецЦикла;
	
	Возврат СтрСоединить(Строки, Символы.ПС);
	
КонецФункции

Функция ПолучитьПредставлениеМассиваСписка(Значение, Смещение, КэшСсылок)
	
	Строки = Новый Массив;
	ТипЗнч = ТипЗнч(Значение);
	ЭтоМассив = (ТипЗнч = Тип("Массив"));
	
	Строки.Добавить(СтрШаблон("**%1 (%2)**:", ТипЗнч, Значение.Количество()) + Символы.ПС);
	
	Индекс = 0;
	Для Каждого Элемент Из Значение Цикл
		Маркер = ДополнитьСтроку("- (" + Индекс + ") ", Смещение * 4, " ");
		
		Если ЭтоМассив Тогда
			Строки.Добавить(Маркер + ПолучитьПредставлениеПеременной(Элемент, Смещение, КэшСсылок));
		Иначе
			Строки.Добавить(Маркер + ПолучитьПредставлениеПеременной(Элемент.Значение, Смещение, КэшСсылок));
		КонецЕсли;
		
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат СтрСоединить(Строки, Символы.ПС);
	
КонецФункции

Функция ДополнитьСтроку(Знач Результат, СимволовДополнить, Дополнение = " ", Слева = Истина)
	
	Стр = "";
	Для Сч = 1 По СимволовДополнить Цикл
		Стр = Стр + Дополнение;
	КонецЦикла;
	
	Возврат ?(Слева, Стр + Результат, Результат + Стр);
	
КонецФункции

// Определяет иконку для ссылочного типа по классу метаданных.
//
// Параметры:
//   Значение - Произвольный - значение ссылочного типа
//
// Возвращаемое значение:
//   Строка - имя файла иконки (с расширением)
//
Функция ОпределитьИконкуСсылки(Значение)
	
	ТипЗнч = ТипЗнч(Значение);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч);
	
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат "catalog.svg";
	КонецЕсли;
	
	ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
	КлассМетаданных = СтрРазделить(ПолноеИмя, ".")[0];
	
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("Справочник",              "catalog.svg");
	Соответствие.Вставить("Документ",                 "document.svg");
	Соответствие.Вставить("Перечисление",             "enum.svg");
	Соответствие.Вставить("ПланОбмена",               "exchangePlan.svg");
	Соответствие.Вставить("ПланВидовХарактеристик",   "chartsOfCharacteristicType.svg");
	Соответствие.Вставить("ПланСчетов",               "chartsOfAccount.svg");
	Соответствие.Вставить("ПланВидовРасчета",         "chartsOfCalculationType.svg");
	Соответствие.Вставить("БизнесПроцесс",            "bprocess.svg");
	Соответствие.Вставить("Задача",                   "task.svg");
	
	Результат = Соответствие.Получить(КлассМетаданных);
	
	Если Результат = Неопределено Тогда
		Возврат "catalog.svg";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ЭтоСсылка(Значение)
	
	ЭтоСсылка = Ложь;
	
	ТипЗнч = ТипЗнч(Значение);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч);
	
	Если ОбъектМетаданных <> Неопределено Тогда
		ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
		Массив = СтрРазделить(ПолноеИмя, ".");
		Массив[0] = Массив[0] + "Ссылка";
		ИмяТипа = СтрСоединить(Массив, ".");
		
		Попытка
			ЭтоСсылка = (ТипЗнч = Тип(ИмяТипа));
		Исключение
			ЭтоСсылка = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Возврат ЭтоСсылка;
	
КонецФункции

Функция ЭтоОбъект(Значение)
	
	ТипЗнч = ТипЗнч(Значение);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч);
	
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
	Массив = СтрРазделить(ПолноеИмя, ".");
	КлассМетаданных = Массив[0];
	
	// Проверяем типы объектов для всех прикладных классов
	Суффиксы = Новый Массив;
	Суффиксы.Добавить("Объект");
	
	Для Каждого Суффикс Из Суффиксы Цикл
		Массив[0] = КлассМетаданных + Суффикс;
		ИмяТипа = СтрСоединить(Массив, ".");
		Попытка
			Если ТипЗнч = Тип(ИмяТипа) Тогда
				Возврат Истина;
			КонецЕсли;
		Исключение
			// Тип не существует для этого суффикса
		КонецПопытки;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Раскрывает переменную для показа дочерних элементов в табло.
// 
// Параметры:
//   ХранилищеПеременных - Структура - хранилище переменных
//   КэшСсылок - Соответствие - кэш ссылок  
//   ПутьКДанным - Строка - путь вида "var_xxx.Свойство" или "var_xxx[0]"
//   ИмяПеременной - Строка - имя переменной для отображения
//
// Возвращаемое значение:
//   Структура, Неопределено - описание переменной с children или Неопределено
//
Функция РаскрытьПеременнуюВТаблоСервер(ХранилищеПеременных, КэшСсылок, ПутьКДанным, ИмяПеременной) Экспорт
	
	// Находим значение по пути через Вычислить
	Значение = Неопределено;
	
	Путь = СтрЗаменить(ПутьКДанным, "&quote;", """");
	
	Попытка
		Значение = Вычислить("ХранилищеПеременных." + Путь);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Восстанавливаем путь с экранированием кавычек
	Путь = СтрЗаменить(Путь, """", "&quote;");
	
	// Получаем дочерние элементы
	Дочерние = ПолучитьДочерниеЭлементы(Значение, Путь, КэшСсылок);
	
	Если Дочерние = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Формируем описание переменной с дочерними элементами
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяПеременной, Путь, КэшСсылок);
	Переменная.Вставить("children", Дочерние);
	
	Возврат Переменная;
	
КонецФункции

// Получает дочерние элементы в зависимости от типа значения.
//
// Параметры:
//   Значение - Произвольный - значение для получения дочерних элементов
//   ПутьКДанным - Строка - путь к значению
//   КэшСсылок - Соответствие - кэш ссылок
//
// Возвращаемое значение:
//   Структура, Неопределено - дочерние элементы или Неопределено если тип не поддерживается
//
Функция ПолучитьДочерниеЭлементы(Значение, ПутьКДанным, КэшСсылок)
	
	ТипЗнч = ТипЗнч(Значение);
	
	Если ТипЗнч = Тип("Структура") Тогда
		Возврат ПолучитьОписаниеСтруктуры(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("Соответствие") Тогда
		Возврат ПолучитьОписаниеСоответствия(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("Массив") Тогда
		Возврат ПолучитьОписаниеИндексированнойКоллекции(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("СписокЗначений") Тогда
		Возврат ПолучитьОписаниеИндексированнойКоллекции(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("ТаблицаЗначений") Тогда
		Возврат ПолучитьОписаниеИндексированнойКоллекции(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("СтрокаТаблицыЗначений") Тогда
		Возврат ПолучитьОписаниеСтрокиТаблицы(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("ДеревоЗначений") Тогда
		Возврат ПолучитьОписаниеДереваЗначений(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("СтрокаДереваЗначений") Тогда
		Возврат ПолучитьОписаниеСтрокиДерева(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("КоллекцияСтрокДереваЗначений") Тогда
		Возврат ПолучитьОписаниеИндексированнойКоллекции(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("КлючИЗначение") Тогда
		Возврат ПолучитьОписаниеКлючаИЗначения(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("ЭлементСпискаЗначений") Тогда
		Возврат ПолучитьОписаниеЭлементаСписка(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("Запрос") Тогда
		Возврат ПолучитьОписаниеЗапроса(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ЭтоСсылка(Значение) Тогда
		Возврат ПолучитьОписаниеСсылки(Значение, ПутьКДанным, КэшСсылок);
	ИначеЕсли ЭтоОбъект(Значение) Тогда
		Возврат ПолучитьОписаниеОбъекта(Значение, ПутьКДанным, КэшСсылок);
	КонецЕсли;
	
	// Попытка обработать как выгружаемую коллекцию (табличные части и другие коллекции с методом Выгрузить)
	Попытка
		ТЗ = Значение.Выгрузить();
		Возврат ПолучитьОписаниеИндексированнойКоллекции(ТЗ, ПутьКДанным, КэшСсылок);
	Исключение
	КонецПопытки;
	
	// Попытка обработать как индексированную коллекцию
	Попытка
		Если Значение.Количество() >= 0 Тогда
			Возврат ПолучитьОписаниеИндексированнойКоллекции(Значение, ПутьКДанным, КэшСсылок);
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	// Попытка обработать через метаданные (строки табличных частей и т.д.)
	Попытка
		МетаданныеТипа = Метаданные.НайтиПоТипу(ТипЗнч(Значение));
		Если МетаданныеТипа <> Неопределено Тогда
			Дочерние = Новый Структура;
			// Стандартный реквизит НомерСтроки
			Попытка
				ПутьНС = ПутьКДанным + ".НомерСтроки";
				ПерНС = ПолучитьКраткуюСтруктуруПеременной(Значение.НомерСтроки, "НомерСтроки", ПутьНС, КэшСсылок);
				Дочерние.Вставить(НовыйИдентификаторПеременной(), ПерНС);
			Исключение
			КонецПопытки;
			// Реквизиты из метаданных
			Для Каждого Реквизит Из МетаданныеТипа.Реквизиты Цикл
				ИмяРеквизита = Реквизит.Имя;
				ПутьРеквизита = ПутьКДанным + "." + ИмяРеквизита;
				Попытка
					ЗначениеРеквизита = Значение[ИмяРеквизита];
				Исключение
					Продолжить;
				КонецПопытки;
				Переменная = ПолучитьКраткуюСтруктуруПеременной(ЗначениеРеквизита, ИмяРеквизита, ПутьРеквизита, КэшСсылок);
				Дочерние.Вставить(НовыйИдентификаторПеременной(), Переменная);
			КонецЦикла;
			Возврат Дочерние;
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	Возврат Неопределено;
	
КонецФункции

// Получает описание структуры для табло.
Функция ПолучитьОписаниеСтруктуры(Структура, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Для Каждого КлючЗначение Из Структура Цикл
		ПутьЭлемента = ПутьКДанным + "." + КлючЗначение.Ключ;
		Переменная = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Значение, КлючЗначение.Ключ, ПутьЭлемента, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание соответствия для табло.
Функция ПолучитьОписаниеСоответствия(Соответствие, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Для Каждого КлючЗначение Из Соответствие Цикл
		КлючСтрока = СтрЗаменить(Строка(КлючЗначение.Ключ), """", "&quote;");
		ПутьЭлемента = ПутьКДанным + "[&quote;" + КлючСтрока + "&quote;]";
		Переменная = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Значение, КлючСтрока, ПутьЭлемента, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание индексированной коллекции (Массив, СписокЗначений, ТаблицаЗначений, КоллекцияСтрокДерева) для табло.
Функция ПолучитьОписаниеИндексированнойКоллекции(Коллекция, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	Индекс = 0;
	
	Для Каждого Элемент Из Коллекция Цикл
		Имя = Формат(Индекс, "ЧН=; ЧГ=0");
		ПутьЭлемента = ПутьКДанным + "[" + Имя + "]";
		Переменная = ПолучитьКраткуюСтруктуруПеременной(Элемент, Имя, ПутьЭлемента, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание выгруженной таблицы с полным раскрытием строк и колонок.
// Используется для табличных частей и других коллекций, поддерживающих метод Выгрузить().
// В отличие от ПолучитьОписаниеИндексированнойКоллекции, формирует дочерние элементы строк
// сразу (eager), чтобы JS мог отрисовать табличное представление.
//
// Параметры:
//   ТЗ - ТаблицаЗначений - выгруженная таблица значений
//   ПутьКДанным - Строка - путь к данным
//   КэшСсылок - Соответствие - кэш ссылок
//
// Возвращаемое значение:
//   Структура - дочерние элементы (строки с колонками)
//
Функция ПолучитьОписаниеВыгруженнойТаблицы(ТЗ, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Для Индекс = 0 По ТЗ.Количество() - 1 Цикл
		
		СтрокаТЗ = ТЗ[Индекс];
		Имя = Формат(Индекс, "ЧН=; ЧГ=0");
		ПутьСтроки = ПутьКДанным + "[" + Имя + "]";
		
		// Создаём узел строки
		Переменная = Новый Структура;
		Переменная.Вставить("label", Имя);
		Попытка
			Переменная.Вставить("value", Строка(СтрокаТЗ));
		Исключение
			Переменная.Вставить("value", Строка(ТипЗнч(СтрокаТЗ)));
		КонецПопытки;
		Переменная.Вставить("type", Строка(ТипЗнч(СтрокаТЗ)));
		Переменная.Вставить("path", ПутьСтроки);
		Переменная.Вставить("class", "");
		
		// Заполняем колонки строки
		ДочерниеСтроки = Новый Структура;
		Для Каждого Колонка Из ТЗ.Колонки Цикл
			ЗначениеКолонки = СтрокаТЗ[Колонка.Имя];
			ПутьКолонки = ПутьСтроки + "." + Колонка.Имя;
			ПерКолонки = ПолучитьКраткуюСтруктуруПеременной(ЗначениеКолонки, Колонка.Имя, ПутьКолонки, КэшСсылок);
			ДочерниеСтроки.Вставить(НовыйИдентификаторПеременной(), ПерКолонки);
		КонецЦикла;
		Переменная.Вставить("children", ДочерниеСтроки);
		
		Дочерние.Вставить(НовыйИдентификаторПеременной(), Переменная);
		
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание элемента списка значений для табло.
Функция ПолучитьОписаниеЭлементаСписка(Элемент, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	// Значение
	ПутьЗначения = ПутьКДанным + ".Значение";
	ПеременнаяЗначение = ПолучитьКраткуюСтруктуруПеременной(Элемент.Значение, "Значение", ПутьЗначения, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяЗначение);
	
	// Представление
	ПутьПредставления = ПутьКДанным + ".Представление";
	ПеременнаяПредставление = ПолучитьКраткуюСтруктуруПеременной(Элемент.Представление, "Представление", ПутьПредставления, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяПредставление);
	
	// Пометка
	ПутьПометки = ПутьКДанным + ".Пометка";
	ПеременнаяПометка = ПолучитьКраткуюСтруктуруПеременной(Элемент.Пометка, "Пометка", ПутьПометки, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяПометка);
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание строки таблицы значений для табло.
Функция ПолучитьОписаниеСтрокиТаблицы(СтрокаТаблицы, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Владелец = СтрокаТаблицы.Владелец();
	
	Для Каждого Колонка Из Владелец.Колонки Цикл
		ИмяКолонки = Колонка.Имя;
		ПутьКолонки = ПутьКДанным + "." + ИмяКолонки;
		Значение = СтрокаТаблицы[ИмяКолонки];
		Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяКолонки, ПутьКолонки, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание дерева значений для табло.
Функция ПолучитьОписаниеДереваЗначений(Дерево, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	// Добавляем ветку "Строки"
	ПутьСтрок = ПутьКДанным + ".Строки";
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Дерево.Строки, "Строки", ПутьСтрок, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), Переменная);
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание строки дерева значений для табло.
Функция ПолучитьОписаниеСтрокиДерева(СтрокаДерева, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Владелец = СтрокаДерева.Владелец();
	
	// Добавляем колонки
	Если ТипЗнч(Владелец) = Тип("ДеревоЗначений") Тогда
		Колонки = Владелец.Колонки;
	Иначе
		Колонки = Владелец.Владелец().Колонки;
	КонецЕсли;
	
	Для Каждого Колонка Из Колонки Цикл
		ИмяКолонки = Колонка.Имя;
		ПутьКолонки = ПутьКДанным + "." + ИмяКолонки;
		Значение = СтрокаДерева[ИмяКолонки];
		Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяКолонки, ПутьКолонки, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
	КонецЦикла;
	
	// Добавляем вложенные строки
	Если СтрокаДерева.Строки.Количество() > 0 Тогда
		ПутьСтрок = ПутьКДанным + ".Строки";
		Переменная = ПолучитьКраткуюСтруктуруПеременной(СтрокаДерева.Строки, "Строки", ПутьСтрок, КэшСсылок);
		Дочерние.Вставить(НовыйИдентификаторПеременной(), Переменная);
	КонецЕсли;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание КлючИЗначение для табло.
Функция ПолучитьОписаниеКлючаИЗначения(КлючЗначение, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	// Ключ
	ПутьКлюча = ПутьКДанным + ".Ключ";
	ПеременнаяКлюч = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Ключ, "Ключ", ПутьКлюча, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяКлюч);
	
	// Значение  
	ПутьЗначения = ПутьКДанным + ".Значение";
	ПеременнаяЗначение = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Значение, "Значение", ПутьЗначения, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяЗначение);
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание Запроса для табло.
Функция ПолучитьОписаниеЗапроса(Запрос, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	// Текст запроса
	ПутьТекста = ПутьКДанным + ".Текст";
	ПеременнаяТекст = ПолучитьКраткуюСтруктуруПеременной(Запрос.Текст, "Текст", ПутьТекста, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяТекст);
	
	// Параметры
	ПутьПараметров = ПутьКДанным + ".Параметры";
	ПеременнаяПараметры = ПолучитьКраткуюСтруктуруПеременной(Запрос.Параметры, "Параметры", ПутьПараметров, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяПараметры);
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание ссылки для табло.
Функция ПолучитьОписаниеСсылки(Ссылка, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Попытка
		
		ОбъектМетаданных = Ссылка.Метаданные();
		
		// Стандартные реквизиты (Код, Наименование, Дата, Номер, ПометкаУдаления и т.д.)
		Для Каждого СтандартныйРеквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
			ИмяРеквизита = СтандартныйРеквизит.Имя;
			ПутьРеквизита = ПутьКДанным + "." + ИмяРеквизита;
			Попытка
				Значение = Ссылка[ИмяРеквизита];
			Исключение
				Продолжить;
			КонецПопытки;
			Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяРеквизита, ПутьРеквизита, КэшСсылок);
			ИдентификаторПеременной = НовыйИдентификаторПеременной();
			Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		КонецЦикла;
		
		// Реквизиты
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			ИмяРеквизита = Реквизит.Имя;
			ПутьРеквизита = ПутьКДанным + "." + ИмяРеквизита;
			Попытка
				Значение = Ссылка[ИмяРеквизита];
			Исключение
				Продолжить;
			КонецПопытки;
			Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяРеквизита, ПутьРеквизита, КэшСсылок);
			ИдентификаторПеременной = НовыйИдентификаторПеременной();
			Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		КонецЦикла;
		
		// Табличные части
		Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			ИмяТЧ = ТабличнаяЧасть.Имя;
			ПутьТЧ = ПутьКДанным + "." + ИмяТЧ;
			Попытка
				Значение = Ссылка[ИмяТЧ];
			Исключение
				Продолжить;
			КонецПопытки;
			Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяТЧ, ПутьТЧ, КэшСсылок);
			Переменная.Вставить("type", "ТабличнаяЧасть");
			ИдентификаторПеременной = НовыйИдентификаторПеременной();
			Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		КонецЦикла;
		
	Исключение
		// Не удалось получить метаданные
	КонецПопытки;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание объекта (СправочникОбъект, ДокументОбъект и т.д.) для табло.
Функция ПолучитьОписаниеОбъекта(Объект, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Попытка
		
		ОбъектМетаданных = Объект.Метаданные();
		
		// Ссылка объекта
		Попытка
			СсылкаОбъекта = Объект.Ссылка;
			ПутьСсылки = ПутьКДанным + ".Ссылка";
			Переменная = ПолучитьКраткуюСтруктуруПеременной(СсылкаОбъекта, "Ссылка", ПутьСсылки, КэшСсылок);
			Дочерние.Вставить(НовыйИдентификаторПеременной(), Переменная);
		Исключение
			// У нового объекта может не быть ссылки
		КонецПопытки;
		
		// Стандартные реквизиты
		Для Каждого СтандартныйРеквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
			ИмяРеквизита = СтандартныйРеквизит.Имя;
			ПутьРеквизита = ПутьКДанным + "." + ИмяРеквизита;
			Попытка
				Значение = Объект[ИмяРеквизита];
			Исключение
				Продолжить;
			КонецПопытки;
			Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяРеквизита, ПутьРеквизита, КэшСсылок);
			ИдентификаторПеременной = НовыйИдентификаторПеременной();
			Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		КонецЦикла;
		
		// Реквизиты
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			ИмяРеквизита = Реквизит.Имя;
			ПутьРеквизита = ПутьКДанным + "." + ИмяРеквизита;
			Попытка
				Значение = Объект[ИмяРеквизита];
			Исключение
				Продолжить;
			КонецПопытки;
			Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяРеквизита, ПутьРеквизита, КэшСсылок);
			ИдентификаторПеременной = НовыйИдентификаторПеременной();
			Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		КонецЦикла;
		
		// Табличные части
		Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			ИмяТЧ = ТабличнаяЧасть.Имя;
			ПутьТЧ = ПутьКДанным + "." + ИмяТЧ;
			Попытка
				Значение = Объект[ИмяТЧ];
			Исключение
				Продолжить;
			КонецПопытки;
			Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяТЧ, ПутьТЧ, КэшСсылок);
			Переменная.Вставить("type", "ТабличнаяЧасть");
			ИдентификаторПеременной = НовыйИдентификаторПеременной();
			Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		КонецЦикла;
		
		// Признак модифицированности
		Попытка
			Модифицированность = Объект.Модифицированность();
			ПутьМодиф = ПутьКДанным + ".Модифицированность()";
			Переменная = ПолучитьКраткуюСтруктуруПеременной(Модифицированность, "Модифицированность()", ПутьМодиф, КэшСсылок);
			Дочерние.Вставить(НовыйИдентификаторПеременной(), Переменная);
		Исключение
			// Не у всех объектов есть метод Модифицированность
		КонецПопытки;
		
		// ЭтоНовый
		Попытка
			ЭтоНовый = Объект.ЭтоНовый();
			ПутьНовый = ПутьКДанным + ".ЭтоНовый()";
			Переменная = ПолучитьКраткуюСтруктуруПеременной(ЭтоНовый, "ЭтоНовый()", ПутьНовый, КэшСсылок);
			Дочерние.Вставить(НовыйИдентификаторПеременной(), Переменная);
		Исключение
			// Не у всех объектов есть метод ЭтоНовый
		КонецПопытки;
		
	Исключение
		// Не удалось получить метаданные
	КонецПопытки;
	
	Возврат Дочерние;
	
КонецФункции

#КонецОбласти

#Область ПользовательскиеОбъектыИМетоды

// Добавляет переменную в контекст редактора.
// Переменная будет доступна в автодополнении.
// Если передано сериализуемое значение (не ОписаниеТипов, не Тип, не Строка),
// оно также будет доступно в контексте отладчика как внешняя переменная ВМ.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//   ИмяПеременной - Строка - имя переменной (например, "_Заказ", "_Данные")
//   ТипИлиЗначение - ОписаниеТипов, Тип, Строка, Произвольный - тип переменной:
//                   * ОписаниеТипов - используется первый подходящий тип (только подсказки)
//                   * Тип - тип напрямую (только подсказки)
//                   * Строка - полное имя типа ("Справочник.Номенклатура") (только подсказки)
//                   * Произвольный - тип определится по значению, значение будет
//                     доступно в отладчике (подсказки + контекст отладки)
//   Описание - Строка - описание переменной для подсказки контекста
//
// Пример:
//   // Вариант 1: По описанию типов (только подсказки, без значения в отладчике)
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Товар", 
//       Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
//   
//   // Вариант 2: По типу (только подсказки)
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Данные", 
//       Тип("Структура"));
//
//   // Вариант 3: По имени типа (только подсказки)
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Клиент", 
//       "Справочник.Контрагенты");
//   
//   // Вариант 4: По значению - тип определится автоматически,
//   // значение будет доступно в контексте отладчика
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Клиент", СсылкаНаКонтрагента);
//
//   // Вариант 5: Соответствие - значение будет доступно в отладчике
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Настройки", МоёСоответствие);
//
//   // Вариант 6: Без типа - просто переменная без свойств
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Результат");
//
//   // Вариант 7: С описанием для подсказки
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "Результат", 
//       Новый Соответствие, "Возврат результата обработки");
//
Процедура ДобавитьПеременную(Форма, ИмяПеременной, ТипИлиЗначение = Неопределено, Описание = "") Экспорт
	
	// Получаем текущие переменные из JSON
	Переменные = ПрочитатьJSONПеременных(Форма);
	
	// Определяем ссылку на тип
	СсылкаНаТип = ОпределитьСсылкуНаТип(ТипИлиЗначение);
	
	// Создаём описание переменной
	Переменная = Новый Структура("properties", Новый Структура);
	
	Если ЗначениеЗаполнено(СсылкаНаТип) Тогда
		Переменная.Вставить("ref", СсылкаНаТип);
	КонецЕсли;
	
	Переменные.Вставить(ИмяПеременной, Переменная);
	
	// Сохраняем обратно в JSON
	СохранитьJSONПеременных(Форма, Переменные);
	
	// Сохраняем значение переменной для контекста отладчика
	// (для сериализуемых значений: соответствия, ссылки на объекты и т.д.)
	Если ТипИлиЗначение <> Неопределено
		И ТипЗнч(ТипИлиЗначение) <> Тип("ОписаниеТипов")
		И ТипЗнч(ТипИлиЗначение) <> Тип("Тип")
		И ТипЗнч(ТипИлиЗначение) <> Тип("Строка") Тогда
		СохранитьЗначениеПеременной(Форма, ИмяПеременной, ТипИлиЗначение);
	КонецЕсли;
	
	// Сохраняем описание переменной для подсказки контекста
	Попытка
		Параметры = Форма.конс_СтруктураПараметровРедактораКода;
		Если Параметры.Свойство("ОписанияПеременных") Тогда
			Параметры.ОписанияПеременных.Вставить(ИмяПеременной,
				Новый Структура("Тип, Описание", ОпределитьИмяТипа(ТипИлиЗначение), Описание));
		КонецЕсли;
	Исключение
		// Структура не инициализирована
	КонецПопытки;
	
	// Обновляем подсказку контекста
	ОбновитьПодсказкуРедактора(Форма);
	
КонецПроцедуры

// Добавляет функцию в контекст редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//   ИмяФункции - Строка - имя функции
//   Описание - Строка - описание функции
//   Параметры - Массив, Неопределено - массив параметров (см. НовыйПараметрФункции)
//   ТипВозврата - Строка - тип возвращаемого значения
//
// Пример:
//   // Функция без параметров:
//   конс_ПодключаемаяКонсольСервер.ДобавитьФункциюВКонтекст(Форма, 
//       "ПолучитьТекущегоПользователя", 
//       "Возвращает текущего пользователя");
//
//   // Функция с параметрами:
//   Параметры = Новый Массив;
//   Параметры.Добавить(конс_ПодключаемаяКонсольСервер.НовыйПараметрФункции("Сумма", "Число", "Сумма заказа"));
//   Параметры.Добавить(конс_ПодключаемаяКонсольСервер.НовыйПараметрФункции("ПроцентСкидки", "Число", "Процент скидки"));
//   конс_ПодключаемаяКонсольСервер.ДобавитьФункциюВКонтекст(Форма,
//       "ВычислитьСкидку",
//       "Вычисляет скидку для клиента",
//       Параметры,
//       "Число");
//
Процедура ДобавитьФункциюВКонтекст(Форма, ИмяФункции, Описание = "", Параметры = Неопределено, ТипВозврата = "") Экспорт
	
	// Получаем текущие функции из JSON
	Функции = ПрочитатьJSONФункций(Форма);
	
	// Создаём описание функции в формате редактора
	Функция_ = Новый Структура;
	Функция_.Вставить("name", ИмяФункции);
	
	Если ЗначениеЗаполнено(Описание) Тогда
		Функция_.Вставить("description", Описание);
	КонецЕсли;
	
	// Формируем сигнатуру из параметров
	СтрокаПараметров = "(";
	ОписанияПараметров = Новый Структура;
	
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		ЧастиПараметров = Новый Массив;
		Для Каждого Параметр Из Параметры Цикл
			ИмяПараметра = Параметр.Имя;
			ТипПараметра = Параметр.Тип;
			ОписаниеПараметра = "";
			Обязательный = Истина;
			
			Если Параметр.Свойство("Описание") Тогда
				ОписаниеПараметра = Параметр.Описание;
			КонецЕсли;
			
			Если Параметр.Свойство("Обязательный") Тогда
				Обязательный = Параметр.Обязательный;
			КонецЕсли;
			
			// Формируем часть сигнатуры: "Имя: Тип" или "Имя?: Тип"
			Если Обязательный Тогда
				ЧастиПараметров.Добавить(ИмяПараметра + ": " + ТипПараметра);
			Иначе
				ЧастиПараметров.Добавить(ИмяПараметра + "?: " + ТипПараметра);
			КонецЕсли;
			
			// Добавляем описание параметра
			Если ЗначениеЗаполнено(ОписаниеПараметра) Тогда
				ОписанияПараметров.Вставить(ИмяПараметра, ОписаниеПараметра);
			КонецЕсли;
		КонецЦикла;
		
		СтрокаПараметров = СтрокаПараметров + СтрСоединить(ЧастиПараметров, ", ");
	КонецЕсли;
	
	СтрокаПараметров = СтрокаПараметров + ")";
	
	// Добавляем тип возврата
	Если ЗначениеЗаполнено(ТипВозврата) Тогда
		СтрокаПараметров = СтрокаПараметров + ": " + ТипВозврата;
	КонецЕсли;
	
	// Формируем сигнатуру
	СигнатураПоУмолчанию = Новый Структура;
	СигнатураПоУмолчанию.Вставить("СтрокаПараметров", СтрокаПараметров);
	СигнатураПоУмолчанию.Вставить("Параметры", ОписанияПараметров);
	Функция_.Вставить("signature", Новый Структура("default", СигнатураПоУмолчанию));
	
	Функции.Вставить(ИмяФункции, Функция_);
	
	// Сохраняем обратно в JSON
	СохранитьJSONФункций(Форма, Функции);
	
	// Обновляем подсказку контекста
	ОбновитьПодсказкуРедактора(Форма);
	
КонецПроцедуры

// Создаёт описание параметра функции для ДобавитьФункциюВКонтекст.
// 
// Параметры:
//   Имя - Строка - имя параметра
//   Тип - Строка - тип параметра (Число, Строка, Булево, СправочникСсылка и т.д.)
//   Описание - Строка - описание параметра
//   Обязательный - Булево - является ли параметр обязательным (по умолчанию Истина)
//
// Возвращаемое значение:
//   Структура - описание параметра
//
// Пример:
//   Параметры = Новый Массив;
//   Параметры.Добавить(конс_ПодключаемаяКонсольСервер.НовыйПараметрФункции("Сумма", "Число", "Сумма заказа"));
//   Параметры.Добавить(конс_ПодключаемаяКонсольСервер.НовыйПараметрФункции("Скидка", "Число", "Процент", Ложь));
//
Функция НовыйПараметрФункции(Имя, Тип, Описание = "", Обязательный = Истина) Экспорт
	
	Возврат Новый Структура("Имя, Тип, Описание, Обязательный", Имя, Тип, Описание, Обязательный);
	
КонецФункции

// Получает JSON пользовательских переменных для загрузки в редактор.
// Вызывается автоматически при инициализации, но можно вызвать вручную.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//
// Возвращаемое значение:
//   Строка - JSON для передачи в updateMetadata
//
Функция ПолучитьJSONПеременных(Форма) Экспорт
	
	Возврат ПолучитьJSONДляРедактора(Форма, "JSONПеременных", "customObjects");
	
КонецФункции

// Получает JSON пользовательских функций для загрузки в редактор.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//
// Возвращаемое значение:
//   Строка - JSON для передачи в updateCustomFunctions
//
Функция ПолучитьJSONФункций(Форма) Экспорт
	
	Возврат ПолучитьJSONДляРедактора(Форма, "JSONФункций", "customFunctions");
	
КонецФункции

// Универсальная функция получения JSON из структуры параметров для передачи в редактор.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоля - Строка - имя поля в структуре (JSONПеременных, JSONФункций, JSONСниппетов)
//   КлючОбертки - Строка - ключ обёртки JSON (customObjects, customFunctions, snippets)
//
// Возвращаемое значение:
//   Строка - JSON с обёрткой для передачи в редактор
//
Функция ПолучитьJSONДляРедактора(Форма, ИмяПоля, КлючОбертки)
	
	Попытка
		Параметры = Форма.конс_СтруктураПараметровРедактораКода;
		Если Параметры.Свойство(ИмяПоля) И ЗначениеЗаполнено(Параметры[ИмяПоля]) Тогда
			Данные = Параметры[ИмяПоля];
			Если СтрНайти(Данные, КлючОбертки) = 0 Тогда
				Возврат СтрШаблон("{""%1"":%2}", КлючОбертки, Данные);
			КонецЕсли;
			Возврат Данные;
		КонецЕсли;
	Исключение
		// Структура не инициализирована
	КонецПопытки;
	
	Возврат "";
	
КонецФункции

// Читает переменные из JSON поля структуры параметров.
Функция ПрочитатьJSONПеременных(Форма)
	
	Возврат ПрочитатьJSONПоляСтруктуры(Форма, "JSONПеременных");
	
КонецФункции

// Сохраняет переменные в JSON поле структуры параметров.
Процедура СохранитьJSONПеременных(Форма, Переменные)
	
	ЗаписатьJSONВПолеСтруктуры(Форма, "JSONПеременных", Переменные);
	
КонецПроцедуры

// Сохраняет значение переменной для контекста отладчика.
// Значение будет доступно как внешняя переменная при отладке в виртуальной машине.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//   ИмяПеременной - Строка - имя переменной
//   Значение - Произвольный - сериализуемое значение переменной
//
Процедура СохранитьЗначениеПеременной(Форма, ИмяПеременной, Значение)
	
	Попытка
		Параметры = Форма.конс_СтруктураПараметровРедактораКода;
		
		// Получаем существующее соответствие из временного хранилища или создаём новое
		ЗначенияПеременных = Неопределено;
		Если Параметры.Свойство("АдресЗначенийПеременных")
			И ЗначениеЗаполнено(Параметры.АдресЗначенийПеременных) Тогда
			ЗначенияПеременных = ПолучитьИзВременногоХранилища(Параметры.АдресЗначенийПеременных);
		КонецЕсли;
		
		Если ТипЗнч(ЗначенияПеременных) <> Тип("Соответствие") Тогда
			ЗначенияПеременных = Новый Соответствие;
		КонецЕсли;
		
		ЗначенияПеременных.Вставить(ВРег(ИмяПеременной), Значение);
		
		// Помещаем обратно во временное хранилище
		Если ЗначениеЗаполнено(Параметры.АдресЗначенийПеременных) Тогда
			ПоместитьВоВременноеХранилище(ЗначенияПеременных, Параметры.АдресЗначенийПеременных);
		Иначе
			Параметры.АдресЗначенийПеременных = ПоместитьВоВременноеХранилище(
				ЗначенияПеременных, Форма.УникальныйИдентификатор);
		КонецЕсли;
	Исключение
		// Структура не инициализирована или ошибка работы с хранилищем
	КонецПопытки;
	
КонецПроцедуры

// Возвращает соответствие значений переменных для контекста отладчика.
// Значения были ранее сохранены через ДобавитьПеременную при передаче сериализуемых объектов.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//
// Возвращаемое значение:
//   Соответствие - имена переменных (в верхнем регистре) и их значения
//
Функция ПолучитьЗначенияПеременных(Форма) Экспорт
	
	Попытка
		Параметры = Форма.конс_СтруктураПараметровРедактораКода;
		Если Параметры.Свойство("АдресЗначенийПеременных")
			И ЗначениеЗаполнено(Параметры.АдресЗначенийПеременных) Тогда
			ЗначенияПеременных = ПолучитьИзВременногоХранилища(Параметры.АдресЗначенийПеременных);
			Если ТипЗнч(ЗначенияПеременных) = Тип("Соответствие") Тогда
				Возврат ЗначенияПеременных;
			КонецЕсли;
		КонецЕсли;
	Исключение
		// Структура не инициализирована или ошибка работы с хранилищем
	КонецПопытки;
	
	Возврат Новый Соответствие;
	
КонецФункции

// Читает функции из JSON поля структуры параметров.
Функция ПрочитатьJSONФункций(Форма)
	
	Возврат ПрочитатьJSONПоляСтруктуры(Форма, "JSONФункций");
	
КонецФункции

// Сохраняет функции в JSON поле структуры параметров.
Процедура СохранитьJSONФункций(Форма, Функции)
	
	ЗаписатьJSONВПолеСтруктуры(Форма, "JSONФункций", Функции);
	
КонецПроцедуры

// Универсальная функция чтения JSON из поля структуры параметров.
Функция ПрочитатьJSONПоляСтруктуры(Форма, ИмяПоля)
	
	Попытка
		Параметры = Форма.конс_СтруктураПараметровРедактораКода;
		Если Не Параметры.Свойство(ИмяПоля) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Параметры[ИмяПоля]) Тогда
			Чтение = Новый ЧтениеJSON;
			Чтение.УстановитьСтроку(Параметры[ИмяПоля]);
			Возврат ПрочитатьJSON(Чтение);
		КонецЕсли;
	Исключение
		// Структура не инициализирована или ошибка разбора
	КонецПопытки;
	
	Возврат Новый Структура;
	
КонецФункции

// Универсальная процедура записи JSON в поле структуры параметров.
Процедура ЗаписатьJSONВПолеСтруктуры(Форма, ИмяПоля, Данные)
	
	Попытка
		Параметры = Форма.конс_СтруктураПараметровРедактораКода;
		Если Не Параметры.Свойство(ИмяПоля) Тогда
			ВызватьИсключение СтрШаблон("Поле %1 не найдено. Сначала вызовите ИнициализироватьРедактор.", ИмяПоля);
		КонецЕсли;
		
		Файл = Новый ЗаписьJSON;
		Файл.УстановитьСтроку();
		ЗаписатьJSON(Файл, Данные);
		Параметры[ИмяПоля] = Файл.Закрыть();
		Форма.конс_СтруктураПараметровРедактораКода = Параметры;
	Исключение
		ВызватьИсключение СтрШаблон("Структура параметров не инициализирована. Сначала вызовите ИнициализироватьРедактор.");
	КонецПопытки;
	
КонецПроцедуры

// Определяет человекочитаемое имя типа для подсказки контекста.
//
// Параметры:
//   ТипИлиЗначение - ОписаниеТипов, Тип, Строка, Произвольный - тип или значение
//
// Возвращаемое значение:
//   Строка - имя типа или пустая строка
//
Функция ОпределитьИмяТипа(ТипИлиЗначение)
	
	Если ТипИлиЗначение = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	ТипПараметра = ТипЗнч(ТипИлиЗначение);
	
	Если ТипПараметра = Тип("ОписаниеТипов") Тогда
		МассивТипов = ТипИлиЗначение.Типы();
		Если МассивТипов.Количество() > 0 Тогда
			Возврат Строка(МассивТипов[0]);
		КонецЕсли;
		Возврат "";
	КонецЕсли;
	
	Если ТипПараметра = Тип("Тип") Тогда
		Возврат Строка(ТипИлиЗначение);
	КонецЕсли;
	
	Если ТипПараметра = Тип("Строка") Тогда
		Возврат ТипИлиЗначение;
	КонецЕсли;
	
	Возврат Строка(ТипЗнч(ТипИлиЗначение));
	
КонецФункции

// Обновляет подсказку контекста редактора на основе добавленных переменных и функций.
// Формат строки подсказки: "Имя - тип - описание" для переменных, "Имя() - описание" для функций.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//
Процедура ОбновитьПодсказкуРедактора(Форма)
	
	Попытка
		Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	Исключение
		Возврат;
	КонецПопытки;
	
	ЧастиПодсказки = Новый Массив;
	
	// Переменные
	Если Параметры.Свойство("ОписанияПеременных") Тогда
		Для Каждого КлючЗначение Из Параметры.ОписанияПеременных Цикл
			СтрокаПодсказки = КлючЗначение.Ключ;
			Данные = КлючЗначение.Значение;
			Если ЗначениеЗаполнено(Данные.Тип) Тогда
				СтрокаПодсказки = СтрокаПодсказки + " - " + Данные.Тип;
			КонецЕсли;
			Если ЗначениеЗаполнено(Данные.Описание) Тогда
				СтрокаПодсказки = СтрокаПодсказки + " - " + Данные.Описание;
			КонецЕсли;
			ЧастиПодсказки.Добавить(СтрокаПодсказки);
		КонецЦикла;
	КонецЕсли;
	
	// Функции
	Функции = ПрочитатьJSONФункций(Форма);
	Для Каждого КлючЗначение Из Функции Цикл
		СтрокаПодсказки = КлючЗначение.Ключ + "()";
		Данные = КлючЗначение.Значение;
		ОписаниеФункции = "";
		Если ТипЗнч(Данные) = Тип("Соответствие") Тогда
			ОписаниеФункции = Данные["description"];
		ИначеЕсли ТипЗнч(Данные) = Тип("Структура") Тогда
			Данные.Свойство("description", ОписаниеФункции);
		КонецЕсли;
		Если ЗначениеЗаполнено(ОписаниеФункции) Тогда
			СтрокаПодсказки = СтрокаПодсказки + " - " + ОписаниеФункции;
		КонецЕсли;
		ЧастиПодсказки.Добавить(СтрокаПодсказки);
	КонецЦикла;
	
	Если ЧастиПодсказки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Устанавливаем подсказку на элемент редактора
	ИмяПоляHTML = Параметры.ИмяПоляHTML;
	Элемент = Форма.Элементы.Найти(ИмяПоляHTML);
	Если Элемент <> Неопределено Тогда
		Элемент.РасширеннаяПодсказка.Заголовок = СтрСоединить(ЧастиПодсказки, Символы.ПС);
	КонецЕсли;
	
КонецПроцедуры

// Универсальная функция определения ссылки на тип для редактора.
// 
// Параметры:
//   ТипИлиЗначение - ОписаниеТипов, Тип, Строка, Произвольный
//
// Возвращаемое значение:
//   Строка - ссылка на тип для редактора или пустая строка
//
Функция ОпределитьСсылкуНаТип(ТипИлиЗначение)
	
	Если ТипИлиЗначение = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	ТипПараметра = ТипЗнч(ТипИлиЗначение);
	
	// Вариант 1: ОписаниеТипов
	Если ТипПараметра = Тип("ОписаниеТипов") Тогда
		Возврат ОпределитьСсылкуПоОписаниюТипов(ТипИлиЗначение);
	КонецЕсли;
	
	// Вариант 2: Тип
	Если ТипПараметра = Тип("Тип") Тогда
		Возврат ОпределитьСсылкуПоТипу(ТипИлиЗначение);
	КонецЕсли;
	
	// Вариант 3: Строка (имя типа)
	Если ТипПараметра = Тип("Строка") И ЗначениеЗаполнено(ТипИлиЗначение) Тогда
		Возврат ПреобразоватьИмяТипаВСсылку(ТипИлиЗначение);
	КонецЕсли;
	
	// Вариант 4: Произвольное значение - определяем тип по значению
	Возврат ОпределитьСсылкуПоЗначению(ТипИлиЗначение);
	
КонецФункции

// Определяет ссылку на тип по ОписаниюТипов.
Функция ОпределитьСсылкуПоОписаниюТипов(ОписаниеТипов)
	
	МассивТипов = ОписаниеТипов.Типы();
	
	Для Каждого ТекущийТип Из МассивТипов Цикл
		Ссылка = ОпределитьСсылкуПоТипу(ТекущийТип);
		Если ЗначениеЗаполнено(Ссылка) Тогда
			Возврат Ссылка;
		КонецЕсли;
	КонецЦикла;
	
	// Проверяем общие типы
	Если МассивТипов.Количество() = 1 Тогда
		ИмяТипа = Строка(МассивТипов[0]);
		Возврат СоответствиеОбщихТипов().Получить(ИмяТипа);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Определяет ссылку на тип по объекту Тип.
Функция ОпределитьСсылкуПоТипу(Тип_)
	
	// Сначала проверяем общие типы
	ИмяТипа = Строка(Тип_);
	СсылкаОбщегоТипа = СоответствиеОбщихТипов().Получить(ИмяТипа);
	Если ЗначениеЗаполнено(СсылкаОбщегоТипа) Тогда
		Возврат СсылкаОбщегоТипа;
	КонецЕсли;
	
	// Пробуем получить метаданные для ссылочных типов
	Попытка
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип_);
		
		Если ОбъектМетаданных <> Неопределено Тогда
			ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			Возврат ПреобразоватьИмяТипаВСсылку(ПолноеИмя);
		КонецЕсли;
	Исключение
		// Не ссылочный тип
	КонецПопытки;
	
	Возврат "";
	
КонецФункции

// Возвращает соответствие общих типов 1С на типы редактора.
// Формат ссылок: classes.ИмяКласса (на русском языке)
// ВАЖНО: Строка(Тип("ТаблицаЗначений")) может возвращать как "ТаблицаЗначений", 
// так и "Таблица значений" (с пробелом) в зависимости от версии платформы.
Функция СоответствиеОбщихТипов()
	
	Соответствие = Новый Соответствие;
	
	// Коллекции - имеют методы в редакторе
	// Добавляем варианты с пробелами и без
	Соответствие.Вставить("Структура", "classes.Структура");
	Соответствие.Вставить("ФиксированнаяСтруктура", "classes.ФиксированнаяСтруктура");
	Соответствие.Вставить("Фиксированная структура", "classes.ФиксированнаяСтруктура");
	Соответствие.Вставить("Соответствие", "classes.Соответствие");
	Соответствие.Вставить("ФиксированноеСоответствие", "classes.ФиксированноеСоответствие");
	Соответствие.Вставить("Фиксированное соответствие", "classes.ФиксированноеСоответствие");
	Соответствие.Вставить("Массив", "classes.Массив");
	Соответствие.Вставить("ФиксированныйМассив", "classes.ФиксированныйМассив");
	Соответствие.Вставить("Фиксированный массив", "classes.ФиксированныйМассив");
	Соответствие.Вставить("СписокЗначений", "classes.СписокЗначений");
	Соответствие.Вставить("Список значений", "classes.СписокЗначений");
	Соответствие.Вставить("ТаблицаЗначений", "classes.ТаблицаЗначений");
	Соответствие.Вставить("Таблица значений", "classes.ТаблицаЗначений");
	Соответствие.Вставить("ДеревоЗначений", "classes.ДеревоЗначений");
	Соответствие.Вставить("Дерево значений", "classes.ДеревоЗначений");
	Соответствие.Вставить("КоллекцияКолонокТаблицыЗначений", "classes.КоллекцияКолонокТаблицыЗначений");
	Соответствие.Вставить("Коллекция колонок таблицы значений", "classes.КоллекцияКолонокТаблицыЗначений");
	Соответствие.Вставить("КоллекцияКолонокДереваЗначений", "classes.КоллекцияКолонокДереваЗначений");
	Соответствие.Вставить("Коллекция колонок дерева значений", "classes.КоллекцияКолонокДереваЗначений");
	
	// Работа с данными
	Соответствие.Вставить("Запрос", "classes.Запрос");
	Соответствие.Вставить("РезультатЗапроса", "classes.РезультатЗапроса");
	Соответствие.Вставить("Результат запроса", "classes.РезультатЗапроса");
	Соответствие.Вставить("ВыборкаИзРезультатаЗапроса", "classes.ВыборкаИзРезультатаЗапроса");
	Соответствие.Вставить("Выборка из результата запроса", "classes.ВыборкаИзРезультатаЗапроса");
	Соответствие.Вставить("ДвоичныеДанные", "classes.ДвоичныеДанные");
	Соответствие.Вставить("Двоичные данные", "classes.ДвоичныеДанные");
	
	// HTTP
	Соответствие.Вставить("HTTPЗапрос", "classes.HTTPЗапрос");
	Соответствие.Вставить("HTTP запрос", "classes.HTTPЗапрос");
	Соответствие.Вставить("HTTPОтвет", "classes.HTTPОтвет");
	Соответствие.Вставить("HTTP ответ", "classes.HTTPОтвет");
	Соответствие.Вставить("HTTPСоединение", "classes.HTTPСоединение");
	Соответствие.Вставить("HTTP соединение", "classes.HTTPСоединение");
	
	// JSON/XML
	Соответствие.Вставить("ЗаписьJSON", "classes.ЗаписьJSON");
	Соответствие.Вставить("Запись JSON", "classes.ЗаписьJSON");
	Соответствие.Вставить("ЧтениеJSON", "classes.ЧтениеJSON");
	Соответствие.Вставить("Чтение JSON", "classes.ЧтениеJSON");
	Соответствие.Вставить("ЗаписьXML", "classes.ЗаписьXML");
	Соответствие.Вставить("Запись XML", "classes.ЗаписьXML");
	Соответствие.Вставить("ЧтениеXML", "classes.ЧтениеXML");
	Соответствие.Вставить("Чтение XML", "classes.ЧтениеXML");
	
	// Файлы и потоки
	Соответствие.Вставить("Файл", "classes.Файл");
	Соответствие.Вставить("ТекстовыйДокумент", "classes.ТекстовыйДокумент");
	Соответствие.Вставить("Текстовый документ", "classes.ТекстовыйДокумент");
	Соответствие.Вставить("ТабличныйДокумент", "classes.ТабличныйДокумент");
	Соответствие.Вставить("Табличный документ", "classes.ТабличныйДокумент");
	
	// Примитивы (без автодополнения свойств)
	Соответствие.Вставить("Строка", "");
	Соответствие.Вставить("Число", "");
	Соответствие.Вставить("Булево", "");
	Соответствие.Вставить("Дата", "");
	
	Возврат Соответствие;
	
КонецФункции

// Преобразует полное имя типа 1С в ссылку для редактора.
Функция ПреобразоватьИмяТипаВСсылку(ПолноеИмяТипа)
	
	Части = СтрРазделить(ПолноеИмяТипа, ".");
	
	Если Части.Количество() < 2 Тогда
		Возврат "";
	КонецЕсли;
	
	ТипКоллекции = НРег(Части[0]);
	ИмяОбъекта = Части[1];
	
	// Маппинг типов 1С на типы редактора
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("справочник", "catalogs");
	Соответствие.Вставить("документ", "documents");
	Соответствие.Вставить("перечисление", "enums");
	Соответствие.Вставить("регистрсведений", "infoRegs");
	Соответствие.Вставить("регистрнакопления", "accumRegs");
	Соответствие.Вставить("обработка", "dataProc");
	Соответствие.Вставить("отчет", "reports");
	
	ТипРедактора = Соответствие.Получить(ТипКоллекции);
	
	Если ТипРедактора = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат ТипРедактора + "." + ИмяОбъекта;
	
КонецФункции

// Определяет ссылку на тип по значению.
Функция ОпределитьСсылкуПоЗначению(Значение)
	
	ТипЗначения = ТипЗнч(Значение);
	
	// Делегируем определение ссылки единой функции,
	// которая проверяет и общие типы, и метаданные
	Возврат ОпределитьСсылкуПоТипу(ТипЗначения);
	
КонецФункции

#Область Сниппеты

// Добавляет сниппет (шаблон кода) в контекст редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//   Префикс - Строка - текст для вызова сниппета (например, "Если", "Для")
//   ТелоСниппета - Строка - код шаблона с плейсхолдерами ${1:название}
//   Описание - Строка - описание сниппета
//
// Примечание:
//   Плейсхолдеры: ${1:имя}, ${2:имя}, ${0:последний}
//   \n - перевод строки, \t - табуляция
//
// Пример:
//   // Простой сниппет
//   конс_ПодключаемаяКонсольСервер.ДобавитьСниппет(Форма, 
//       "Для", 
//       "Для ${1:Индекс} = ${2:0} По ${3:Количество} Цикл\n\t${0}\nКонецЦикла;",
//       "Цикл Для");
//
//   // Сниппет с вызовом функции
//   конс_ПодключаемаяКонсольСервер.ДобавитьСниппет(Форма,
//       "Запрос",
//       "Запрос = Новый Запрос;\nЗапрос.Текст = \"${1:SELECT}\";",
//       "Создание запроса");
//
Процедура ДобавитьСниппет(Форма, Префикс, ТелоСниппета, Описание = "") Экспорт
	
	// Получаем текущие сниппеты из JSON
	Сниппеты = ПрочитатьJSONСниппетов(Форма);
	
	// Создаём описание сниппета
	Сниппет = Новый Структура;
	Сниппет.Вставить("prefix", Префикс);
	Сниппет.Вставить("body", ТелоСниппета);
	
	Если ЗначениеЗаполнено(Описание) Тогда
		Сниппет.Вставить("description", Описание);
	КонецЕсли;
	
	Сниппеты.Вставить(Префикс, Сниппет);
	
	// Сохраняем обратно в JSON
	СохранитьJSONСниппетов(Форма, Сниппеты);
	
КонецПроцедуры

// Получает JSON сниппетов для загрузки в редактор.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//
// Возвращаемое значение:
//   Строка - JSON для передачи в updateSnippets
//
Функция ПолучитьJSONСниппетов(Форма) Экспорт
	
	Возврат ПолучитьJSONДляРедактора(Форма, "JSONСниппетов", "snippets");
	
КонецФункции

// Читает сниппеты из JSON поля структуры параметров.
Функция ПрочитатьJSONСниппетов(Форма)
	
	Возврат ПрочитатьJSONПоляСтруктуры(Форма, "JSONСниппетов");
	
КонецФункции

// Сохраняет сниппеты в JSON поле структуры параметров.
Процедура СохранитьJSONСниппетов(Форма, Сниппеты)
	
	ЗаписатьJSONВПолеСтруктуры(Форма, "JSONСниппетов", Сниппеты);
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

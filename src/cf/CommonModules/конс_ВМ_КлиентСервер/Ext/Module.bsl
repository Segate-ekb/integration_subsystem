// Модуль конс_ВМ_КлиентСервер
//
// Виртуальная машина (ВМ) для выполнения байткода, скомпилированного из BSL.
// Реализует стековый интерпретатор с поддержкой вложенных вызовов,
// обработки исключений (Попытка/Исключение), точек останова и пошаговой отладки.
//
// Архитектура ВМ:
//  - Стековая машина: операнды загружаются в стек, операции потребляют и помещают результат
//  - Состояние хранится в структуре «СостояниеВМ» (стек, стек вызовов, переменные, команды)
//  - Команды (байткод): массив структур {ОпКод, Аргумент}, выполняемых последовательно
//  - Диспетчеризация: простые встроенные функции — через Соответствие строк кода (СформироватьОбработчикиОпКодов),
//    сложные опкоды — через явный Если/ИначеЕсли (ВыполнитьОпКод)
#Область ПрограммныйИнтерфейс

// Создаёт корневую виртуальную машину на основе данных компиляции и параметров среды.
// Используется для запуска нового сеанса отладки.
//
// Параметры:
//  ДанныеКомпиляции - Структура - результат конс_КомпиляцияКлиентСервер.ВыполнитьКомпиляцию():
//    * КомандыВМ - Массив - массив команд виртуальной машины
//    * КонстантыВМ - Массив - массив констант программы
//    * МеткиВМ - Соответствие - соответствие меток и адресов
//    * ПеременныеВМ - Массив - массив переменных программы
//    * ПроцедурыФункцииВМ - Массив - массив описаний процедур/функций
//    * ТочкаВхода - Число - начальный адрес выполнения
//  ПараметрыСреды - Структура - контекст запуска:
//    * ИдентификаторФормы - Строка - UUID формы для хранилища
//    * АдресВМ - Строка - адрес во временном хранилище (пустой → создаётся)
//    * АдресПеременных - Строка - адрес переменных во временном хранилище (пустой → создаётся)
//    * АдресТаблицПерехода - Строка - адрес таблиц перехода
//    * ВариантВстроенногоЯзыка - Строка - вариант языка ("ru"/"en")
//    * ЗначенияВнешнихПеременных - Соответствие, Неопределено - значения внешних переменных
//
Процедура СоздатьВМ(ДанныеКомпиляции, ПараметрыСреды) Экспорт
	
	ВариантВстроенногоЯзыка = ПараметрыСреды.ВариантВстроенногоЯзыка;
	АдресВМ = ПараметрыСреды.АдресВМ;
	АдресПеременных = ПараметрыСреды.АдресПеременных;
	
	СостояниеВМ = НовоеСостояниеВМ(ДанныеКомпиляции, ПараметрыСреды.АдресТаблицПерехода,
		ВариантВстроенногоЯзыка);
	СостояниеВМ.Вставить("ЭтоСервер", ?(ТипЗнч(АдресВМ) = Тип("Строка"), Истина, Ложь));
	
	ИнициализироватьВнешниеПеременные(СостояниеВМ.Программа.Переменные,
		ПараметрыСреды.ЗначенияВнешнихПеременных);
	
	// Создаем структуру для хранения данных отладки
	ДанныеОтладки = Новый Соответствие;
	СоответствиеПеременных = Новый Соответствие;
	ДанныеОтладки.Вставить("Переменные", СоответствиеПеременных);
	ДанныеОтладки.Вставить("СтруктурыТипов", СостояниеВМ.СтруктурыТипов);
	
	// Размещаем данные во временном хранилище или используем напрямую
	Если ТипЗнч(АдресВМ) = Тип("Строка") Тогда
		Если Не ЗначениеЗаполнено(АдресВМ) Тогда
			ПараметрыСреды.АдресВМ = ПоместитьВоВременноеХранилище(СостояниеВМ, ПараметрыСреды.ИдентификаторФормы);
			ПараметрыСреды.АдресПеременных = ПоместитьВоВременноеХранилище(ДанныеОтладки, ПараметрыСреды.ИдентификаторФормы);
		Иначе
			ПоместитьВоВременноеХранилище(СостояниеВМ, АдресВМ);
			ПоместитьВоВременноеХранилище(ДанныеОтладки, АдресПеременных);
		КонецЕсли;
	Иначе
		ПараметрыСреды.АдресВМ = СостояниеВМ;
		ПараметрыСреды.АдресПеременных = ДанныеОтладки;
	КонецЕсли;
	
КонецПроцедуры

// Создаёт вложенную виртуальную машину для опкода Выполнить или вычисления выражения отладчика.
// Наследует разделяемое состояние (типы, ключи переменных, ключи подпрограмм) от исходной ВМ.
//
// Параметры:
//  ИсходнаяВМ - Структура - родительская ВМ (или контекст данных отладчика)
//  ДанныеКомпиляции - Структура - результат конс_КомпиляцияКлиентСервер.ВыполнитьКомпиляцию()
//
// Возвращаемое значение:
//  Структура - новая вложенная ВМ, готовая к выполнению
//
Функция СоздатьВложеннуюВМДляВыполнения(ИсходнаяВМ, ДанныеКомпиляции) Экспорт
	
	СостояниеВМ = НовоеСостояниеВМ(ДанныеКомпиляции, ИсходнаяВМ.АдресТаблицПерехода,
		ИсходнаяВМ.ВариантВстроенногоЯзыка, ИсходнаяВМ);
	
	СостояниеВМ.Вставить("ЭтоСервер", ИсходнаяВМ.ЭтоСервер);
	
	ИнициализироватьВнешниеПеременные(СостояниеВМ.Программа.Переменные, Неопределено);
	
	// Подготовка вложенного вызова
	СостояниеВМ.Сообщения = ИсходнаяВМ.Сообщения;
	СостояниеВМ.Ошибки = ИсходнаяВМ.Ошибки;
	СостояниеВМ.ОсновнаяВМ = ?(ИсходнаяВМ.ОсновнаяВМ = Неопределено, ИсходнаяВМ, ИсходнаяВМ.ОсновнаяВМ);
	
	// Копирование ключей переменных для вложенного вызова
	Для Каждого КлючЗначение Из ИсходнаяВМ.Индексы.КлючиПеременных Цикл
		СостояниеВМ.Индексы.КлючиПеременных.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
	КонецЦикла;
	
	ЗаполнитьКлючиПодпрограмм(СостояниеВМ.Индексы.КлючиЛокальныхПодпрограмм,
		СостояниеВМ.Программа.Подпрограммы);
	
	Возврат СостояниеВМ;
	
КонецФункции

// Продолжает выполнение отладки виртуальной машины
//
// Параметры:
//  АдресВМ - Строка, Структура - адрес ВМ во временном хранилище или структура ВМ
//  АдресПеременных - Строка - адрес переменных во временном хранилище
//  ОстановкаПоОшибке - Булево - флаг остановки при возникновении ошибки
//  СоответствиеТочекОстанова - Соответствие - соответствие точек останова
//
// Обрабатывает состояние остановки по ошибке при возобновлении
Процедура ОбработатьВозобновлениеПослеОшибки(ВМ)
	Если Не ВМ.Отладка.ОстановленоПоОшибке Тогда
		Возврат;
	КонецЕсли;
	
	Если ВМ.Стеки.СтекОшибок.Количество() > 0 Тогда
		// Ошибка перехвачена блоком Попытка — IP уже указывает на обработчик,
		// просто сбрасываем флаг и продолжаем выполнение
		ВМ.Отладка.ОстановленоПоОшибке = Ложь;
		Возврат;
	КонецЕсли;
	
	// Ошибка не перехвачена — завершаем отладку
	ВМ.ОтладкаЗавершена = Истина;
	ВМ.НомерСтрокиОстанова = 0;
	ВМ.Отладка.ОстановленоПоОшибке = Ложь;
КонецПроцедуры

// Выполняет одну команду с обработкой ошибок.
// Если есть СтекПопыток — исключение перехватывается и обрабатывается через
// РаскрутитьСтекВызовов + СтекОшибок (без рекурсии).
// Возвращает Истина если нужно остановить выполнение.
Функция ВыполнитьКомандуСОбработкойОшибок(ВМ, Стек, Команда, СтекПопыток, ОбработчикиОпКодов,
		АдресВМ, АдресПеременных, ОстановкаПоОшибке)
	Попытка
		Выполнить ОбработчикиОпКодов[Команда.ОпКод];
		Возврат Ложь;
	Исключение
		Если СтекПопыток.Количество() > 0 Тогда
			Возврат ОбработатьОшибкуВБлокеПопытки(ВМ, ИнформацияОбОшибке(), ОстановкаПоОшибке, АдресВМ, АдресПеременных);
		Иначе
			Возврат ОбработатьОшибкуВГлавномЦикле(ВМ, АдресВМ, АдресПеременных, ОстановкаПоОшибке, ИнформацияОбОшибке());
		КонецЕсли;
	КонецПопытки;
КонецФункции

// Проверяет завершение выполнения ВМ
// Возвращает Истина если нужно остановиться
Функция ПроверитьЗавершениеВМ(ВМ, АдресВМ, АдресПеременных, КоличествоКоманд, СоответствиеТочекОстанова)
	Если ВМ.ТекущаяКоманда < КоличествоКоманд Тогда
		Возврат СоответствиеТочекОстанова = Неопределено И СохранитьСостояниеВМ(ВМ, АдресВМ, АдресПеременных);
	КонецЕсли;
	
	Если АдресПеременных <> Неопределено Тогда
		СохранитьСостояниеВМ(ВМ, АдресВМ, АдресПеременных,, Истина);
	КонецЕсли;
	ЗавершитьОтладкуВМ(ВМ, АдресВМ);
	Возврат Истина;
КонецФункции

Процедура ПродолжитьОтладку(АдресВМ, АдресПеременных, ОстановкаПоОшибке, СоответствиеТочекОстанова = Неопределено, МаксимальнаяГлубинаОстановки = Неопределено) Экспорт
	
	Перем Стек;
	
	ВМ = ПолучитьВМИзАдреса(АдресВМ);
	
	ОбработатьВозобновлениеПослеОшибки(ВМ);
	
	ВМ.Отладка.ОстановкаПоОшибке = ОстановкаПоОшибке;
	
	КомандыВМ = ВМ.Программа.Команды;
	КоличествоКоманд = КомандыВМ.Количество();
	
	Если ВМ.ОтладкаЗавершена ИЛИ ВМ.ТекущаяКоманда >= КоличествоКоманд Тогда
		// Сохраняем состояние ВМ перед выходом (например, после завершения при ошибке без try/catch)
		Если ТипЗнч(АдресВМ) = Тип("Строка") Тогда
			ПоместитьВоВременноеХранилище(ВМ, АдресВМ);
		КонецЕсли;
		Возврат;
	КонецЕсли;
	Стек = ВМ.Стеки.Стек;
	СтекПопыток = ВМ.Стеки.СтекПопыток;
	ВМ.Вставить("СоответствиеТочекОстанова", СоответствиеТочекОстанова);
	ВМ.Отладка.МаксимальнаяГлубинаОстановки = МаксимальнаяГлубинаОстановки;
	ВМ.Вставить("ОбработчикиОпКодов", СформироватьОбработчикиОпКодов());
	ОбработчикиОпКодов = ВМ.ОбработчикиОпКодов;
	
	Пока ВМ.ТекущаяКоманда < КоличествоКоманд Цикл
		
		Команда = КомандыВМ[ВМ.ТекущаяКоманда];
		
		Если Команда.ОпКод = "НОМЕРСТРОКИ" Тогда
			Если ОбработатьНомерСтрокиВГлавномЦикле(ВМ, Стек, Команда, СоответствиеТочекОстанова, АдресПеременных, АдресВМ) Тогда
				Возврат;
			КонецЕсли;
		ИначеЕсли ВыполнитьКомандуСОбработкойОшибок(ВМ, Стек, Команда, СтекПопыток, ОбработчикиОпКодов,
				АдресВМ, АдресПеременных, ОстановкаПоОшибке) Тогда
			Возврат;
		КонецЕсли;
		
		Если ПроверитьЗавершениеВМ(ВМ, АдресВМ, АдресПеременных, КоличествоКоманд, СоответствиеТочекОстанова) Тогда
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
	// Защитное завершение: если цикл завершился естественным образом
	Если ВМ.ТекущаяКоманда >= КоличествоКоманд Тогда
		ЗавершитьОтладкуВМ(ВМ, АдресВМ);
	КонецЕсли;
	
КонецПроцедуры

// Завершает отладку виртуальной машины
//
// Параметры:
//  АдресВМ - Строка, Структура - адрес ВМ во временном хранилище или структура ВМ
//
Процедура ЗавершитьОтладку(АдресВМ) Экспорт
	
	ВМ = ПолучитьВМИзАдреса(АдресВМ);
	
	ЗавершитьОтладкуВМ(ВМ, АдресВМ);
	
КонецПроцедуры

// Получает текущее состояние виртуальной машины
//
// Параметры:
//  АдресВМ - Строка, Структура - адрес ВМ во временном хранилище или структура ВМ
//
// Возвращаемое значение:
//  Структура - состояние ВМ
//
Функция ПолучитьСостояниеВМ(АдресВМ) Экспорт
	
	ВМ = ПолучитьВМИзАдреса(АдресВМ);
	
	Результат = Новый Структура;
	Результат.Вставить("ОтладкаЗавершена", ВМ.ОтладкаЗавершена);
	Результат.Вставить("СтрокаТочкиОстанова", ВМ.НомерСтрокиОстанова);
	Результат.Вставить("ГлубинаСтекаВызовов", ВМ.Стеки.СтекВызовов.Количество());
	Результат.Вставить("ТекущаяКоманда", ВМ.ТекущаяКоманда);
	Результат.Вставить("КоличествоАргументов", ВМ.КоличествоАргументов);
	Результат.Вставить("Ошибки", ВМ.Ошибки);
	Результат.Вставить("Сообщения", ВМ.Сообщения);
	
	ПредставлениеСтека = Новый Массив;
	Для Каждого ЭлементСтека Из ВМ.Стеки.Стек Цикл
		ПредставлениеСтека.Добавить(ПолучитьПредставлениеЗначения(ЭлементСтека.Значение));
	КонецЦикла;
	Результат.Вставить("ПредставлениеСтека", ПредставлениеСтека);
	
	ПредставлениеПеременных = Новый Массив;
	Для Каждого Переменная Из ВМ.Программа.Переменные Цикл
		ПредставлениеПеременных.Добавить(Новый Структура("Значение,Инициализирована",
			ПолучитьПредставлениеЗначения(Переменная.Значение), Переменная.Инициализирована));
	КонецЦикла;
	Результат.Вставить("ПредставлениеПеременных", ПредставлениеПеременных);
	
	СформироватьСтекВызовов(ВМ, Результат);
	
	Возврат Результат;
	
КонецФункции

// Обновляет текущее соответствие переменных
//
// Параметры:
//  АдресВМ - Строка, Структура - адрес ВМ во временном хранилище или структура ВМ
//  АдресПеременных - Строка - адрес переменных во временном хранилище
//  НомерУровняСтека - Число - номер уровня стека вызовов
//
Процедура ОбновитьТекущееСоответствиеПеременных(АдресВМ, АдресПеременных, НомерУровняСтека) Экспорт
	
	ВМ = ПолучитьВМИзАдреса(АдресВМ);
	
	СохранитьСостояниеВМ(ВМ, АдресВМ, АдресПеременных, НомерУровняСтека);
	
КонецПроцедуры

// Формирует соответствие встроенных функций языка из общего макета конс_ВстроенныеФункцииВМ.
// JSON-данные преобразуются в Соответствие, где ключ — имя функции в верхнем регистре,
// значение — Структура(Имя, КоличествоПараметров) или Массив таких структур (полиморфные функции).
//
// Возвращаемое значение:
//  Соответствие - карта соответствия имен встроенных функций их параметрам
//
Функция СформироватьСоответствиеВстроенныхФункций() Экспорт
	
	ТекстJSON = ПолучитьОбщийМакет("конс_ВстроенныеФункцииВМ").ПолучитьТекст();
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТекстJSON);
	Данные = ПрочитатьJSON(ЧтениеJSON, Истина);
	ЧтениеJSON.Закрыть();
	
	ВстроенныеФункции = Новый Соответствие;
	
	Для Каждого Элемент Из Данные Цикл
		Если ТипЗнч(Элемент.Значение) = Тип("Соответствие") Тогда
			ВстроенныеФункции.Вставить(Элемент.Ключ,
				Новый Структура("Имя,КоличествоПараметров", Элемент.Значение["Имя"], Элемент.Значение["КоличествоПараметров"]));
		Иначе
			Варианты = Новый Массив;
			Для Каждого Вариант Из Элемент.Значение Цикл
				Варианты.Добавить(Новый Структура("Имя,КоличествоПараметров,Суффикс",
					Вариант["Имя"], Вариант["КоличествоПараметров"], Вариант["Суффикс"]));
			КонецЦикла;
			ВстроенныеФункции.Вставить(Элемент.Ключ, Варианты);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВстроенныеФункции;
	
КонецФункции

// Формирует соответствие обработчиков опкодов из общего макета конс_ОбработчикиОпКодовВМ.
// Ключ — имя опкода (совпадает с тем, что генерирует компилятор).
// Значение — строка BSL-кода, выполняемая через Выполнить.
//
// Возвращаемое значение:
//  Соответствие - карта опкодов к исполняемому коду
//
Функция СформироватьОбработчикиОпКодов() Экспорт
	
	ТекстJSON = ПолучитьОбщийМакет("конс_ОбработчикиОпКодовВМ").ПолучитьТекст();
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТекстJSON);
	Данные = ПрочитатьJSON(ЧтениеJSON, Истина);
	ЧтениеJSON.Закрыть();
	
	О = Новый Соответствие;
	Для Каждого Элемент Из Данные Цикл
		О.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
	Возврат О;
	
КонецФункции

// Получает значение внешней переменной по имени
//
// Параметры:
//  ИмяПеременной - Строка - имя переменной для получения
//
// Возвращаемое значение:
//  Произвольный - значение переменной
//
Функция ПолучитьЗначениеВнешнейПеременной(ИмяПеременной) Экспорт
	
	// Имя переменной нарочито уникальное, чтобы не совпасть с пользовательской переменной (напр. "Результат")
	конс__0_Результат = Неопределено;
	Выполнить "конс__0_Результат = " + ИмяПеременной;
	Возврат конс__0_Результат;
	
КонецФункции

// Проверяет возможность сохранения переменной во временное хранилище
//
// Параметры:
//  Переменная - Структура - переменная для проверки
//  ВМ - Структура - виртуальная машина
//  ПропуститьОшибки - Булево - пропускать ошибки
//
// Возвращаемое значение:
//  Булево - Истина, если переменную можно сохранить
//
Функция ВозможноСохранитьПеременнуюВХранилище(Переменная, ВМ, ПропуститьОшибки) Экспорт
	
	МожноСохранить = Истина;
	
	Если ВМ.ЭтоСервер Тогда
		// Проверяем на менеджер временных таблиц с активными таблицами
		Если (ТипЗнч(Переменная.Значение) = Тип("МенеджерВременныхТаблиц")
				И Переменная.Значение.Таблицы.Количество() > 0)
			ИЛИ (ТипЗнч(Переменная.Значение) = Тип("Запрос")
				И Переменная.Значение.МенеджерВременныхТаблиц <> Неопределено
				И Переменная.Значение.МенеджерВременныхТаблиц.Таблицы.Количество() > 0) Тогда
			
			Если Не ПропуститьОшибки Тогда
				ТекстОшибки = НСтр("ru='Не удалось остановиться в строке ';en='It was not possible to stop in the line '", ТекущийЯзыкСистемы())
					+ ВМ.НомерСтрокиОстанова
					+ НСтр("ru=' т.к. на момент останова существует переменная, которую не удается поместить во временное хранилище (';en=' because at the time of stopping there is a variable that cannot be placed in temporary storage ('", ТекущийЯзыкСистемы());
				ВМ.Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 2, ТекстОшибки + Переменная.Имя + ")", ВМ.НомерСтрокиОстанова));
			КонецЕсли;
			
			МожноСохранить = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат МожноСохранить;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ВспомогательныеПроцедурыИФункции

// Раскручивает стек вызовов при обработке ошибки внутри блока Попытка.
// Удаляет все фреймы вызовов, созданные после входа в Попытку,
// восстанавливая состояние стеков к моменту входа в Попытку.
//
// Параметры:
//   ВМ - Структура - состояние виртуальной машины
//   ИдентификаторВызоваЦель - Строка - идентификатор вызова, до которого нужно раскрутить стек
//   КоличествоВременныхПеременных - Число - количество временных переменных на момент входа в Попытку
//
Процедура РаскрутитьСтекВызовов(ВМ, ИдентификаторВызоваЦель, КоличествоВременныхПеременных) Экспорт
	СтекВызовов = ВМ.Стеки.СтекВызовов;
	УдаленныеИдентификаторы = Новый Соответствие;
	КоличествоЭлементов = СтекВызовов.Количество();
	
	Пока КоличествоЭлементов > 0 Цикл
		ИдВызова = СтекВызовов[0].ИдентификаторВызова;
		
		Если ИдВызова <> ИдентификаторВызоваЦель Тогда
			УдаленныеИдентификаторы.Вставить(ИдВызова, Истина);
			ВМ.Индексы.КлючиПеременных.Удалить(ИдВызова);
			СтекВызовов.Удалить(0);
		Иначе
			Прервать;
		КонецЕсли;
		
		КоличествоЭлементов = КоличествоЭлементов - 1;
	КонецЦикла;
	
	СтекВременных = ВМ.Стеки.СтекВременныхПеременных;
	ОчиститьСтекПоИдентификаторам(СтекВременных, УдаленныеИдентификаторы);
	
	Размер = СтекВременных.Количество();
	Пока Размер > КоличествоВременныхПеременных Цикл
		СтекВременных.Удалить(0);
		Размер = Размер - 1;
	КонецЦикла;
	
	УдаленныеИдентификаторы.Вставить(ИдентификаторВызоваЦель, Истина);
	ОчиститьСтекПоИдентификаторам(ВМ.Стеки.Стек, УдаленныеИдентификаторы);
	ВМ.ИдентификаторВызова = ИдентификаторВызоваЦель;
КонецПроцедуры

// Проверяет, можно ли остановить выполнение ВМ (не в активной транзакции на сервере).
// При невозможности — добавляет информативную ошибку.
//
// Параметры:
//   ВМ - Структура - состояние виртуальной машины
//   НомерСтроки - Число - номер строки для сообщения об ошибке
//
// Возвращаемое значение:
//   Булево - Истина если остановка возможна
//
Функция МожноОстановиться(ВМ, НомерСтроки) Экспорт
	Если ВМ.ЭтоСервер И конс_ВМ_ВызовСервера.ПроверитьАктивностьТранзакции() Тогда
		ДобавитьОшибкуОстановкиВТранзакции(ВМ, НомерСтроки);
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
КонецФункции

// Обрабатывает перехват исключения в главном цикле при наличии СтекПопыток.
// Раскручивает стек вызовов, записывает ошибку в СтекОшибок,
// устанавливает указатель команд на адрес обработчика Исключение.
//
// Параметры:
//   ВМ - Структура - состояние виртуальной машины
//   ОбъектОшибки - ИнформацияОбОшибке - объект с данными об ошибке
//   ОстановкаПоОшибке - Булево - останавливать ли при ошибке для отладки
//   АдресВМ - Строка - адрес ВМ во временном хранилище
//   АдресПеременных - Строка - адрес переменных
//
// Возвращаемое значение:
//   Булево - Истина если нужно приостановить выполнение (остановка по ошибке)
//
Функция ОбработатьОшибкуВБлокеПопытки(ВМ, ОбъектОшибки, ОстановкаПоОшибке, АдресВМ, АдресПеременных)
	СтекПопыток = ВМ.Стеки.СтекПопыток;
	Фрейм = СтекПопыток[0];
	СтекПопыток.Удалить(0);
	
	РаскрутитьСтекВызовов(ВМ, Фрейм.ИдентификаторВызова, Фрейм.КоличествоВременныхПеременных);
	
	ОписаниеОшибки = ПолучитьТекстИсключения(ОбъектОшибки);
	ВМ.Стеки.СтекОшибок.Вставить(0, Новый Структура("ОписаниеОшибки,ГлубинаПопыток",
		ОписаниеОшибки, СтекПопыток.Количество()));
	
	ВМ.ТекущаяКоманда = Фрейм.АдресПерехода;
	
	Если Не ОстановкаПоОшибке Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не МожноОстановиться(ВМ, ВМ.НомерСтрокиОстанова) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ВМ.Отладка.ОстановленоПоОшибке = Истина;
	ВМ.Отладка.ОписаниеОшибки = ОписаниеОшибки;
	ВМ.Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 2, ОписаниеОшибки, ВМ.НомерСтрокиОстанова));
	Если Не СохранитьСостояниеВМ(ВМ, АдресВМ, АдресПеременных) Тогда
		СохранитьСостояниеВМ(ВМ, АдресВМ, АдресПеременных,, Истина);
	КонецЕсли;
	Возврат Истина;
КонецФункции

// Обрабатывает команду LINENUM в главном цикле ПродолжитьОтладку:
// проверяет точку останова, обновляет номер текущей строки.
// Возвращает Истина, если выполнение приостановлено (вызывающий должен выполнить Возврат)
//
// Параметры:
//   ВМ - Структура - состояние виртуальной машины
//   Стек - Массив - стек операндов
//   Команда - Структура - текущая команда LINENUM
//   СоответствиеТочекОстанова - Соответствие - карта точек останова
//   АдресПеременных - Строка - адрес переменных во временном хранилище
//   АдресВМ - Строка - адрес ВМ во временном хранилище
//
// Возвращаемое значение:
//   Булево - Истина если нужно приостановить выполнение
//
Функция ОбработатьНомерСтрокиВГлавномЦикле(ВМ, Стек, Команда, СоответствиеТочекОстанова, АдресПеременных, АдресВМ)
	Если Команда.Аргумент <> ВМ.НомерСтрокиОстанова И СоответствиеТочекОстанова <> Неопределено Тогда
		Если конс_ВМ_ОпКодыКлиентСервер.НомерСтроки(ВМ, Стек, Команда, СоответствиеТочекОстанова, АдресПеременных, АдресВМ) Тогда
			Если МожноОстановиться(ВМ, ВМ.НомерСтрокиОстанова) Тогда
				ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	Возврат Ложь;
КонецФункции

// Обрабатывает исключение в главном цикле ПродолжитьОтладку.
// В зависимости от режима остановки по ошибке, либо генерирует исключение дальше,
// либо приостанавливает выполнение для просмотра ошибки.
// Может также сгенерировать исключение (пробрасывание ошибки дальше).
//
// Параметры:
//   ВМ - Структура - состояние виртуальной машины
//   АдресВМ - Строка - адрес ВМ во временном хранилище
//   АдресПеременных - Строка - адрес переменных
//   ОстановкаПоОшибке - Булево - останавливать ли при ошибке
//   ОбъектОшибки - ИнформацияОбОшибке - объект с данными об ошибке
//
// Возвращаемое значение:
//   Булево - Истина если нужно приостановить выполнение
//
Функция ОбработатьОшибкуВГлавномЦикле(ВМ, АдресВМ, АдресПеременных, ОстановкаПоОшибке, ОбъектОшибки)
	Если ОстановкаПоОшибке И МожноОстановиться(ВМ, ВМ.НомерСтрокиОстанова) Тогда
		// Пытаемся сохранить с переменными, при неудаче - без
		Если Не СохранитьСостояниеВМ(ВМ, АдресВМ, АдресПеременных) Тогда
			СохранитьСостояниеВМ(ВМ, АдресВМ, АдресПеременных,, Истина);
		КонецЕсли;
		ВМ.Отладка.ОписаниеОшибки = ПолучитьТекстИсключения(ОбъектОшибки);
		ВМ.Отладка.ОстановленоПоОшибке = Истина;
		ВМ.Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 2, ВМ.Отладка.ОписаниеОшибки, ВМ.НомерСтрокиОстанова));
		// Пересохраним ВМ с обновлёнными полями ошибки
		Если ТипЗнч(АдресВМ) = Тип("Строка") Тогда
			ПоместитьВоВременноеХранилище(ВМ, АдресВМ);
		КонецЕсли;
		Возврат Истина;
	Иначе
		// Ошибка без остановки (или нельзя остановиться) — сохраняем переменные, завершаем отладку и пробрасываем исключение
		ВМ.Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 2, ПолучитьТекстИсключения(ОбъектОшибки), ВМ.НомерСтрокиОстанова));
		// Сохраняем переменные перед завершением
		Если Не СохранитьСостояниеВМ(ВМ, АдресВМ, АдресПеременных) Тогда
			СохранитьСостояниеВМ(ВМ, АдресВМ, АдресПеременных,, Истина);
		КонецЕсли;
		ЗавершитьОтладкуВМ(ВМ, АдресВМ);
		ВызватьИсключение ПолучитьТекстИсключения(ОбъектОшибки);
	КонецЕсли;
	Возврат Ложь;
КонецФункции

// Заполняет параметры подпрограммы значениями
Процедура ЗаполнитьПараметрыПодпрограммы(Переменные, ОписаниеПодпрограммы)
	Если ОписаниеПодпрограммы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ОписаниеПодпрограммы.Свойство("Параметры") Тогда
		Возврат;
	КонецЕсли;
	
	Индекс = 0;
	Для Каждого Параметр Из ОписаниеПодпрограммы.Параметры Цикл
		Переменная = Переменные[Индекс];
		Переменная.Значение = Параметр;
		Переменная.Инициализирована = Истина;
		Индекс = Индекс + 1;
	КонецЦикла;
КонецПроцедуры

// Добавляет ошибку транзакции - нельзя остановиться внутри активной транзакции
Процедура ДобавитьОшибкуОстановкиВТранзакции(ВМ, НомерСтроки) Экспорт
	ВМ.Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 2,
		НСтр("ru='Не удалось остановиться в строке ';en='It was not possible to stop in the line '", ТекущийЯзыкСистемы())
		+ НомерСтроки
		+ НСтр("ru=' т.к. код выполняется внутри активной транзакции';en=' because code runs inside an active transaction'", ТекущийЯзыкСистемы()),
		НомерСтроки));
КонецПроцедуры

// Заполняет представление стека вызовов для отображения
Процедура СформироватьСтекВызовов(ВМ, Настройки)
	МассивВызовов = Новый Массив;
	КэшНомеровСтрок = Новый Соответствие;
	
	Для Каждого ЭлементСтека Из ВМ.Стеки.СтекВызовов Цикл
		ЭлементПредставления = Новый Структура("Строка,Название", НайтиНомерСтроки(КэшНомеровСтрок, ЭлементСтека.ТочкаВызова, ВМ));
		МассивВызовов.Добавить(ЭлементПредставления);
	КонецЦикла;
	
	Если МассивВызовов.Количество() > 0 Тогда
		ЭлементПредставления = Новый Структура("Строка,Название", НайтиНомерСтроки(КэшНомеровСтрок, ВМ.ТекущаяКоманда, ВМ));
		МассивВызовов.Вставить(0, ЭлементПредставления);
		МассивВызовов[МассивВызовов.Количество() - 1].Название = НСтр("ru='<Основной модуль консоли кода>';en='<Main code console module>'", ТекущийЯзыкСистемы());
		
		Индекс = 0;
		Для Каждого ЭлементСтека Из ВМ.Стеки.СтекВызовов Цикл
			МассивВызовов[Индекс].Название = ПредставлениеПодпрограммы(ЭлементСтека, ВМ);
			Индекс = Индекс + 1;
		КонецЦикла;
	КонецЕсли;
	
	Настройки.Вставить("ПредставлениеСтекаВызовов", МассивВызовов);
КонецПроцедуры

// Возвращает текстовое представление подпрограммы с параметрами
Функция ПредставлениеПодпрограммы(ОписаниеПодпрограммы, ВМ)
	Представление = "";
	
	Для Каждого Переменная Из ОписаниеПодпрограммы.Переменные Цикл
		Если Переменная.Флаг = "Параметр" ИЛИ Переменная.Флаг = "ПараметрЗнач" Тогда // обычный параметр (по ссылке) или Знач (по значению)
			Представление = Представление + ?(ЗначениеЗаполнено(Представление), ", ", "") + Переменная.Имя + " = " + ПредставлениеЗначенияПеременной(ВМ, Переменная);
		КонецЕсли;
	КонецЦикла;
	
	Представление = ОписаниеПодпрограммы.Имя + "(" + Представление + ")";
	Возврат Представление;
КонецФункции

// Возвращает строковое представление значения переменной
Функция ПредставлениеЗначенияПеременной(ВМ, ОписаниеПеременной)
	Значение = ПолучитьЗначениеПеременнойВМ(ВМ, ОписаниеПеременной);
	Результат = "";
	МаксДлина = 50;
	
	Если ТипЗнч(Значение) = Тип("Булево") Тогда
		Если ВМ.ВариантВстроенногоЯзыка = "ru" Тогда
			Результат = Формат(Значение, "БЛ=Ложь; БИ=Истина");
		Иначе
			Результат = Формат(Значение, "BF=False; BT=True");
		КонецЕсли;
	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда
		Результат = """" + ОбрезатьСтроку(Значение, МаксДлина) + """";
	Иначе
		Результат = ОбрезатьСтроку(БезопаснаяСтрока(Значение), МаксДлина);
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Обрезает строку до указанной длины, добавляя "..." при необходимости
Функция ОбрезатьСтроку(ИсходнаяСтрока, МаксДлина)
	Результат = ИсходнаяСтрока;
	
	Если СтрДлина(ИсходнаяСтрока) > МаксДлина Тогда
		Результат = Сред(ИсходнаяСтрока, 1, МаксДлина - 3) + "...";
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Находит номер строки исходного кода по адресу команды
Функция НайтиНомерСтроки(КэшНомеров, АдресКоманды, ВМ)
	НомерСтроки = КэшНомеров[АдресКоманды];
	Команды = ВМ.Программа.Команды;
	
	Если НомерСтроки <> Неопределено Тогда
		Возврат НомерСтроки;
	Иначе
		ТекущийАдрес = АдресКоманды - 1;
		ТекущаяКоманда = Команды[ТекущийАдрес];
		
		Пока ТекущийАдрес >= 0 Цикл
			ТекущаяКоманда = Команды[ТекущийАдрес];
			
			Если ТекущаяКоманда.ОпКод = "НОМЕРСТРОКИ" Тогда
				КэшНомеров.Вставить(АдресКоманды, ТекущаяКоманда.Аргумент);
				Возврат ТекущаяКоманда.Аргумент;
			КонецЕсли;
			
			ТекущийАдрес = ТекущийАдрес - 1;
		КонецЦикла;
	КонецЕсли;
КонецФункции

// Очищает массив элементов, удаляя элементы с указанными идентификаторами вызова
Процедура ОчиститьСтекПоИдентификаторам(Массив, СоответствиеИдентификаторов) Экспорт
	Количество = Массив.Количество();
	
	Для Счетчик = 1 По Количество Цикл
		Индекс = Количество - Счетчик;
		Элемент = Массив[Индекс];
		
		Если СоответствиеИдентификаторов[Элемент.ИдентификаторВызова] <> Неопределено Тогда
			Массив.Удалить(Индекс);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Вызывает метод объекта
Процедура ВыполнитьВызовМетода(ВМ, Стек, Команда, ЭтоФункция = Истина) Экспорт
	КоличествоАргументов = ВМ.КоличествоАргументов;
	АдресОбъекта = КоличествоАргументов;
	ИмяМетода = ВМ.Программа.Константы[Команда.Аргумент].Значение;
	
	Если ТипЗнч(Стек[АдресОбъекта].Значение) = Тип("СообщениеПользователю") И (ВРег(ИмяМетода) = "СООБЩИТЬ" ИЛИ ВРег(ИмяМетода) = "MESSAGE") Тогда
		Если КоличествоАргументов = 0 Тогда
			Сообщения = ?(ВМ.ОсновнаяВМ = Неопределено, ВМ.Сообщения, ВМ.ОсновнаяВМ.Сообщения);
			Сообщения.Добавить(Новый Структура("Текст,Статус", Стек[АдресОбъекта].Значение.Текст, СтатусСообщения.Обычное));
		Иначе
			ВызватьИсключение НСтр("ru='Слишком много фактических параметров (';en='Too many actual parameters ('", ТекущийЯзыкСистемы()) + ИмяМетода + ")";
		КонецЕсли;
	Иначе
		Префикс = ?(ЭтоФункция = Истина, "ВМ.РезультатФункции.Значение = ", "");
		ТекстВыполнения = Префикс + "Стек[АдресОбъекта].Значение." + ИмяМетода + "(" + СформироватьТекстПараметровВызова(Стек, КоличествоАргументов) + ")";
		Выполнить ТекстВыполнения;
		ОчиститьАргументыИзСтека(Стек, АдресОбъекта + 1);
	КонецЕсли;
КонецПроцедуры

// Вызывает внутреннюю подпрограмму (процедуру или функцию текущего модуля).
// Создаёт контекст вызова, обрабатывает формальные параметры (по значению/по ссылке),
// локальные и модульные переменные, помещает контекст в стек вызовов и перемещает
// указатель команд на точку входа подпрограммы.
// Для вложенных вызовов (из вложенной ВМ) создаётся отдельная вложенная ВМ.
//
// Параметры:
//   ВМ - Структура - состояние виртуальной машины
//   Стек - Массив - стек операндов
//   Команда - Структура - текущая команда байткода
//   Подпрограмма - Структура - описание вызываемой подпрограммы (Имя, ЧислоАргументов, Переменные, ТочкаВхода)
//   ФлагПодпрограммы - Число - флаг типа подпрограммы:
//     0 = внутренняя процедура, 1 = внутренняя функция,
//     16 = экспортная процедура, 17 = экспортная функция
//
// Заполняет формальный параметр подпрограммы значением из стека
Процедура ЗаполнитьФормальныйПараметр(НоваяПеременная, ИсходнаяПеременная, ЭлементСтека,
		НовыйИдентификаторВызова, Счетчик, ВМ)
	
	Если ЭлементСтека.Свойство("ЭтоПустоеЗначение") Тогда
		УстановитьЗначениеПоУмолчанию(НоваяПеременная, ИсходнаяПеременная, НовыйИдентификаторВызова, Счетчик);
		Возврат;
	КонецЕсли;
	
	Если НоваяПеременная.Флаг = "ПараметрЗнач" Тогда
		НоваяПеременная.Значение = ЭлементСтека.Значение;
		НоваяПеременная.ИдентификаторВызова = НовыйИдентификаторВызова;
		НоваяПеременная.Адрес = Счетчик;
		Возврат;
	КонецЕсли;
	
	// Передача по ссылке
	Если Не ЭлементСтека.Свойство("Адрес") Тогда
		НоваяПеременная.Значение = ЭлементСтека.Значение;
		НоваяПеременная.ИдентификаторВызова = НовыйИдентификаторВызова;
		НоваяПеременная.Адрес = Счетчик;
		Возврат;
	КонецЕсли;
	
	НоваяПеременная.ИдентификаторВызова = ЭлементСтека.ИсходныйИдентификаторВызова;
	НоваяПеременная.Адрес = ЭлементСтека.Адрес;
	НоваяПеременная.ЗначениеПредСвойства = ЭлементСтека.ЗначениеПредСвойства;
	НоваяПеременная.ИмяСвойства = ЭлементСтека.ИмяСвойства;
	
	ПеременнаяКонтекста = ВМ.ТекущийКонтекст[ВРег(ЭлементСтека.Имя)];
	НоваяПеременная.ВМ = ?(ПеременнаяКонтекста = Неопределено, Неопределено, ПеременнаяКонтекста.ВМ);
КонецПроцедуры

// Устанавливает значение параметра по умолчанию
Процедура УстановитьЗначениеПоУмолчанию(НоваяПеременная, ИсходнаяПеременная, НовыйИдентификаторВызова, Счетчик)
	НоваяПеременная.Значение = ИсходнаяПеременная.ЗначениеПоУмолчанию;
	НоваяПеременная.ИдентификаторВызова = НовыйИдентификаторВызова;
	НоваяПеременная.Адрес = Счетчик;
КонецПроцедуры

// Инициализирует локальную переменную подпрограммы по её флагу
Процедура ИнициализироватьЛокальнуюПеременную(НоваяПеременная, НовыйИдентификаторВызова, Счетчик, ВМ, ЭтоВложенныйВызов)
	ФлагЛокальнойПеременной = НоваяПеременная.Флаг;
	
	Если ФлагЛокальнойПеременной = "НеявнаяЛокальная" Тогда
		НоваяПеременная.Адрес = Счетчик;
		НоваяПеременная.ИдентификаторВызова = НовыйИдентификаторВызова;
		Возврат;
	КонецЕсли;
	
	Если ФлагЛокальнойПеременной <> "НеявнаяМодульная" И ФлагЛокальнойПеременной <> "ЯвнаяМодульная" Тогда
		Возврат;
	КонецЕсли;
	
	АдресМодульнойПеременной = ВМ.Индексы.КлючиПеременныхМодуля[ВРег(НоваяПеременная.Имя)];
	Если АдресМодульнойПеременной = Неопределено Тогда
		ВызватьИсключение НСтр("ru='Переменная не определена (';en='Variable is not defined ('", ТекущийЯзыкСистемы()) + НоваяПеременная.Имя + ")";
	КонецЕсли;
	НоваяПеременная.Адрес = АдресМодульнойПеременной;
	НоваяПеременная.ИдентификаторВызова = Неопределено;
	НоваяПеременная.ВМ = ?(ЭтоВложенныйВызов, ВМ.ОсновнаяВМ, Неопределено);
КонецПроцедуры

Процедура ВызватьВнутреннююПодпрограмму(ВМ, Стек, Команда, Подпрограмма, ФлагПодпрограммы) Экспорт
	
	НовыйИдентификаторВызова = Новый УникальныйИдентификатор;
	ЭтоФункция = (ФлагПодпрограммы = "Функция" ИЛИ ФлагПодпрограммы = "ЭкспортФункция");
	
	КонтекстВызова = Новый Структура(
		"Имя,Переменные,ЭтоФункция,ТочкаВызова,ИдентификаторВызова",
		Подпрограмма.Имя,
		Новый Массив,
		ЭтоФункция,
		ВМ.ТекущаяКоманда,
		НовыйИдентификаторВызова
	);
	
	ЧислоФормальныхАргументов = Подпрограмма.ЧислоАргументов;
	ЧислоФактическихАргументов = ВМ.КоличествоАргументов;
	ПеременныеВызова = КонтекстВызова.Переменные;
	ПеременныеПодпрограммы = Подпрограмма.Переменные;
	КоличествоПеременных = ПеременныеПодпрограммы.Количество();
	
	Счетчик = 0;
	ЭтоВложенныйВызов = ВМ.ИсходнаяВМ <> Неопределено;
	ЦелеваяВМ = ?(ЭтоВложенныйВызов, СоздатьВложеннуюВМДляПодпрограммы(ВМ.ОсновнаяВМ, ВМ), ВМ);
	
	// Обработка формальных параметров
	Пока Счетчик < ЧислоФормальныхАргументов Цикл
		ИсходнаяПеременная = ПеременныеПодпрограммы[Счетчик];
		НоваяПеременная = Новый Структура(
			"ВМ,Имя,Флаг,Значение,Адрес,ИдентификаторВызова,ЗначениеПредСвойства,ИмяСвойства"
		);
		ЗаполнитьЗначенияСвойств(НоваяПеременная, ИсходнаяПеременная);
		НоваяПеременная.Вставить("Инициализирована", Истина);
		
		Если Счетчик < ЧислоФактическихАргументов Тогда
			ЭлементСтека = Стек[ЧислоФактическихАргументов - Счетчик - 1];
			ЗаполнитьФормальныйПараметр(НоваяПеременная, ИсходнаяПеременная, ЭлементСтека, НовыйИдентификаторВызова, Счетчик, ВМ);
		ИначеЕсли ИсходнаяПеременная.ЗначениеПоУмолчаниюСуществует Тогда
			УстановитьЗначениеПоУмолчанию(НоваяПеременная, ИсходнаяПеременная, НовыйИдентификаторВызова, Счетчик);
		Иначе
			ВызватьИсключение НСтр("ru='Недостаточно фактических параметров (';en='Not enough actual parameters ('", ТекущийЯзыкСистемы()) + Подпрограмма.Имя + ")";
		КонецЕсли;
		
		ПеременныеВызова.Добавить(НоваяПеременная);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	// Обработка локальных переменных
	Пока Счетчик < КоличествоПеременных Цикл
		ИсходнаяПеременная = ПеременныеПодпрограммы[Счетчик];
		НоваяПеременная = Новый Структура(
			"ВМ,Инициализирована,Имя,Флаг,Значение,Адрес,ИдентификаторВызова,ЗначениеПредСвойства,ИмяСвойства"
		);
		ЗаполнитьЗначенияСвойств(НоваяПеременная, ИсходнаяПеременная);
		ИнициализироватьЛокальнуюПеременную(НоваяПеременная, НовыйИдентификаторВызова, Счетчик, ВМ, ЭтоВложенныйВызов);
		ПеременныеВызова.Добавить(НоваяПеременная);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	// Очистка аргументов со стека
	ОчиститьАргументыИзСтека(Стек, ЧислоФактическихАргументов);
	
	// Добавление контекста вызова в стек вызовов
	ЦелеваяВМ.Стеки.СтекВызовов.Вставить(0, КонтекстВызова);
	ЦелеваяВМ.Индексы.КлючиПеременных.Вставить(НовыйИдентификаторВызова, КонтекстВызова.Переменные);
	ЦелеваяВМ.ТекущаяКоманда = Подпрограмма.ТочкаВхода;
	ЦелеваяВМ.РезультатФункции.Значение = Неопределено;
	ЦелеваяВМ.ИдентификаторВызова = НовыйИдентификаторВызова;
	
	Если ЭтоВложенныйВызов Тогда
		ВМ.РезультатФункции.Значение = Неопределено;
		ЦелеваяВМ.РезультатФункции = ВМ.РезультатФункции;
		ПродолжитьОтладку(ЦелеваяВМ, Неопределено, ВМ.Отладка.ОстановкаПоОшибке, Новый Соответствие);
		ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
	КонецЕсли;
	
КонецПроцедуры

// Вызывает глобальную встроенную функцию или процедуру
Процедура ВызватьВнешнююПодпрограмму(ВМ, Стек, Команда, ЭтоФункция = Истина) Экспорт
	КоличествоАргументов = ВМ.КоличествоАргументов;
	ИмяФункции = ВМ.Программа.Подпрограммы[Команда.Аргумент].Имя;
	
	Если ВРег(ИмяФункции) = "СООБЩИТЬ" ИЛИ ВРег(ИмяФункции) = "MESSAGE" Тогда
		Сообщения = ?(ВМ.ОсновнаяВМ = Неопределено, ВМ.Сообщения, ВМ.ОсновнаяВМ.Сообщения);
		
		Если КоличествоАргументов = 1 Тогда
			Сообщения.Добавить(Новый Структура("Текст,Статус", Строка(Стек[0].Значение), СтатусСообщения.Обычное));
		ИначеЕсли КоличествоАргументов = 2 Тогда
			Сообщения.Добавить(Новый Структура("Текст,Статус", Строка(Стек[1].Значение), Стек[0].Значение));
		ИначеЕсли КоличествоАргументов = 0 Тогда
			ВызватьИсключение НСтр("ru='Недостаточно фактических параметров (';en='Not enough actual parameters ('", ТекущийЯзыкСистемы()) + ИмяФункции + ")";
		Иначе
			ВызватьИсключение НСтр("ru='Слишком много фактических параметров (';en='Too many actual parameters ('", ТекущийЯзыкСистемы()) + ИмяФункции + ")";
		КонецЕсли;
	Иначе
		Префикс = ?(ЭтоФункция = Истина, "ВМ.РезультатФункции.Значение = ", "");
		ТекстВыполнения = Префикс + ИмяФункции + "(" + СформироватьТекстПараметровВызова(Стек, КоличествоАргументов) + ")";
		Выполнить ТекстВыполнения;
	КонецЕсли;
	
	ОчиститьАргументыИзСтека(Стек, КоличествоАргументов);
КонецПроцедуры

// Вычисляет функцию с переменным числом аргументов (MIN, MAX)
Процедура ВычислитьФункциюСПеременнымЧисломАргументов(ВМ, Стек, ИмяФункции) Экспорт
	КоличествоАргументов = ВМ.КоличествоАргументов;
	РезультатФункции = Неопределено;
	
	ТекстВыполнения = "РезультатФункции = " + ИмяФункции + "(" + СформироватьТекстПараметровВызова(Стек, КоличествоАргументов) + ")";
	Выполнить ТекстВыполнения;
	
	ОчиститьАргументыИзСтека(Стек, КоличествоАргументов);
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", РезультатФункции, ВМ.ИдентификаторВызова));
КонецПроцедуры

// Получает свойство объекта и помещает результат в стек
Процедура ЗагрузитьСвойствоИлиИндекс(ВМ, Стек, ИмяСвойства) Экспорт
	ЭлементСтека = Стек[0];
	
	Если ЭлементСтека.Значение = Неопределено Тогда
		ВызватьИсключение НСтр("ru='Значение не является значением объектного типа (Получение элемента по индексу для значения Неопределено)';en='Value is not an object type value (Getting element by index for Undefined value)'", ТекущийЯзыкСистемы());
	КонецЕсли;
	
	НовыйЭлемент = Новый Структура("Значение,ИдентификаторВызова", ЭлементСтека.Значение[ИмяСвойства], ВМ.ИдентификаторВызова);
	
	Если ЭлементСтека.Свойство("Адрес") Тогда
		НовыйЭлемент.Вставить("ИмяСвойства", ИмяСвойства);
		НовыйЭлемент.Вставить("ЗначениеПредСвойства", ЭлементСтека.Значение);
		НовыйЭлемент.Вставить("Адрес", ЭлементСтека.Адрес);
		НовыйЭлемент.Вставить("Флаг", ЭлементСтека.Флаг);
		НовыйЭлемент.Вставить("ИсходныйИдентификаторВызова", ЭлементСтека.ИсходныйИдентификаторВызова);
		НовыйЭлемент.Вставить("ВМ", ЭлементСтека.ВМ);
		НовыйЭлемент.Вставить("Имя", ЭлементСтека.Имя);
	КонецЕсли;
	
	Стек.Удалить(0);
	Стек.Вставить(0, НовыйЭлемент);
КонецПроцедуры

// Получает значение переменной по её описанию
Функция ПолучитьЗначениеПеременнойВМ(ВМ, ОписаниеПеременной) Экспорт
	Если ОписаниеПеременной.Флаг = "Внешняя" Тогда
		Возврат ПолучитьЗначениеВнешнейПеременной(ОписаниеПеременной.Имя);
	КонецЕсли;
	
	Если ОписаниеПеременной.ЗначениеПредСвойства <> Неопределено Тогда
		Возврат ОписаниеПеременной.ЗначениеПредСвойства[ОписаниеПеременной.ИмяСвойства];
	КонецЕсли;
	
	ПроверитьАдресПеременной(ОписаниеПеременной);
	
	Возврат ПолучитьЗначениеИзКонтекстаВызова(ВМ, ОписаниеПеременной);
КонецФункции

// Проверяет что адрес переменной определён
Процедура ПроверитьАдресПеременной(ОписаниеПеременной)
	Если ОписаниеПеременной.Адрес = Неопределено Тогда
		ВызватьИсключение НСтр("ru='Переменная не определена (';en='Variable is not defined ('", ТекущийЯзыкСистемы()) + ОписаниеПеременной.Имя + ")";
	КонецЕсли;
КонецПроцедуры

// Получает значение из контекста вызова по идентификатору и адресу
Функция ПолучитьЗначениеИзКонтекстаВызова(ВМ, ОписаниеПеременной)
	ЦелеваяВМ = ?(ОписаниеПеременной.ВМ = Неопределено, ВМ, ОписаниеПеременной.ВМ);
	
	Если ОписаниеПеременной.ИдентификаторВызова = Неопределено Тогда
		Если ОписаниеПеременной.Адрес >= ЦелеваяВМ.Программа.Переменные.Количество() Тогда
			ВызватьИсключение НСтр("ru='Переменная не определена (';en='Variable is not defined ('", ТекущийЯзыкСистемы()) + ОписаниеПеременной.Имя + ")";
		КонецЕсли;
		Возврат ЦелеваяВМ.Программа.Переменные[ОписаниеПеременной.Адрес].Значение;
	КонецЕсли;
	
	ПеременныеВызова = ЦелеваяВМ.Индексы.КлючиПеременных[ОписаниеПеременной.ИдентификаторВызова];
	Если ПеременныеВызова = Неопределено ИЛИ ОписаниеПеременной.Адрес >= ПеременныеВызова.Количество() Тогда
		ВызватьИсключение НСтр("ru='Переменная не определена (';en='Variable is not defined ('", ТекущийЯзыкСистемы()) + ОписаниеПеременной.Имя + ")";
	КонецЕсли;
	Возврат ПеременныеВызова[ОписаниеПеременной.Адрес].Значение;
КонецФункции

// Получает ссылку на переменную по её описанию
Функция ПолучитьСсылкуНаПеременную(ВМ, ОписаниеПеременной)
	ЦелеваяВМ = ?(ОписаниеПеременной.ВМ = Неопределено, ВМ, ОписаниеПеременной.ВМ);
	
	Если ОписаниеПеременной.Адрес = Неопределено Тогда
		ВызватьИсключение НСтр("ru='Переменная не определена (';en='Variable is not defined ('", ТекущийЯзыкСистемы()) + ОписаниеПеременной.Имя + ")";
	КонецЕсли;
	
	Если ОписаниеПеременной.ИсходныйИдентификаторВызова = Неопределено Тогда
		Если ОписаниеПеременной.Адрес >= ЦелеваяВМ.Программа.Переменные.Количество() Тогда
			ВызватьИсключение НСтр("ru='Переменная не определена (';en='Variable is not defined ('", ТекущийЯзыкСистемы()) + ОписаниеПеременной.Имя + ")";
		КонецЕсли;
		Возврат ЦелеваяВМ.Программа.Переменные[ОписаниеПеременной.Адрес];
	Иначе
		ПеременныеВызова = ЦелеваяВМ.Индексы.КлючиПеременных[ОписаниеПеременной.ИсходныйИдентификаторВызова];
		Если ПеременныеВызова = Неопределено ИЛИ ОписаниеПеременной.Адрес >= ПеременныеВызова.Количество() Тогда
			ВызватьИсключение НСтр("ru='Переменная не определена (';en='Variable is not defined ('", ТекущийЯзыкСистемы()) + ОписаниеПеременной.Имя + ")";
		КонецЕсли;
		Возврат ПеременныеВызова[ОписаниеПеременной.Адрес];
	КонецЕсли;
КонецФункции

// Устанавливает значение переменной
Процедура УстановитьЗначениеПеременной(ВМ, Стек, ОписаниеПеременной, ФлагПеременной, Значение) Экспорт
	СсылкаНаПеременную = ПолучитьСсылкуНаПеременную(ВМ, ОписаниеПеременной);
	СсылкаНаПеременную.Инициализирована = Истина;
	
	Если ФлагПеременной <> "Внешняя" Тогда
		Если ОписаниеПеременной.ЗначениеПредСвойства <> Неопределено Тогда
			ОписаниеПеременной.ЗначениеПредСвойства[ОписаниеПеременной.ИмяСвойства] = Значение;
		Иначе
			СсылкаНаПеременную.Значение = Значение;
		КонецЕсли;
	Иначе
		Выполнить СсылкаНаПеременную.Имя + " = Значение";
	КонецЕсли;
КонецПроцедуры

// Строит индекс имен переменных (имя -> индекс)
Функция СформироватьКлючиПеременныхМодуля(Переменные)
	Индекс = Новый Соответствие;
	Номер = 0;
	Количество = Переменные.Количество();
	
	Пока Номер < Количество Цикл
		Индекс.Вставить(ВРег(Переменные[Номер].Имя), Номер);
		Номер = Номер + 1;
	КонецЦикла;
	
	Возврат Индекс;
КонецФункции

// Строит индекс имен подпрограмм (имя -> описание), исключая флаги 32 и 33
Функция СформироватьКлючиПодпрограмм(Подпрограммы)
	Индекс = Новый Соответствие;
	
	Для Каждого Подпрограмма Из Подпрограммы Цикл
		Если Подпрограмма.Флаг <> "ВнешняяПроцедура" И Подпрограмма.Флаг <> "ВнешняяФункция" Тогда
			Индекс.Вставить(ВРег(Подпрограмма.Имя), Подпрограмма);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Индекс;
КонецФункции

// Восстанавливает переменные по именам из сопоставления
Процедура ВосстановитьПеременныеПоИменам(СоответствиеИмен, Переменные)
	Для Каждого Переменная Из Переменные Цикл
		Найденная = СоответствиеИмен[ВРег(Переменная.Имя)];
		
		Если Найденная <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(Переменная, Найденная);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Помещает результат встроенной функции в стек: удаляет входные аргументы,
// добавляет результат и продвигает указатель команд.
// Используется для унификации обработчиков встроенных функций (_STRLEN, _SIN, _LEFT и др.)
//
// Параметры:
//   ВМ - Структура - состояние виртуальной машины
//   Стек - Массив - стек операндов
//   Результат - Произвольный - результат вычисления функции
//   КоличествоАргументов - Число - сколько аргументов удалить из стека (0 для функций без аргументов)
//
Процедура ПоместитьРезультатФункцииВСтек(ВМ, Стек, Результат, КоличествоАргументов = 0) Экспорт
	Счетчик = КоличествоАргументов;
	Пока Счетчик > 0 Цикл
		Стек.Удалить(0);
		Счетчик = Счетчик - 1;
	КонецЦикла;
	Стек.Вставить(0, Новый Структура("Значение,ИдентификаторВызова", Результат, ВМ.ИдентификаторВызова));
	ВМ.ТекущаяКоманда = ВМ.ТекущаяКоманда + 1;
КонецПроцедуры

// Загружает структуру ВМ из адреса (временное хранилище или прямая ссылка)
//
// Параметры:
//   АдресВМ - Строка, Структура - адрес ВМ во временном хранилище или структура ВМ
//
// Возвращаемое значение:
//   Структура - состояние виртуальной машины
//
Функция ПолучитьВМИзАдреса(АдресВМ)
	Если ТипЗнч(АдресВМ) = Тип("Строка") Тогда
		Возврат ПолучитьИзВременногоХранилища(АдресВМ);
	Иначе
		Возврат АдресВМ;
	КонецЕсли;
КонецФункции

// Формирует текст списка параметров для динамического вызова через Выполнить
// Генерирует строку вида "Стек[2].Значение, Стек[1].Значение, Стек[0].Значение"
// с учётом пустых значений (пропущенных параметров)
//
// Параметры:
//   Стек - Массив - стек операндов
//   КоличествоАргументов - Число - число аргументов
//
// Возвращаемое значение:
//   Строка - текст параметров для подстановки в вызов
//
Функция СформироватьТекстПараметровВызова(Стек, КоличествоАргументов)
	Результат = "";
	Индекс = КоличествоАргументов - 1;
	
	Пока Индекс >= 0 Цикл
		Если Стек[Индекс].Свойство("ЭтоПустоеЗначение") Тогда
			Параметр = "";
		Иначе
			Параметр = "Стек[" + Формат(Индекс, "ЧН=0; ЧГ=0") + "].Значение";
		КонецЕсли;
		Результат = Результат + Параметр + ?(Индекс > 0, ", ", "");
		Индекс = Индекс - 1;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Удаляет указанное количество элементов из вершины стека
//
// Параметры:
//   Стек - Массив - стек операндов
//   Количество - Число - сколько элементов удалить
//
Процедура ОчиститьАргументыИзСтека(Стек, Количество)
	Счетчик = Количество;
	Пока Счетчик > 0 Цикл
		Стек.Удалить(0);
		Счетчик = Счетчик - 1;
	КонецЦикла;
КонецПроцедуры

// Заполняет контекст переменных для отладки
// Создаёт описание переменной для контекста
Функция СоздатьОписаниеПеременнойКонтекста(Переменная, ВМ)
	ОписаниеПеременной = Новый Структура("Адрес,ИдентификаторВызова,Флаг,Инициализирована,ЗначениеПредСвойства,ИмяСвойства");
	ЗаполнитьЗначенияСвойств(ОписаниеПеременной, Переменная);
	ОписаниеПеременной.Вставить("ВМ", ВМ);
	Возврат ОписаниеПеременной;
КонецФункции

// Проверяет, является ли переменная допустимой для включения в контекст
Функция ПеременнаяДопустимаДляКонтекста(Переменная)
	Возврат Переменная.Инициализирована И Не СтрНачинаетсяС(Переменная.Имя, "0");
КонецФункции

// Добавляет модульные переменные в контекст
Процедура ДобавитьМодульныеПеременные(Контекст, ВМ)
	Для Каждого Переменная Из ВМ.Программа.Переменные Цикл
		Если ПеременнаяДопустимаДляКонтекста(Переменная) И Контекст[ВРег(Переменная.Имя)] = Неопределено Тогда
			Контекст.Вставить(ВРег(Переменная.Имя), СоздатьОписаниеПеременнойКонтекста(Переменная, ВМ));
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Добавляет переменные стека вызовов в контекст
Процедура ДобавитьПеременныеСтекаВКонтекст(Контекст, ВМ, УровеньСтека)
	КоличествоВызовов = ВМ.Стеки.СтекВызовов.Количество();
	
	Если КоличествоВызовов = 0 ИЛИ УровеньСтека >= КоличествоВызовов Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Переменная Из ВМ.Стеки.СтекВызовов[УровеньСтека].Переменные Цикл
		Если ПеременнаяДопустимаДляКонтекста(Переменная) Тогда
			Контекст.Вставить(ВРег(Переменная.Имя), СоздатьОписаниеПеременнойКонтекста(Переменная, ВМ));
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаполнитьКонтекстПеременных(ЦелевойКонтекст, ВМ, УровеньСтека)
	Контекст = Новый Соответствие;
	
	Для Каждого Элемент Из ВМ.ТекущийКонтекст Цикл
		Контекст.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
	ДобавитьМодульныеПеременные(Контекст, ВМ);
	ДобавитьПеременныеСтекаВКонтекст(Контекст, ВМ, УровеньСтека);
	
	Для Каждого Переменная Из ЦелевойКонтекст.Переменные Цикл
		ОписаниеПеременной = Контекст[ВРег(Переменная.Имя)];
		Если ОписаниеПеременной <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(Переменная, ОписаниеПеременной);
		КонецЕсли;
	КонецЦикла;
	
	ЦелевойКонтекст.Вставить("ТекущийКонтекст", Контекст);
КонецПроцедуры

// Сохраняет состояние ВМ во временное хранилище
// Обрабатывает переменную при проверке возможности сохранения
// Возвращает Истина если переменная несохраняемая
Функция ОбработатьНесохраняемуюПеременную(Переменная, ВМ, ОчищатьПеременные)
	Если ВозможноСохранитьПеременнуюВХранилище(Переменная, ВМ, ОчищатьПеременные) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ОчищатьПеременные Тогда
		Переменная.Значение = Неопределено;
		Переменная.Инициализирована = Ложь;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// Собирает сохраняемые переменные модуля
Функция СобратьПеременныеМодуля(ВМ, ОчищатьПеременные)
	СохраненныеПеременные = Новый Соответствие;
	ЕстьНесохраняемые = Ложь;
	
	Для Каждого Переменная Из ВМ.Программа.Переменные Цикл
		Если ОбработатьНесохраняемуюПеременную(Переменная, ВМ, ОчищатьПеременные) Тогда
			ЕстьНесохраняемые = Истина;
			Продолжить;
		КонецЕсли;
		
		Если Переменная.Инициализирована И Не СтрНачинаетсяС(Переменная.Имя, "0") Тогда
			СохраненныеПеременные.Вставить(Переменная.Имя, Переменная.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Переменные,ЕстьНесохраняемые", СохраненныеПеременные, ЕстьНесохраняемые);
КонецФункции

// Собирает переменные стека вызовов
Процедура СобратьПеременныеСтекаВызовов(ВМ, СохраненныеПеременные, УровеньСтека, ОчищатьПеременные, ЕстьНесохраняемые)
	КоличествоВызовов = ВМ.Стеки.СтекВызовов.Количество();
	ИндексВызова = 0;
	
	Пока ИндексВызова < КоличествоВызовов Цикл
		СобратьПеременныеУровняВызова(ВМ, ИндексВызова, УровеньСтека, КоличествоВызовов,
			СохраненныеПеременные, ОчищатьПеременные, ЕстьНесохраняемые);
		ИндексВызова = ИндексВызова + 1;
	КонецЦикла;
КонецПроцедуры

// Собирает переменные одного уровня вызова
Процедура СобратьПеременныеУровняВызова(ВМ, ИндексВызова, УровеньСтека, КоличествоВызовов,
		СохраненныеПеременные, ОчищатьПеременные, ЕстьНесохраняемые)
	Для Каждого Переменная Из ВМ.Стеки.СтекВызовов[ИндексВызова].Переменные Цикл
		Если ОбработатьНесохраняемуюПеременную(Переменная, ВМ, ОчищатьПеременные) Тогда
			ЕстьНесохраняемые.Значение = Истина;
			Продолжить;
		КонецЕсли;
		
		Если ИндексВызова = УровеньСтека И УровеньСтека < КоличествоВызовов Тогда
			Если Переменная.Инициализирована И Не СтрНачинаетсяС(Переменная.Имя, "0") Тогда
				СохраненныеПеременные.Вставить(Переменная.Имя, ПолучитьЗначениеПеременнойВМ(ВМ, Переменная));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Сохраняет данные отладки во временное хранилище
Процедура СохранитьДанныеОтладки(ДанныеОтладки, АдресХранилища, СохраненныеПеременные, ВМ)
	Если ДанныеОтладки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(АдресХранилища) = Тип("Строка") Тогда
		Данные = ПолучитьИзВременногоХранилища(ДанныеОтладки);
		Данные.Вставить("Переменные", СохраненныеПеременные);
		ПоместитьВоВременноеХранилище(Данные, ДанныеОтладки);
		ПоместитьВоВременноеХранилище(ВМ, АдресХранилища);
	Иначе
		Данные = ДанныеОтладки;
		Данные.Вставить("Переменные", СохраненныеПеременные);
	КонецЕсли;
КонецПроцедуры

Функция СохранитьСостояниеВМ(ВМ, АдресХранилища, ДанныеОтладки, УровеньСтека = 0, ОчищатьПеременные = Ложь) Экспорт
	РезультатМодуля = СобратьПеременныеМодуля(ВМ, ОчищатьПеременные);
	СохраненныеПеременные = РезультатМодуля.Переменные;
	ФлагНесохраняемых = Новый Структура("Значение", РезультатМодуля.ЕстьНесохраняемые);
	
	СобратьПеременныеСтекаВызовов(ВМ, СохраненныеПеременные, УровеньСтека, ОчищатьПеременные, ФлагНесохраняемых);
	
	Если ФлагНесохраняемых.Значение И Не ОчищатьПеременные Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СохранитьДанныеОтладки(ДанныеОтладки, АдресХранилища, СохраненныеПеременные, ВМ);
	
	Возврат Истина;
КонецФункции

// Сбрасывает состояние ВМ для нового запуска
Процедура СброситьСостояниеВМ(ВМ, Настройки)
	ВМ.Стеки.Стек = Новый Массив;
	ВМ.Стеки.СтекВременныхПеременных = Новый Массив;
	ВМ.Стеки.СтекПопыток = Новый Массив;
	ВМ.Стеки.СтекОшибок = Новый Массив;
	ВМ.ТекущаяКоманда = ВМ.ОсновнаяТочкаВхода;
	ВМ.КоличествоАргументов = 0;
	ВМ.ОтладкаЗавершена = Истина;
	ВМ.НомерСтрокиОстанова = 0;
	ВМ.ОсновнаяВМ = Неопределено;
	ВМ.Отладка.ОстановленоПоОшибке = Ложь;
	ВМ.Отладка.ОписаниеОшибки = Неопределено;
КонецПроцедуры

// Сбрасывает значения всех переменных ВМ
Процедура СброситьПеременные(ВМ)
	Для Каждого Переменная Из ВМ.Программа.Переменные Цикл
		Переменная.Инициализирована = Ложь;
		Переменная.Значение = Неопределено;
	КонецЦикла;
	
	Для Каждого Подпрограмма Из ВМ.Программа.Подпрограммы Цикл
		Для Каждого Переменная Из Подпрограмма.Переменные Цикл
			Переменная.Инициализирована = Ложь;
			Переменная.Значение = Неопределено;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

// Безопасно преобразует значение в строку
Функция БезопаснаяСтрока(Значение)
	Попытка
		Результат = Строка(Значение);
	Исключение
		Результат = "";
	КонецПопытки;
	
	Возврат Результат;
КонецФункции

// Преобразует текст ошибки в объект ИнформацияОбОшибке
Функция ТекстВИнформациюОбОшибке(ТекстОшибки) Экспорт
	Попытка
		ВызватьИсключение ТекстОшибки;
	Исключение
		Возврат ИнформацияОбОшибке();
	КонецПопытки;
КонецФункции

// Извлекает текст описания ошибки из объекта ИнформацияОбОшибке
Функция ПолучитьТекстИсключения(ИнформацияОбОшибке) Экспорт
	Если ИнформацияОбОшибке.Причина <> Неопределено Тогда
		Возврат ОчиститьТекстОшибки(ИнформацияОбОшибке.Причина.Описание);
	Иначе
		Возврат ОчиститьТекстОшибки(ИнформацияОбОшибке.Описание);
	КонецЕсли;
КонецФункции

// Очищает текст ошибки от системного префикса вида {GUID}:
Функция ОчиститьТекстОшибки(Знач ТекстОшибки)
	ТекстОшибки = СокрЛП(ТекстОшибки);
	
	Если Не СтрНачинаетсяС(ТекстОшибки, "{") Тогда
		Возврат ТекстОшибки;
	КонецЕсли;
	
	Позиция = 1;
	ТекущийСимвол = "";
	ДлинаТекста = СтрДлина(ТекстОшибки);
	
	Пока ТекущийСимвол <> "}" И Позиция <= ДлинаТекста Цикл
		ТекущийСимвол = Сред(ТекстОшибки, Позиция, 1);
		Позиция = Позиция + 1;
	КонецЦикла;
	
	Если Позиция < ДлинаТекста И Сред(ТекстОшибки, Позиция, 1) = ":" Тогда
		ТекстОшибки = СокрЛП(Сред(ТекстОшибки, Позиция + 1));
	КонецЕсли;
	
	Возврат ТекстОшибки;
КонецФункции

// Создаёт новое состояние ВМ из данных компиляции
Функция НовоеСостояниеВМ(ДанныеКомпиляции, АдресТаблицПерехода, ВариантВстроенногоЯзыка, ИсходнаяВМ = Неопределено)
	СостояниеВМ = Новый Структура;
	
	// Подструктура «Программа»
	Программа = Новый Структура;
	Программа.Вставить("Команды", ДанныеКомпиляции.КомандыВМ);
	Программа.Вставить("Константы", ДанныеКомпиляции.КонстантыВМ);
	Программа.Вставить("Метки", ДанныеКомпиляции.МеткиВМ);
	Программа.Вставить("Переменные", ДанныеКомпиляции.ПеременныеВМ);
	Программа.Вставить("Подпрограммы", ДанныеКомпиляции.ПроцедурыФункцииВМ);
	СостояниеВМ.Вставить("Программа", Программа);
	
	// Подструктура «Стеки»
	Стеки = Новый Структура;
	Стеки.Вставить("Стек", Новый Массив);
	Стеки.Вставить("СтекВызовов", Новый Массив);
	Стеки.Вставить("СтекВременныхПеременных", Новый Массив);
	Стеки.Вставить("СтекПопыток", Новый Массив);
	Стеки.Вставить("СтекОшибок", Новый Массив);
	СостояниеВМ.Вставить("Стеки", Стеки);
	
	// Подструктура «Отладка»
	Отладка = Новый Структура;
	Отладка.Вставить("ОстановленоПоОшибке", Ложь);
	Отладка.Вставить("ОстановкаПоОшибке", Ложь);
	Отладка.Вставить("ОписаниеОшибки", Неопределено);
	Отладка.Вставить("МаксимальнаяГлубинаОстановки", Неопределено);
	СостояниеВМ.Вставить("Отладка", Отладка);
	
	// Подструктура «Индексы»
	Индексы = Новый Структура;
	Индексы.Вставить("КлючиПеременных",
		?(ИсходнаяВМ = Неопределено, Новый Соответствие, ИсходнаяВМ.Индексы.КлючиПеременных));
	Индексы.Вставить("КлючиПеременныхМодуля",
		?(ИсходнаяВМ = Неопределено,
			СформироватьКлючиПеременныхМодуля(ДанныеКомпиляции.ПеременныеВМ),
			ИсходнаяВМ.Индексы.КлючиПеременныхМодуля));
	Индексы.Вставить("КлючиЛокальныхПодпрограмм",
		?(ИсходнаяВМ = Неопределено,
			СформироватьКлючиПодпрограмм(ДанныеКомпиляции.ПроцедурыФункцииВМ),
			ИсходнаяВМ.Индексы.КлючиЛокальныхПодпрограмм));
	СостояниеВМ.Вставить("Индексы", Индексы);
	
	// Поля верхнего уровня
	ТочкаВхода = ДанныеКомпиляции.ТочкаВхода;
	СостояниеВМ.Вставить("Ошибки", Новый Массив);
	СостояниеВМ.Вставить("Сообщения", Новый Массив);
	СостояниеВМ.Вставить("ТекущаяКоманда", ТочкаВхода);
	СостояниеВМ.Вставить("ОсновнаяТочкаВхода", ТочкаВхода);
	СостояниеВМ.Вставить("КоличествоАргументов", 0);
	СостояниеВМ.Вставить("РезультатФункции", Новый Структура("Значение"));
	СостояниеВМ.Вставить("ИдентификаторВызова",
		?(ИсходнаяВМ = Неопределено, Неопределено, ИсходнаяВМ.ИдентификаторВызова));
	СостояниеВМ.Вставить("НомерСтрокиОстанова", 0);
	СостояниеВМ.Вставить("ОтладкаЗавершена", Ложь);
	СостояниеВМ.Вставить("АдресТаблицПерехода", АдресТаблицПерехода);
	СостояниеВМ.Вставить("ИсходнаяВМ", ИсходнаяВМ);
	СостояниеВМ.Вставить("ТекущийКонтекст", Новый Соответствие);
	СостояниеВМ.Вставить("ОсновнаяВМ", Неопределено);
	СостояниеВМ.Вставить("ВариантВстроенногоЯзыка", ВариантВстроенногоЯзыка);
	СостояниеВМ.Вставить("СтруктурыТипов",
		?(ИсходнаяВМ = Неопределено,
			конс_СистемаТиповКлиентСервер.СформироватьСоответствиеТипов(ВариантВстроенногоЯзыка),
			ИсходнаяВМ.СтруктурыТипов));
	
	Возврат СостояниеВМ;
КонецФункции

// Создаёт дочернюю ВМ для вызова подпрограммы внутри вложенного Выполнить
Функция СоздатьВложеннуюВМДляПодпрограммы(ОсновнаяВМ, ИсходнаяВМ)
	НоваяВМ = Новый Структура;
	
	Для Каждого Элемент Из ОсновнаяВМ Цикл
		НоваяВМ.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
	// Свежие стеки
	Стеки = Новый Структура;
	Стеки.Вставить("Стек", Новый Массив);
	Стеки.Вставить("СтекВызовов", Новый Массив);
	Стеки.Вставить("СтекВременныхПеременных", Новый Массив);
	Стеки.Вставить("СтекПопыток", Новый Массив);
	Стеки.Вставить("СтекОшибок", Новый Массив);
	НоваяВМ.Вставить("Стеки", Стеки);
	
	// Свежая отладка
	Отладка = Новый Структура;
	Отладка.Вставить("ОстановленоПоОшибке", Ложь);
	Отладка.Вставить("ОстановкаПоОшибке", ИсходнаяВМ.Отладка.ОстановкаПоОшибке);
	Отладка.Вставить("ОписаниеОшибки", Неопределено);
	Отладка.Вставить("МаксимальнаяГлубинаОстановки", Неопределено);
	НоваяВМ.Вставить("Отладка", Отладка);
	
	НоваяВМ.Вставить("КоличествоАргументов", 0);
	НоваяВМ.Вставить("НомерСтрокиОстанова", 0);
	НоваяВМ.Вставить("ИсходнаяВМ", ИсходнаяВМ);
	НоваяВМ.Вставить("ОсновнаяВМ", ОсновнаяВМ);
	
	Возврат НоваяВМ;
КонецФункции

// Инициализирует внешние переменные
// Получает значение внешней переменной из источника значений
// Возвращает Неопределено если значение не найдено
Функция НайтиЗначениеВнешнейПеременной(ИмяПеременнойВРег, ЗначенияВнешнихПеременных, Значение)
	Если ТипЗнч(ЗначенияВнешнихПеременных) = Тип("Структура") Тогда
		Возврат ЗначенияВнешнихПеременных.Свойство(ИмяПеременнойВРег, Значение);
	КонецЕсли;
	
	Значение = ЗначенияВнешнихПеременных[ИмяПеременнойВРег];
	Возврат Истина;
КонецФункции

Процедура ИнициализироватьВнешниеПеременные(Переменные, ЗначенияВнешнихПеременных)
	Если ЗначенияВнешнихПеременных = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Переменная Из Переменные Цикл
		// Поддерживаются переменные с флагом "Внешняя" (из оператора Выполнить)
		// и "НеявнаяМодульная" (из контекста отладчика через ДобавитьПеременную)
		Если Переменная.Флаг <> "Внешняя" И Переменная.Флаг <> "НеявнаяМодульная" Тогда
			Продолжить;
		КонецЕсли;
		
		ЗначениеИзВнешних = Неопределено;
		Если Не НайтиЗначениеВнешнейПеременной(ВРег(Переменная.Имя), ЗначенияВнешнихПеременных, ЗначениеИзВнешних) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЗначениеИзВнешних <> Неопределено Тогда
			Переменная.Значение = ЗначениеИзВнешних;
			Переменная.Инициализирована = Истина;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Заполняет ключи подпрограмм (исключая внешние)
Процедура ЗаполнитьКлючиПодпрограмм(КлючиПодпрограмм, Подпрограммы)
	Для Каждого Подпрограмма Из Подпрограммы Цикл
		Если Подпрограмма.Флаг <> "ВнешняяПроцедура" И Подпрограмма.Флаг <> "ВнешняяФункция" Тогда
			КлючиПодпрограмм.Вставить(ВРег(Подпрограмма.Имя), Подпрограмма);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Завершает отладку ВМ
Процедура ЗавершитьОтладкуВМ(ВМ, АдресВМ)
	ВМ.ОтладкаЗавершена = Истина;
	ВМ.НомерСтрокиОстанова = 0;
	
	Если ТипЗнч(АдресВМ) = Тип("Строка") Тогда
		ПоместитьВоВременноеХранилище(ВМ, АдресВМ);
	КонецЕсли;
КонецПроцедуры

// Получает строковое представление значения
Функция ПолучитьПредставлениеЗначения(Значение)
	Попытка
		Если ТипЗнч(Значение) = Тип("Строка") Тогда
			Возврат """" + Значение + """";
		ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда
			Возврат Формат(Значение, "БЛ=Ложь; БИ=Истина");
		ИначеЕсли Значение = Неопределено Тогда
			Возврат "Неопределено";
		ИначеЕсли Значение = Null Тогда
			Возврат "Null";
		Иначе
			Возврат Строка(Значение);
		КонецЕсли;
	Исключение
		Возврат "<" + Строка(ТипЗнч(Значение)) + ">";
	КонецПопытки;
КонецФункции

#КонецОбласти
#КонецОбласти

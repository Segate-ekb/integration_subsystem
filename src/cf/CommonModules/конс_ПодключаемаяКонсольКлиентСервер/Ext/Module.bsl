////////////////////////////////////////////////////////////////////////////////
// конс_ПодключаемаяКонсольКлиентСервер: Общие функции для клиента и сервера
////////////////////////////////////////////////////////////////////////////////
// Модуль содержит функции обработки ошибок и вспомогательные функции,
// которые используются как на клиенте, так и на сервере.
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область ОбработкаОшибок

// Создает пустую структуру описания ошибки.
// 
// Возвращаемое значение:
//   Структура - Пустое описание ошибки:
//     * Описание - Строка - текст ошибки
//     * НомерСтроки - Число - номер строки (0 если неизвестно)
//     * НомерКолонки - Число - номер колонки (1 по умолчанию)
//     * ИмяМодуля - Строка - имя модуля где произошла ошибка
//     * ИсходнаяСтрока - Строка - исходный код строки с ошибкой
//     * СтекВызовов - Массив - стек вызовов
//     * ЭтоВыполняемыйКод - Булево - ошибка в выполняемом коде
//     * Причина - Структура, Неопределено - вложенная ошибка (причина)
//
Функция НовоеОписаниеОшибки() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Описание", "");
	Результат.Вставить("НомерСтроки", 0);
	Результат.Вставить("НомерКолонки", 1);
	Результат.Вставить("ИмяМодуля", "");
	Результат.Вставить("ИсходнаяСтрока", "");
	Результат.Вставить("СтекВызовов", Новый Массив);
	Результат.Вставить("ЭтоВыполняемыйКод", Ложь);
	Результат.Вставить("Причина", Неопределено);
	
	Возврат Результат;
	
КонецФункции

// Разбирает стек ошибки из ПодробноеПредставлениеОшибки.
// Идёт с конца к началу, находит строку выполняемого кода {(номер)}.
// Учитывает вложенные ошибки после "по причине:".
// 
// Параметры:
//   ПолныйТекст - Строка - результат ПодробноеПредставлениеОшибки
//   ОписаниеОшибки - Строка - текст ошибки (первопричина, используется как fallback)
//
// Возвращаемое значение:
//   Структура - разобранная информация об ошибке (см. НовоеОписаниеОшибки)
//
Функция РазобратьСтекОшибки(ПолныйТекст, ОписаниеОшибки) Экспорт
	
	Результат = НовоеОписаниеОшибки();
	Результат.Описание = ОписаниеОшибки;
	
	// Разбиваем на строки
	СтрокиСтека = СтрРазделить(ПолныйТекст, Символы.ПС, Ложь);
	
	// Ищем "по причине:" - это триггер для поиска вложенной ошибки
	ИндексПоПричине = -1;
	Для Индекс = 0 По СтрокиСтека.ВГраница() Цикл
		Если СтрНайти(НРег(СтрокиСтека[Индекс]), "по причине:") > 0 Тогда
			ИндексПоПричине = Индекс;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// Есть вложенная ошибка - ищем после "по причине:"
	Если ИндексПоПричине >= 0 Тогда
		// Ищем первую строку с {<...>(...)} после "по причине:"
		Для Индекс = ИндексПоПричине + 1 По СтрокиСтека.ВГраница() Цикл
			Строка = СтрокиСтека[Индекс];
			ТриммированнаяСтрока = СокрЛ(Строка);
			
			Если СтрНачинаетсяС(ТриммированнаяСтрока, "{<") Тогда
				// Извлекаем позицию из формата {<Модуль>(строка,колонка)}
				Позиция = ИзвлечьПозициюИзМодульнойОшибки(Строка);
				Результат.НомерСтроки = Позиция.НомерСтроки;
				Результат.НомерКолонки = Позиция.НомерКолонки;
				Результат.ИмяМодуля = Позиция.ИмяМодуля;
				Результат.ЭтоВыполняемыйКод = Истина;
				
				// Описание: от этой строки и далее до конца блока
				Результат.Описание = ИзвлечьОписаниеОшибкиИзСтрок(СтрокиСтека, Индекс);
				
				// Извлекаем исходную строку (после }:)
				ПозицияДвоеточия = СтрНайти(Строка, "}:");
				Если ПозицияДвоеточия > 0 Тогда
					Результат.ИсходнаяСтрока = СокрЛП(Сред(Строка, ПозицияДвоеточия + 2));
				КонецЕсли;
				
				Возврат Результат;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Обычная ошибка - ищем {(номер)} с конца к началу
	ИндексСтрокиКода = -1;
	Индекс = СтрокиСтека.ВГраница();
	Пока Индекс >= 0 Цикл
		Строка = СтрокиСтека[Индекс];
		ТриммированнаяСтрока = СокрЛ(Строка);
		
		Если СтрНачинаетсяС(ТриммированнаяСтрока, "{(") Тогда
			ИндексСтрокиКода = Индекс;
			
			Позиция = ИзвлечьПозициюВыполняемогоКода(Строка);
			Результат.НомерСтроки = Позиция.НомерСтроки;
			Результат.НомерКолонки = Позиция.НомерКолонки;
			Результат.ЭтоВыполняемыйКод = Истина;
			
			ПозицияДвоеточия = СтрНайти(Строка, "}:");
			Если ПозицияДвоеточия > 0 Тогда
				Результат.ИсходнаяСтрока = СокрЛП(Сред(Строка, ПозицияДвоеточия + 2));
			КонецЕсли;
			
			Прервать;
		КонецЕсли;
		
		Индекс = Индекс - 1;
	КонецЦикла;
	
	// Описание: от начала до строки с ошибкой (или до "по причине:")
	Если ИндексСтрокиКода >= 0 Тогда
		КонечныйИндекс = ?(ИндексПоПричине >= 0, ИндексПоПричине - 1, ИндексСтрокиКода);
		Результат.Описание = ИзвлечьОписаниеОтНачалаДоИндекса(СтрокиСтека, КонечныйИндекс);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Извлекает позицию из описания ошибки выполняемого кода.
// Формат: {(строка,колонка)}:...
//
// Параметры:
//   ОписаниеОшибки - Строка - строка с описанием ошибки
//
// Возвращаемое значение:
//   Структура - позиция ошибки:
//     * НомерСтроки - Число
//     * НомерКолонки - Число
//
Функция ИзвлечьПозициюВыполняемогоКода(ОписаниеОшибки) Экспорт
	
	Результат = Новый Структура("НомерСтроки, НомерКолонки", 0, 1);
	
	// Проверяем формат {(строка,колонка)}:...
	Если Не СтрНачинаетсяС(СокрЛ(ОписаниеОшибки), "{(") Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем закрывающую скобку после {(
	ПозицияЗакрытия = СтрНайти(ОписаниеОшибки, ")");
	Если ПозицияЗакрытия <= 2 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Находим позицию {(
	ПозицияНачала = СтрНайти(ОписаниеОшибки, "{(");
	
	// Извлекаем координаты между {( и )
	СтрокаКоординат = Сред(ОписаниеОшибки, ПозицияНачала + 2, ПозицияЗакрытия - ПозицияНачала - 2);
	ИзвлечьКоординатыИзСтроки(СтрокаКоординат, Результат);
	
	Возврат Результат;
	
КонецФункции

// Извлекает позицию из описания ошибки с именем модуля.
// Формат: {<ИмяМодуля>(строка,колонка)}:...
// Например: {<Неизвестный модуль>(1,11)}:
//
// Параметры:
//   ОписаниеОшибки - Строка - строка с описанием ошибки
//
// Возвращаемое значение:
//   Структура - позиция ошибки:
//     * НомерСтроки - Число
//     * НомерКолонки - Число
//     * ИмяМодуля - Строка
//
Функция ИзвлечьПозициюИзМодульнойОшибки(ОписаниеОшибки) Экспорт
	
	Результат = Новый Структура("НомерСтроки, НомерКолонки, ИмяМодуля", 0, 1, "");
	
	ТриммированноеОписание = СокрЛ(ОписаниеОшибки);
	
	// Проверяем формат {<...
	Если Не СтрНачинаетсяС(ТриммированноеОписание, "{<") Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем закрывающую угловую скобку >
	ПозицияЗакрытияУгловой = СтрНайти(ТриммированноеОписание, ">");
	Если ПозицияЗакрытияУгловой <= 2 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Извлекаем имя модуля между {< и >
	Результат.ИмяМодуля = Сред(ТриммированноеОписание, 3, ПозицияЗакрытияУгловой - 3);
	
	// После > должна быть открывающая скобка (
	ОстатокСтроки = Сред(ТриммированноеОписание, ПозицияЗакрытияУгловой + 1);
	Если Не СтрНачинаетсяС(ОстатокСтроки, "(") Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем закрывающую скобку )
	ПозицияЗакрытияСкобки = СтрНайти(ОстатокСтроки, ")");
	Если ПозицияЗакрытияСкобки <= 1 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Извлекаем координаты между ( и )
	СтрокаКоординат = Сред(ОстатокСтроки, 2, ПозицияЗакрытияСкобки - 2);
	ИзвлечьКоординатыИзСтроки(СтрокаКоординат, Результат);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПреобразованиеТипов

// Безопасно преобразует строку в число.
// 
// Параметры:
//   Строка - Строка - строка для преобразования
//   ЗначениеПоУмолчанию - Число - значение при ошибке преобразования
//
// Возвращаемое значение:
//   Число - результат преобразования
//
Функция БезопасноеПреобразованиеВЧисло(Знач Строка, ЗначениеПоУмолчанию) Экспорт
	
	ОписаниеТипа = Новый ОписаниеТипов("Число");
	Результат = ОписаниеТипа.ПривестиЗначение(СокрЛП(Строка));
	
	Если Результат = 0 И СокрЛП(Строка) <> "0" Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Извлекает координаты (строка, колонка) из строки формата "N, M".
//
// Параметры:
//   СтрокаКоординат - Строка - строка вида "123, 45" или "123"
//   Результат - Структура - структура с ключами НомерСтроки и НомерКолонки (изменяется)
//
Процедура ИзвлечьКоординатыИзСтроки(СтрокаКоординат, Результат) Экспорт
	
	Части = СтрРазделить(СтрокаКоординат, ",");
	
	Если Части.Количество() >= 1 Тогда
		Результат.НомерСтроки = Макс(0, БезопасноеПреобразованиеВЧисло(СокрЛП(Части[0]), 0));
	КонецЕсли;
	
	Если Части.Количество() >= 2 Тогда
		Результат.НомерКолонки = Макс(1, БезопасноеПреобразованиеВЧисло(СокрЛП(Части[1]), 1));
	КонецЕсли;
	
КонецПроцедуры

// Извлекает описание ошибки от начала массива до указанного индекса (включительно).
// Пропускает строки типа [...] в конце.
//
// Параметры:
//   СтрокиСтека - Массив из Строка - все строки стека
//   КонечныйИндекс - Число - индекс последней строки для включения
//
// Возвращаемое значение:
//   Строка - описание ошибки
//
Функция ИзвлечьОписаниеОтНачалаДоИндекса(СтрокиСтека, КонечныйИндекс) Экспорт
	
	ЧастиОписания = Новый Массив;
	
	Для Индекс = 0 По Мин(КонечныйИндекс, СтрокиСтека.ВГраница()) Цикл
		Строка = СтрокиСтека[Индекс];
		ТриммированнаяСтрока = СокрЛП(Строка);
		
		// Пропускаем строки типа [ОшибкаВоВремяВыполнения...]
		Если СтрНачинаетсяС(ТриммированнаяСтрока, "[") Тогда
			Продолжить;
		КонецЕсли;
		
		ЧастиОписания.Добавить(Строка);
	КонецЦикла;
	
	Возврат СтрСоединить(ЧастиОписания, Символы.ПС);
	
КонецФункции

// Извлекает многострочное описание ошибки из массива строк.
// Начинает со строки с позицией ошибки (после }:) и продолжает до следующего {... или конца.
//
// Параметры:
//   СтрокиСтека - Массив из Строка - все строки стека
//   ИндексНачала - Число - индекс строки с {<...>(...)}:
//
// Возвращаемое значение:
//   Строка - описание ошибки
//
Функция ИзвлечьОписаниеОшибкиИзСтрок(СтрокиСтека, ИндексНачала) Экспорт
	
	ЧастиОписания = Новый Массив;
	
	// Первая строка - берём часть после }:
	ПерваяСтрока = СтрокиСтека[ИндексНачала];
	ПозицияДвоеточия = СтрНайти(ПерваяСтрока, "}:");
	Если ПозицияДвоеточия > 0 Тогда
		ТекстПослеДвоеточия = СокрЛП(Сред(ПерваяСтрока, ПозицияДвоеточия + 2));
		Если ЗначениеЗаполнено(ТекстПослеДвоеточия) Тогда
			ЧастиОписания.Добавить(ТекстПослеДвоеточия);
		КонецЕсли;
	КонецЕсли;
	
	// Продолжаем собирать следующие строки до {... или [...]
	Для Индекс = ИндексНачала + 1 По СтрокиСтека.ВГраница() Цикл
		Строка = СтрокиСтека[Индекс];
		ТриммированнаяСтрока = СокрЛ(Строка);
		
		// Останавливаемся на новом блоке ошибки или метке типа ошибки
		Если СтрНачинаетсяС(ТриммированнаяСтрока, "{")
			ИЛИ СтрНачинаетсяС(ТриммированнаяСтрока, "[") Тогда
			Прервать;
		КонецЕсли;
		
		// Добавляем строку к описанию
		Если ЗначениеЗаполнено(СокрЛП(Строка)) Тогда
			ЧастиОписания.Добавить(СокрЛП(Строка));
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(ЧастиОписания, Символы.ПС);
	
КонецФункции

#КонецОбласти


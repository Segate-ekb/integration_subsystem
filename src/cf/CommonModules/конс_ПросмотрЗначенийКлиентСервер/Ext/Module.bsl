// Модуль конс_ПросмотрЗначенийКлиентСервер
//
// Содержит функции для просмотра, анализа и отображения значений переменных в отладчике.
//
// Логическая структура модуля:
//  - Навигация по переменным: доступ к значениям по пути через вложенные свойства
//  - Формирование описаний переменных: построение структур для отображения в UI
//  - Работа с коллекциями: получение полей, элементов и количества элементов коллекций
//  - Определение типов: разрешение и анализ типов значений
//  - Представление значений: форматирование значений для отображения
//  - Вычисление выражений: выполнение произвольных BSL-выражений в контексте отладки
//  - Интроспекция данных формы: получение свойств данных формы через сериализацию
//
// Коды типов, используемые в структурах описания переменных:
//  1 — примитивный тип (Число, Строка, Булево, Дата, Неопределено, Null и т.п.)
//  2 — объект (ссылочные типы, объекты метаданных)
//  3 — составной тип (структуры, соответствия, коллекции с подчинёнными свойствами)

#Область ПрограммныйИнтерфейс

#Область НавигацияПоПеременным

// Получает значение переменной по пути через вложенные свойства.
// Если обращение по пути вызывает ошибку, выполняет альтернативный код через суффикс.
// 
// Параметры:
//  Переменные - Соответствие - коллекция переменных
//  ИмяПеременной - Строка - имя корневой переменной
//  ПутьКСвойству - Строка - путь через точку к вложенному свойству (например, "Реквизит.Поле")
//  СуффиксКода - Строка - суффикс для формирования альтернативного кода при ошибке доступа
//
// Возвращаемое значение:
//  Произвольный - значение переменной или её вложенного свойства
//
Функция ПолучитьПеременнуюПоПути(Переменные, ИмяПеременной, ПутьКСвойству, СуффиксКода) Экспорт
	
	СегментыПути = СтрРазделить(ПутьКСвойству, ".", Ложь);
	ТекПерем = Переменные[ИмяПеременной];
	
	Попытка
		Для Каждого СегментПути Из СегментыПути Цикл
			ТекПерем = ТекПерем[СегментПути];
		КонецЦикла;
	Исключение
		Выполнить "ТекПерем = Переменные[ИмяПеременной]" + СуффиксКода;
	КонецПопытки;
	
	Возврат ТекПерем;
	
КонецФункции

// Получает значение переменной по пути из хранилища данных или из переданного соответствия.
// Обёртка над ПолучитьПеременнуюПоПути с предварительным извлечением данных.
//
// Параметры:
//  ИмяПеременной - Строка - имя переменной
//  ДанныеИлиАдрес - Соответствие, Строка - данные переменных или адрес временного хранилища
//  ПутьКСвойству - Строка - путь к вложенному свойству через точку
//  СуффиксКода - Строка - суффикс кода для альтернативного доступа
//
// Возвращаемое значение:
//  Произвольный - значение переменной
//
Функция ПолучитьЗначениеТекущейПеременной(ИмяПеременной, ДанныеИлиАдрес, ПутьКСвойству, СуффиксКода) Экспорт
	
	ДанныеПеременных = ПолучитьДанныеИзХранилищаИлиЗначение(ДанныеИлиАдрес);
	
	ЗначениеПеременной = конс_ПросмотрЗначенийКлиентСервер.ПолучитьПеременнуюПоПути(
		ДанныеПеременных["Переменные"],
		ИмяПеременной,
		ПутьКСвойству,
		СуффиксКода);
	
	Возврат ЗначениеПеременной;
	
КонецФункции

#КонецОбласти

#Область ФормированиеОписанийПеременных

// Получает структуру с полным описанием переменной для отображения в отладчике.
// Для составных типов и объектов рекурсивно строит описания подчинённых свойств.
//
// Параметры:
//  ИмяПеременной - Строка - имя переменной
//  ДанныеИлиАдрес - Соответствие, Строка - данные переменных или адрес временного хранилища
//  ПутьКСвойству - Строка - путь к вложенному свойству через точку
//  СуффиксКода - Строка - суффикс для формирования альтернативного кода
//  ТекПерем - Произвольный - текущее значение переменной (если уже получено извне)
//
// Возвращаемое значение:
//  Структура, Неопределено - описание переменной со свойствами:
//    * Свойство - Строка - имя переменной
//    * Значение - Строка - строковое представление значения
//    * Тип - Строка - имя типа
//    * Код - Число - код типа (1=примитивный, 2=объект, 3=составной)
//    * ЭтоКоллекция - Булево - признак коллекции
//    * Количество - Число, Неопределено - количество элементов коллекции
//    * Подчиненные - Массив - (только для типов 2 и 3) массив описаний подчинённых свойств
//
Функция ПолучитьСтруктуруПеременной(ИмяПеременной, ДанныеИлиАдрес, ПутьКСвойству = "", СуффиксКода = "", ТекПерем = Неопределено) Экспорт
	
	ДанныеПеременных = ПолучитьДанныеИзХранилищаИлиЗначение(ДанныеИлиАдрес);
	СтруктурыТипов = ДанныеПеременных["СтруктурыТипов"];
	
	Если ТекПерем = Неопределено Тогда
		ТекПерем = конс_ПросмотрЗначенийКлиентСервер.ПолучитьПеременнуюПоПути(
			ДанныеПеременных["Переменные"],
			ИмяПеременной,
			ПутьКСвойству,
			СуффиксКода);
	КонецЕсли;
	
	СтруктураТипа = конс_ПросмотрЗначенийКлиентСервер.ПолучитьСтруктуруТипа(ТипЗнч(ТекПерем), СтруктурыТипов, ТекПерем);
	
	Если СтруктураТипа = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ОписаниеПеременной = СоздатьОписаниеПеременной(ИмяПеременной, ТекПерем, СтруктураТипа);
	
	Если СтруктураТипа.Код = 1 Тогда // Примитивный тип
		ОписаниеПеременной.Значение = ПолучитьПредставлениеЗначенияПримитивногоТипа(ТекПерем, СтруктурыТипов);
		
	ИначеЕсли СтруктураТипа.Код = 3 ИЛИ СтруктураТипа.Код = 2 Тогда // Составной тип или объект
		ОписаниеПеременной.Вставить("Подчиненные", Новый Массив);
		
		ДобавитьФиксированныеСвойства(ОписаниеПеременной, ТекПерем, СтруктураТипа, СтруктурыТипов);
		ДобавитьРасширяемыеСвойства(ОписаниеПеременной, ТекПерем, СтруктураТипа, СтруктурыТипов);
	КонецЕсли;
	
	Возврат ОписаниеПеременной;
	
КонецФункции

// Получает массив структур переменных для постраничного отображения элементов коллекции.
//
// Параметры:
//  ИмяПеременной - Строка - имя переменной-коллекции
//  ДанныеИлиАдрес - Соответствие, Строка - данные переменных или адрес временного хранилища
//  НачальныйИндекс - Число - начальный индекс (0-based) для выборки элементов
//  КоличествоЭлементов - Число - максимальное количество элементов в выборке
//
// Возвращаемое значение:
//  Массив из Структура - массив описаний переменных (см. ПолучитьСтруктуруПеременной)
//
Функция ПолучитьМассивСтруктурПеременных(ИмяПеременной, ДанныеИлиАдрес, НачальныйИндекс, КоличествоЭлементов) Экспорт
	
	ДанныеПеременных = ПолучитьДанныеИзХранилищаИлиЗначение(ДанныеИлиАдрес);
	СтруктурыТипов = ДанныеПеременных["СтруктурыТипов"];
	ИмяТипаНеопределено = СтруктурыТипов[ТипЗнч(Неопределено)].Имя;
	МассивЗначений = ДанныеПеременных[ИмяПеременной];
	
	Результат = Новый Массив;
	КонечныйИндекс = Мин(НачальныйИндекс + КоличествоЭлементов, МассивЗначений.Количество());
	
	Пока НачальныйИндекс < КонечныйИндекс Цикл
		ТекущийЭлемент = МассивЗначений[НачальныйИндекс];
		
		СтруктураПеременной = ?(ТекущийЭлемент = Неопределено,
			Новый Структура("Код,Тип,Значение", 1, ИмяТипаНеопределено, Строка(ТекущийЭлемент)),
			конс_ПросмотрЗначенийКлиентСервер.ПолучитьСтруктуруПеременной(ИмяПеременной, ДанныеИлиАдрес, , , ТекущийЭлемент));
		
		Результат.Добавить(СтруктураПеременной);
		НачальныйИндекс = НачальныйИндекс + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область РаботаСКоллекциями

// Получает соответствие всех полей элементов коллекции для формирования колонок таблицы.
// Перебирает все элементы коллекции и собирает уникальные имена свойств.
//
// Параметры:
//  ИмяПеременной - Строка - имя переменной-коллекции
//  ДанныеИлиАдрес - Соответствие, Строка - данные переменных или адрес временного хранилища
//
// Возвращаемое значение:
//  Соответствие - ключи — имена полей, значения — Истина
//
Функция ПолучитьСоответствиеПолейКоллекции(ИмяПеременной, ДанныеИлиАдрес) Экспорт
	
	СоответствиеПолей = Новый Соответствие;
	МассивЭлементов = Новый Массив;
	
	ДанныеПеременных = ПолучитьДанныеИзХранилищаИлиЗначение(ДанныеИлиАдрес);
	СтруктурыТипов = ДанныеПеременных["СтруктурыТипов"];
	КоллекцияЗначений = ДанныеПеременных["Переменные"][ИмяПеременной];
	
	Для Каждого ТекПерем Из КоллекцияЗначений Цикл
		ТипЭлемента = ТипЗнч(ТекПерем);
		СтруктураТипа = конс_ПросмотрЗначенийКлиентСервер.ПолучитьСтруктуруТипа(ТипЭлемента, СтруктурыТипов, ТекПерем);
		
		// Фиксированные (статически известные) свойства
		Для Каждого ЭлементСвойства Из СтруктураТипа.Свойства Цикл
			Попытка
				ЗначениеПоля = ТекПерем[ЭлементСвойства.Ключ];
				СоответствиеПолей.Вставить(ЭлементСвойства.Ключ, Истина);
			Исключение
			КонецПопытки;
		КонецЦикла;
		
		// Расширяемые (динамически определяемые) свойства
		// Переменные СоответствиеПолей и ТекПерем доступны из области видимости Выполнить()
		Для Каждого РасширяемоеСвойство Из СтруктураТипа.РасширяемыеСвойства Цикл
			ИмяКоллекции = ?(ЗначениеЗаполнено(РасширяемоеСвойство.КоллекцияПуть),
				РасширяемоеСвойство.КоллекцияПуть, "ТекПерем");
			ВыражениеИмениСвойства = ?(ЗначениеЗаполнено(РасширяемоеСвойство.ИмяСвойстваПуть),
				РасширяемоеСвойство.ИмяСвойстваПуть, "ЭлементКоллекции");
			
			ТекстАлгоритма = РасширяемоеСвойство.АлгоритмФормированияКоллекции + Символы.ПС;
			ТекстАлгоритма = ТекстАлгоритма + "
				|Для Каждого ЭлементКоллекции Из " + ИмяКоллекции + " Цикл
				|	СоответствиеПолей.Вставить(" + ВыражениеИмениСвойства + ", Истина);
				|КонецЦикла;";
			
			Выполнить(ТекстАлгоритма);
		КонецЦикла;
		
		МассивЭлементов.Добавить(ТекПерем);
	КонецЦикла;
	
	ДанныеПеременных.Вставить(ИмяПеременной, МассивЭлементов);
	
	Возврат СоответствиеПолей;
	
КонецФункции

// Получает количество элементов в коллекции по имени переменной и пути.
//
// Параметры:
//  ИмяПеременной - Строка - имя переменной-коллекции
//  ДанныеИлиАдрес - Соответствие, Строка - данные переменных или адрес временного хранилища
//  ПутьКСвойству - Строка - путь к свойству-коллекции
//  СуффиксКода - Строка - суффикс кода для альтернативного доступа
//
// Возвращаемое значение:
//  Число - количество элементов (0, если не удалось определить)
//
Функция ПолучитьКоличествоЭлементовКоллекции(ИмяПеременной, ДанныеИлиАдрес, ПутьКСвойству, СуффиксКода) Экспорт
	
	ЗначениеПеременной = конс_ПросмотрЗначенийКлиентСервер.ПолучитьЗначениеТекущейПеременной(
		ИмяПеременной,
		ДанныеИлиАдрес,
		ПутьКСвойству,
		СуффиксКода);
	
	Попытка
		Возврат ЗначениеПеременной.Количество();
	Исключение
		Возврат 0;
	КонецПопытки;
	
КонецФункции

// Получает количество элементов переменной, если она является коллекцией.
//
// Параметры:
//  ЭтоКоллекция - Булево - признак того, что значение является коллекцией
//  Значение - Произвольный - значение переменной
//
// Возвращаемое значение:
//  Число, Неопределено - количество элементов, или Неопределено если не коллекция
//
Функция ПолучитьКоличествоЭлементовПеременной(ЭтоКоллекция, Значение) Экспорт
	
	Если ЭтоКоллекция Тогда
		Попытка
			КоличествоЭлементов = Значение.Количество();
			Возврат КоличествоЭлементов;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ОпределениеТипов

// Получает структуру описания типа для произвольного значения.
// Последовательно пытается определить тип: по прямому соответствию в реестре,
// по XML-типу, по строковому представлению типа. Если тип не найден,
// возвращает базовую структуру с кодом примитивного типа.
//
// Параметры:
//  ТипЗначения - Тип - тип значения (результат ТипЗнч())
//  СтруктурыТипов - Соответствие - реестр типов из системы типов отладчика
//  Значение - Произвольный - значение для анализа (используется как fallback для имени типа)
//
// Возвращаемое значение:
//  Структура - описание типа со свойствами:
//    * Имя - Строка - имя типа для отображения
//    * Код - Число - код типа (1=примитивный, 2=объект, 3=составной)
//    * ЭтоКоллекция - Булево - признак коллекции
//    * Свойства - Массив - список описаний фиксированных свойств
//    * РасширяемыеСвойства - Массив - список описаний расширяемых свойств
//
Функция ПолучитьСтруктуруТипа(ТипЗначения, СтруктурыТипов, Значение) Экспорт
	
	// 1. Прямой поиск в реестре типов
	СтруктураТипа = СтруктурыТипов[ТипЗначения];
	
	Если СтруктураТипа <> Неопределено Тогда
		Возврат СтруктураТипа;
	КонецЕсли;
	
	// 2. Поиск по XML-представлению типа (например, "CatalogRef.Номенклатура")
	СтруктураТипа = НайтиСтруктуруТипаПоXML(ТипЗначения, СтруктурыТипов, Значение);
	
	Если СтруктураТипа <> Неопределено Тогда
		Возврат СтруктураТипа;
	КонецЕсли;
	
	// 3. Поиск по строковому представлению типа (например, "Справочник: Номенклатура")
	СтруктураТипа = НайтиСтруктуруТипаПоСтроковомуПредставлению(ТипЗначения, СтруктурыТипов, Значение);
	
	Если СтруктураТипа <> Неопределено Тогда
		Возврат СтруктураТипа;
	КонецЕсли;
	
	// 4. Неизвестный тип: возвращаем базовую структуру
	СтруктураТипа = Новый Структура("Имя,Код,ЭтоКоллекция,Свойства,РасширяемыеСвойства",
		Строка(ТипЗначения), 1, Ложь, Новый Массив, Новый Массив); // Код 1 = примитивный
	
	Возврат СтруктураТипа;
	
КонецФункции

#КонецОбласти

#Область ПредставлениеЗначений

// Получает строковое представление произвольного значения.
// Безопасная обёртка над Строка() с обработкой ошибок.
//
// Параметры:
//  Значение - Произвольный - значение для преобразования в строку
//
// Возвращаемое значение:
//  Строка - строковое представление, или пустая строка при ошибке
//
Функция ПолучитьСтроковоеПредставлениеЗначения(Значение) Экспорт
	
	Попытка
		СтроковоеПредставление = Строка(Значение);
	Исключение
		СтроковоеПредставление = "";
	КонецПопытки;
	
	Возврат СтроковоеПредставление;
	
КонецФункции

// Получает форматированное представление значения примитивного типа.
// Для булевых значений учитывает текущую локаль (русский/английский).
// Для строк оборачивает значение в кавычки.
//
// Параметры:
//  Значение - Произвольный - значение примитивного типа
//  СтруктурыТипов - Соответствие - реестр типов (для определения локали)
//
// Возвращаемое значение:
//  Строка - форматированное представление значения
//
Функция ПолучитьПредставлениеЗначенияПримитивногоТипа(Значение, СтруктурыТипов) Экспорт
	
	Если ТипЗнч(Значение) = Тип("Булево") Тогда
		ЛокальРусский = (СтруктурыТипов[Тип("Булево")].Имя = "Булево");
		Если ЛокальРусский Тогда
			Возврат Формат(Значение, "БЛ=Ложь; БИ=Истина");
		Иначе
			Возврат Формат(Значение, "BF=False; BT=True");
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда
		Возврат """" + Значение + """";
		
	Иначе
		Попытка
			Возврат Строка(Значение);
		Исключение
			Возврат "";
		КонецПопытки;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ВычислениеВыражений

// Вычисляет произвольное BSL-выражение в контексте текущей отладочной сессии.
// Компилирует выражение, создаёт виртуальную машину, переносит значения переменных
// из контекста отладки и выполняет код.
//
// Параметры:
//  ТекстВыражения - Строка - текст BSL-выражения для вычисления
//  ДанныеИлиАдрес - Соответствие, Строка - данные контекста отладки или адрес временного хранилища
//  ФормаОтладчика - Число - индекс текущего кадра стека вызовов
//
// Возвращаемое значение:
//  Соответствие - результат с ключами:
//    * "Переменные" - Соответствие - ключ: текст выражения, значение: вычисленный результат
//    * "СтруктурыТипов" - Соответствие - реестр типов из контекста отладки
//
Функция ПолучитьДанныеПеременныхПоВыражению(ТекстВыражения, ДанныеИлиАдрес, ФормаОтладчика) Экспорт
	
	Если ТипЗнч(ДанныеИлиАдрес) = Тип("Строка") Тогда
		ДанныеКонтекста = ПолучитьИзВременногоХранилища(ДанныеИлиАдрес);
	Иначе
		ДанныеКонтекста = ДанныеИлиАдрес;
	КонецЕсли;
	
	// Подготовка результирующей структуры
	СоответствиеПеременных = Новый Соответствие;
	Результат = Новый Соответствие;
	Результат.Вставить("Переменные", СоответствиеПеременных);
	Результат.Вставить("СтруктурыТипов", ДанныеКонтекста.СтруктурыТипов);
	
	Если Не ЗначениеЗаполнено(ТекстВыражения) Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Компиляция: оборачиваем выражение в присваивание временной переменной,
	// чтобы получить результат через значение этой переменной после выполнения
	ИмяВременнойПеременной = "_99afce8902cc44e1aadf8f8ecbe3f4d1";
	ТекстКода = ИмяВременнойПеременной + " = " + ТекстВыражения;
	
	РезультатКомпиляции = конс_КомпиляцияКлиентСервер.ВыполнитьКомпиляцию(
		ТекстКода,
		ДанныеКонтекста.АдресТаблицПерехода,
		Истина);
	
	Если Не РезультатКомпиляции.ВыполнениеВозможно Тогда
		ВызватьИсключение "Ошибка в выражении";
	КонецЕсли;
	
	// Инициализация виртуальной машины для выполнения скомпилированного кода
	СостояниеВМ = конс_ВМ_КлиентСервер.СоздатьВложеннуюВМДляВыполнения(ДанныеКонтекста, РезультатКомпиляции);
	
	// Перенос значений переменных из контекста отладки в виртуальную машину,
	// чтобы выражение могло обращаться к текущим значениям переменных
	СоответствиеЗначенийКонтекста = СобратьЗначенияПеременныхКонтекста(ДанныеКонтекста, ФормаОтладчика);
	ПеренестиЗначенияКонтекстаВВМ(СостояниеВМ, СоответствиеЗначенийКонтекста, ИмяВременнойПеременной);
	
	// Выполнение кода в ВМ и извлечение результата из временной переменной
	конс_ВМ_КлиентСервер.ПродолжитьОтладку(СостояниеВМ, Неопределено, Ложь, Новый Соответствие);
	СоответствиеПеременных.Вставить(ТекстВыражения, СостояниеВМ.Программа.Переменные[0].Значение);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ИнтроспекцияДанныхФормы

// Получает массив имён свойств данных формы через сериализацию FastInfoset.
// Используется для типов ДанныеФормыСтруктура, свойства которых невозможно
// получить стандартными средствами.
//
// Параметры:
//  ДанныеФормы - ДанныеФормыСтруктура - данные формы для анализа
//
// Возвращаемое значение:
//  Массив из Строка - массив имён свойств (предпочтительно русские имена)
//
Функция ПолучитьМассивИменСвойствДанныхФормы(ДанныеФормы) Экспорт
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(ДанныеФормы);
	
	ЗаписьFI = Новый ЗаписьFastInfoset;
	ЗаписьFI.УстановитьДвоичныеДанные();
	СериализаторXDTO.ЗаписатьXML(ЗаписьFI, МассивДанных);
	
	ЧтениеFI = Новый ЧтениеFastInfoset;
	ЧтениеFI.УстановитьДвоичныеДанные(ЗаписьFI.Закрыть());
	
	МассивИменСвойств = Новый Массив;
	
	Пока ЧтениеFI.Прочитать() Цикл
		Если ЧтениеFI.Имя = "field" И ЧтениеFI.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			ИмяПоля = ЧтениеFI.ЗначениеАтрибута("nameRu");
			Если ИмяПоля = Неопределено Тогда
				ИмяПоля = ЧтениеFI.ЗначениеАтрибута("name");
			КонецЕсли;
			
			Если ИмяПоля <> Неопределено Тогда
				МассивИменСвойств.Добавить(ИмяПоля);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивИменСвойств;
	
КонецФункции

#КонецОбласти

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

// {{{ Формирование описаний переменных

// Создаёт базовую структуру описания переменной (без подчинённых свойств).
//
// Параметры:
//  ИмяПеременной - Строка - имя переменной
//  ЗначениеПеременной - Произвольный - текущее значение
//  СтруктураТипа - Структура - описание типа переменной
//
// Возвращаемое значение:
//  Структура - базовое описание переменной
//
Функция СоздатьОписаниеПеременной(ИмяПеременной, ЗначениеПеременной, СтруктураТипа)
	
	Описание = Новый Структура("Свойство,Значение,Тип,Код,ЭтоКоллекция,Количество");
	Описание.Свойство = ИмяПеременной;
	Описание.Тип = СтруктураТипа.Имя;
	Описание.Код = СтруктураТипа.Код;
	Описание.ЭтоКоллекция = СтруктураТипа.ЭтоКоллекция;
	Описание.Количество = ПолучитьКоличествоЭлементовПеременной(Описание.ЭтоКоллекция, ЗначениеПеременной);
	Описание.Значение = ПолучитьСтроковоеПредставлениеЗначения(ЗначениеПеременной);
	
	Возврат Описание;
	
КонецФункции

// Добавляет описания фиксированных (статически известных) свойств объекта
// к массиву подчинённых элементов описания переменной.
//
// Параметры:
//  ОписаниеПеременной - Структура - описание переменной с массивом Подчиненные
//  ТекПерем - Произвольный - значение переменной
//  СтруктураТипа - Структура - описание типа со списком фиксированных свойств
//  СтруктурыТипов - Соответствие - реестр типов
//
Процедура ДобавитьФиксированныеСвойства(ОписаниеПеременной, ТекПерем, СтруктураТипа, СтруктурыТипов)
	
	ТекстОшибкиПоля = НСтр("ru='Поле объекта не обнаружено';en='Object field not found'", ТекущийЯзыкСистемы());
	
	Для Каждого ЭлементСвойства Из СтруктураТипа.Свойства Цикл
		ОписаниеСвойства = ПолучитьОписаниеФиксированногоСвойства(
			ЭлементСвойства.Ключ, ТекПерем, СтруктурыТипов, ТекстОшибкиПоля);
		
		Если ОписаниеСвойства <> Неопределено Тогда
			ОписаниеПеременной.Подчиненные.Добавить(ОписаниеСвойства);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Получает описание одного фиксированного свойства объекта.
//
// Параметры:
//  ИмяСвойства - Строка - имя свойства
//  ТекПерем - Произвольный - значение родительского объекта
//  СтруктурыТипов - Соответствие - реестр типов
//  ТекстОшибкиПоля - Строка - текст ошибки "Поле объекта не обнаружено"
//
// Возвращаемое значение:
//  Структура, Неопределено - описание свойства, или Неопределено если поле не существует
//
Функция ПолучитьОписаниеФиксированногоСвойства(ИмяСвойства, ТекПерем, СтруктурыТипов, ТекстОшибкиПоля)
	
	Попытка
		ЗначениеСвойства = ТекПерем[ИмяСвойства];
		СтруктураТипаСвойства = конс_ПросмотрЗначенийКлиентСервер.ПолучитьСтруктуруТипа(
			ТипЗнч(ЗначениеСвойства),
			СтруктурыТипов,
			ЗначениеСвойства);
	Исключение
		ТекстОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Если СтрНачинаетсяС(ТекстОшибки, ТекстОшибкиПоля) Тогда
			Возврат Неопределено; // Свойство не существует у данного объекта — пропускаем
		Иначе
			Возврат Новый Структура("Свойство,Значение,Тип,Код,ЭтоКоллекция,Количество",
				ИмяСвойства, ТекстОшибки, , 1, Ложь); // Код 1 = примитивное представление ошибки
		КонецЕсли;
	КонецПопытки;
	
	ОписаниеСвойства = Новый Структура("Свойство,Значение,Тип,Код,ЭтоКоллекция,Количество",
		ИмяСвойства,
		ПолучитьСтроковоеПредставлениеЗначения(ЗначениеСвойства),
		СтруктураТипаСвойства.Имя,
		СтруктураТипаСвойства.Код,
		СтруктураТипаСвойства.ЭтоКоллекция,
		ПолучитьКоличествоЭлементовПеременной(СтруктураТипаСвойства.ЭтоКоллекция, ЗначениеСвойства));
	
	Если СтруктураТипаСвойства.Код = 1 Тогда // Примитивный тип — форматируем значение
		ОписаниеСвойства.Значение = ПолучитьПредставлениеЗначенияПримитивногоТипа(ЗначениеСвойства, СтруктурыТипов);
	КонецЕсли;
	
	Возврат ОписаниеСвойства;
	
КонецФункции

// Добавляет описания расширяемых (динамически определяемых) свойств объекта.
// Использует Выполнить() для обработки алгоритмов формирования коллекций из описания типа.
//
// Важно: Переменные ОписаниеПеременной, ТекПерем, СтруктурыТипов доступны
// в области видимости Выполнить() и используются в формируемом алгоритме.
//
// Параметры:
//  ОписаниеПеременной - Структура - описание переменной с массивом Подчиненные
//  ТекПерем - Произвольный - значение переменной
//  СтруктураТипа - Структура - описание типа со списком расширяемых свойств
//  СтруктурыТипов - Соответствие - реестр типов
//
Процедура ДобавитьРасширяемыеСвойства(ОписаниеПеременной, ТекПерем, СтруктураТипа, СтруктурыТипов)
	
	// Формируем массив имён общих реквизитов конфигурации.
	// Переменная доступна из контекста Выполнить() для обхода общих реквизитов объекта.
	МассивИменОбщихРеквизитов = Новый Массив;
	Для Каждого ОбщийРеквизит Из Метаданные.ОбщиеРеквизиты Цикл
		МассивИменОбщихРеквизитов.Добавить(ОбщийРеквизит.Имя);
	КонецЦикла;
	
	Для Каждого РасширяемоеСвойство Из СтруктураТипа.РасширяемыеСвойства Цикл
		ИмяКоллекции = ?(ЗначениеЗаполнено(РасширяемоеСвойство.КоллекцияПуть),
			РасширяемоеСвойство.КоллекцияПуть, "ТекПерем");
		ВыражениеИмениСвойства = ?(ЗначениеЗаполнено(РасширяемоеСвойство.ИмяСвойстваПуть),
			РасширяемоеСвойство.ИмяСвойстваПуть, "ЭлементКоллекции");
		ВыражениеЗначенияСвойства = ?(ЗначениеЗаполнено(РасширяемоеСвойство.ЗначениеСвойстваПуть),
			РасширяемоеСвойство.ЗначениеСвойстваПуть, "ЭлементКоллекции");
		
		// Формирование текста алгоритма для динамического обхода коллекции.
		// Переменные стПеремСвойство, стСтруктураТипа, ЗначениеСвойства — 
		// локальные для контекста Выполнить(), создаются внутри алгоритма.
		ТекстАлгоритма = РасширяемоеСвойство.АлгоритмФормированияКоллекции + Символы.ПС;
		ТекстАлгоритма = ТекстАлгоритма + "
			|Для Каждого ЭлементКоллекции Из " + ИмяКоллекции + " Цикл
			|	стПеремСвойство = Неопределено;
			|	Попытка
			|		ЗначениеСвойства = " + ВыражениеЗначенияСвойства + ";
			|		стСтруктураТипа = конс_ПросмотрЗначенийКлиентСервер.ПолучитьСтруктуруТипа(ТипЗнч(ЗначениеСвойства), СтруктурыТипов, ЗначениеСвойства);
			|	Исключение
			|		стПеремСвойство = Новый Структура(""Свойство,Значение,Тип,Код,ЭтоКоллекция,Количество"", " + ВыражениеИмениСвойства + ", КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),, 1, Ложь);
			|	КонецПопытки;
			|
			|	Если стПеремСвойство = Неопределено Тогда
			|		стПеремСвойство = Новый Структура(""Свойство,Значение,Тип,Код,ЭтоКоллекция,Количество"", " + ВыражениеИмениСвойства + ", ПолучитьСтроковоеПредставлениеЗначения(ЗначениеСвойства),
			|		стСтруктураТипа.Имя, стСтруктураТипа.Код, стСтруктураТипа.ЭтоКоллекция, ПолучитьКоличествоЭлементовПеременной(стСтруктураТипа.ЭтоКоллекция, ЗначениеСвойства));
			| 		Если стСтруктураТипа.Код = 1 Тогда
			|			стПеремСвойство.Значение = ПолучитьПредставлениеЗначенияПримитивногоТипа(ЗначениеСвойства, СтруктурыТипов);
			|    	КонецЕсли;
			|	КонецЕсли;
			|
			|	ОписаниеПеременной.Подчиненные.Добавить(стПеремСвойство);
			|КонецЦикла;";
		
		Выполнить(ТекстАлгоритма);
	КонецЦикла;
	
КонецПроцедуры

// }}}

// {{{ Определение типов

// Пытается найти структуру типа по XML-представлению типа.
// XML-тип имеет формат "КатегорияОбъекта.ИмяОбъекта" (например, "CatalogRef.Номенклатура").
//
Функция НайтиСтруктуруТипаПоXML(ТипЗначения, СтруктурыТипов, Значение)
	
	ДанныеXMLТипа = XMLТип(ТипЗначения);
	
	Если ДанныеXMLТипа = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЧастиИмениТипа = СтрРазделить(ДанныеXMLТипа.ИмяТипа, ".", Ложь);
	
	Если ЧастиИмениТипа.Количество() = 2 Тогда
		Возврат ПолучитьСтруктуруТипаПоЧастямИмени(ЧастиИмениТипа, СтруктурыТипов, Значение);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Пытается найти структуру типа по строковому представлению через Строка(Тип).
// Строковое представление имеет формат "Категория: Объект" (например, "Справочник: Номенклатура").
// Части преобразуются в PascalCase для сопоставления с реестром типов.
//
Функция НайтиСтруктуруТипаПоСтроковомуПредставлению(ТипЗначения, СтруктурыТипов, Значение)
	
	СтроковоеПредставлениеТипа = Строка(ТипЗначения);
	ЧастиИмениТипа = СтрРазделить(СтроковоеПредставлениеТипа, ":", Ложь);
	
	Если ЧастиИмениТипа.Количество() <> 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЧастиИмениТипа[0] = ПреобразоватьВПаскальКейс(ЧастиИмениТипа[0]);
	ЧастиИмениТипа[1] = ПреобразоватьВПаскальКейс(ЧастиИмениТипа[1]);
	
	Возврат ПолучитьСтруктуруТипаПоЧастямИмени(ЧастиИмениТипа, СтруктурыТипов, Значение);
	
КонецФункции

// Получает структуру типа по двум частям составного имени типа.
// Сначала проверяет, является ли имя суффиксом табличной части,
// затем ищет базовый тип в реестре и формирует полное имя.
//
Функция ПолучитьСтруктуруТипаПоЧастямИмени(ЧастиИмениТипа, СтруктурыТипов, Значение)
	
	ИмяБазовогоТипа = ЧастиИмениТипа[0];
	НайденныйСуффикс = Неопределено;
	СуффиксыТабличнойЧасти = ПолучитьСуффиксыТабличнойЧасти();
	
	Для Каждого Суффикс Из СуффиксыТабличнойЧасти Цикл
		Если СтрЗаканчиваетсяНа(ИмяБазовогоТипа, Суффикс) Тогда
			ИмяБазовогоТипа = Суффикс;
			НайденныйСуффикс = Суффикс;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	БазоваяСтруктураТипа = СтруктурыТипов[ИмяБазовогоТипа];
	
	Если БазоваяСтруктураТипа = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураТипа = Новый Структура("Имя,Код,ЭтоКоллекция,Свойства,РасширяемыеСвойства");
	ЗаполнитьЗначенияСвойств(СтруктураТипа, БазоваяСтруктураТипа);
	
	// Для табличных частей используем строковое представление значения,
	// для остальных — формируем составное имя "БазовыйТип.ИмяОбъекта"
	СтруктураТипа.Имя = ?(НайденныйСуффикс <> Неопределено,
		Строка(Значение),
		БазоваяСтруктураТипа.Имя + "." + ЧастиИмениТипа[1]);
	
	Возврат СтруктураТипа;
	
КонецФункции

// Преобразует строку в формат PascalCase.
// Разделители: пробел и дефис.
//
// Параметры:
//  ИсходнаяСтрока - Строка - строка для преобразования (например, "tabular-section")
//
// Возвращаемое значение:
//  Строка - строка в PascalCase (например, "TabularSection")
//
Функция ПреобразоватьВПаскальКейс(ИсходнаяСтрока)
	
	Результат = "";
	ЧастиСлова = СтрРазделить(СтрЗаменить(ИсходнаяСтрока, "-", " "), " ", Ложь);
	
	Для Каждого ЧастьСлова Из ЧастиСлова Цикл
		Результат = Результат + ВРег(Лев(ЧастьСлова, 1)) + Сред(ЧастьСлова, 2);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает массив суффиксов, используемых для идентификации типов табличных частей.
//
Функция ПолучитьСуффиксыТабличнойЧасти()
	
	Суффиксы = Новый Массив;
	Суффиксы.Добавить("ТабличнаяЧасть");
	Суффиксы.Добавить("TabularSection");
	Суффиксы.Добавить("ТабличнаяЧастьСтрока");
	Суффиксы.Добавить("TabularSectionLine");
	
	Возврат Суффиксы;
	
КонецФункции

// }}}

// {{{ Вычисление выражений

// Собирает значения инициализированных переменных из контекста отладки 
// (глобальные переменные модуля + локальные переменные текущего кадра стека вызовов)
// в соответствие для последующего переноса в виртуальную машину.
// Переменные с именами, начинающимися на "0", пропускаются (служебные).
//
// Параметры:
//  ДанныеКонтекста - Структура - данные контекста отладки
//  ИндексСтекаВызовов - Число - индекс текущего кадра стека вызовов
//
// Возвращаемое значение:
//  Соответствие - ключ: имя переменной в верхнем регистре, 
//                 значение: Структура с единственным полем "Значение"
//
Функция СобратьЗначенияПеременныхКонтекста(ДанныеКонтекста, ИндексСтекаВызовов)
	
	СоответствиеЗначений = Новый Соответствие;
	
	// Глобальные переменные модуля
	Для Каждого Переменная Из ДанныеКонтекста.Программа.Переменные Цикл
		Если Переменная.Инициализирована И Не СтрНачинаетсяС(Переменная.Имя, "0") Тогда
			СоответствиеЗначений.Вставить(ВРег(Переменная.Имя),
				Новый Структура("Значение", Переменная.Значение));
		КонецЕсли;
	КонецЦикла;
	
	// Локальные переменные текущего кадра стека вызовов
	// (перезаписывают глобальные при совпадении имён — как в реальном исполнении)
	КоличествоВызовов = ДанныеКонтекста.Стеки.СтекВызовов.Количество();
	Если КоличествоВызовов > 0 И ИндексСтекаВызовов < КоличествоВызовов Тогда
		Для Каждого Переменная Из ДанныеКонтекста.Стеки.СтекВызовов[ИндексСтекаВызовов].Переменные Цикл
			Если Переменная.Инициализирована И Не СтрНачинаетсяС(Переменная.Имя, "0") Тогда
				СоответствиеЗначений.Вставить(ВРег(Переменная.Имя),
					Новый Структура("Значение", Переменная.Значение));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СоответствиеЗначений;
	
КонецФункции

// Переносит собранные значения переменных контекста в переменные виртуальной машины.
// Для временной переменной результата сбрасывает флаг, чтобы команда ASSIGN 
// записывала значение напрямую через ".Значение", а не через Выполнить().
//
// Параметры:
//  СостояниеВМ - Структура - текущее состояние виртуальной машины (содержит массив Переменные)
//  СоответствиеЗначенийКонтекста - Соответствие - собранные значения (см. СобратьЗначенияПеременныхКонтекста)
//  ИмяВременнойПеременной - Строка - имя переменной для хранения результата выражения
//
Процедура ПеренестиЗначенияКонтекстаВВМ(СостояниеВМ, СоответствиеЗначенийКонтекста, ИмяВременнойПеременной)
	
	Для Каждого ПеременнаяВМ Из СостояниеВМ.Программа.Переменные Цикл
		Если ВРег(ПеременнаяВМ.Имя) = ВРег(ИмяВременнойПеременной) Тогда
			// Переменная результата: сбрасываем Флаг,
			// чтобы ASSIGN записывал значение в .Значение, а не через Выполнить()
			ПеременнаяВМ.Флаг = "НеявнаяМодульная";
		Иначе
			ОберткаЗначения = СоответствиеЗначенийКонтекста[ВРег(ПеременнаяВМ.Имя)];
			Если ОберткаЗначения <> Неопределено Тогда
				ПеременнаяВМ.Значение = ОберткаЗначения.Значение;
				ПеременнаяВМ.Инициализирована = Истина;
				ПеременнаяВМ.Флаг = "НеявнаяМодульная";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// }}}

// {{{ Общие утилиты

// Извлекает данные переменных из временного хранилища или возвращает значение напрямую.
//
// Параметры:
//  ДанныеИлиАдрес - Соответствие, Строка - если Соответствие — возвращается как есть,
//                   иначе интерпретируется как адрес временного хранилища
//
// Возвращаемое значение:
//  Соответствие - данные переменных
//
Функция ПолучитьДанныеИзХранилищаИлиЗначение(ДанныеИлиАдрес)
	
	Если ТипЗнч(ДанныеИлиАдрес) = Тип("Соответствие") Тогда
		Возврат ДанныеИлиАдрес;
	Иначе
		Возврат ПолучитьИзВременногоХранилища(ДанныеИлиАдрес);
	КонецЕсли;
	
КонецФункции

// }}}

#КонецОбласти

// Компилятор встроенного языка BSL (1C:Enterprise)
//
// Модуль реализует компиляцию исходного кода BSL:
//   1. Построение AST - делегируется конс_АСТ_ПостроительКлиентСервер.Разобрать()
//      (лексический анализ, препроцессор, синтаксический анализ)
//   2. Обход AST (post-order) - ОбойтиДеревоАСТ
//   3. Семантический анализ (действия при обходе узлов) - процедуры _*
//   4. Генерация байт-кода виртуальной машины - через ДобавитьКомандуВМ
//
// AST может использоваться независимо (инлайнер, анализ кода и т.д.)
// через конс_АСТ_ПостроительКлиентСервер.Разобрать()
//
// Семантические действия делегируются в конс_КомпиляцияСемантикаКлиентСервер.
//   конс_КомпиляцияСемантикаКлиентСервер.ВыполнитьСемантическоеДействие(...)
// Имена процедур _* определяются грамматикой и НЕ подлежат переименованию.
//
// Флаги подпрограмм (строковые константы):
//   "Процедура"        / "Функция"         - локальные
//   "Параметр"         / "ПараметрЗнач"    - параметры (по ссылке / по значению)
//   "ЭкспортПроцедура" / "ЭкспортФункция"  - экспортные
//   "ВнешняяПроцедура" / "ВнешняяФункция"  - глобального контекста
//
// Типы переменных (строковые константы):
//   "НеявнаяМодульная" / "НеявнаяЛокальная" / "Внешняя" / "ЯвнаяМодульная" / "Временная"
// Типы ошибок: 0 - критическая (блокирует выполнение), 1 - предупреждение

#Область ПрограммныйИнтерфейс

// Выполняет полный цикл компиляции исходного кода BSL.
// Двухпроходная схема: сначала строит AST, затем обходит дерево для генерации байт-кода.
//
// Параметры:
//  ИсходныйКод - Строка - исходный код BSL для компиляции
//  АдресТаблицПерехода - Строка, Структура - адрес во временном хранилище или структура таблиц перехода парсера
//  РежимВыполнить - Булево - Истина если компиляция в режиме оператора "Выполнить"
//  ВнешниеПеременные - Структура, Неопределено - внешние переменные ВМ
//  ПредварительныеЛексемыJSON - Строка - JSON-массив предварительных лексем от lezer (пропуск ДКА-лексера)
//
// Возвращаемое значение:
//  Структура - результат: Узел, МассивЛексем, Ошибки, ВыполнениеВозможно (Булево)
Функция ВыполнитьКомпиляцию(ИсходныйКод, АдресТаблицПерехода, РежимВыполнить = Ложь, ВнешниеПеременные = Неопределено, ПредварительныеЛексемыJSON = "") Экспорт
	Перем Стек;
	
	// === Проход 1: Построение AST (делегируется фасаду) ===
	РезультатПарсинга = конс_АСТ_ПостроительКлиентСервер.Разобрать(ИсходныйКод, АдресТаблицПерехода, РежимВыполнить, ПредварительныеЛексемыJSON);
	
	// === Проход 2: Обход AST и генерация байт-кода ===
	МассивОшибок = РезультатПарсинга.Ошибки;
	Результат = Новый Структура();
	ДанныеСемантики = СформироватьСтруктуруДанныхСемантики();
	ДанныеСемантики.Код = ИсходныйКод;
	ДанныеСемантики.РежимВыполнить = РежимВыполнить;
	ИнициализироватьПеременные(ДанныеСемантики, ВнешниеПеременные);
	ДобавитьКомандуВМ("", 0, ДанныеСемантики, Новый Структура("Атрибуты", Новый Структура("КоличествоОпераций", 0)));
	
	Если РезультатПарсинга.Свойство("Узел") И РезультатПарсинга.Узел <> Неопределено Тогда
		// Обход дерева post-order: дочерние узлы обрабатываются раньше родительских
		ОбойтиДеревоАСТ(РезультатПарсинга.Узел, ДанныеСемантики, МассивОшибок, Результат);
	КонецЕсли;
	
	Результат.Вставить("Узел", ?(РезультатПарсинга.Свойство("Узел"), РезультатПарсинга.Узел, Неопределено));
	Результат.Вставить("МассивЛексем", РезультатПарсинга.МассивЛексем);
	Результат.Вставить("ВыполнениеВозможно", ОпределитьВозможностьВыполнения(МассивОшибок));
	Результат.Вставить("Ошибки", МассивОшибок);
	Возврат Результат;
КонецФункции

// Создаёт начальную структуру данных семантического анализа (контекст компиляции).
// Содержит таблицу команд ВМ, константы, переменные, подпрограммы, метки и счётчики.
//
// Возвращаемое значение:
//  Структура - контекст семантического анализа
Функция СформироватьСтруктуруДанныхСемантики() Экспорт
	СтруктураДанных = Новый Структура;
	СтруктураДанных.Вставить("КомандыВМ", Новый Массив);
	СтруктураДанных.Вставить("ДанныеКомандВМ", Новый Соответствие);
	СтруктураДанных.Вставить("Константы", Новый Соответствие);
	СтруктураДанных.Вставить("АдресаМеток", Новый Соответствие);
	СтруктураДанных.Вставить("Метки", Новый Соответствие);
	СтруктураДанных.Вставить("Переменные", Новый Соответствие);
	СтруктураДанных.Вставить("Подпрограммы", Новый Соответствие);
	СтруктураДанных.Вставить("ЧтениеПодпрограммы", Ложь);
	СтруктураДанных.Вставить("ЧтениеЗаголовкаПодпрограммы", Ложь);
	СтруктураДанных.Вставить("РежимВыполнить", Ложь);
	СтруктураДанных.Вставить("КлючТекущейПодпрограммы", Неопределено);
	СтруктураДанных.Вставить("ИменаВстроенныхФункций", ПолучитьИменаВстроенныхФункций());
	СтруктураДанных.Вставить("СчетчикБлоков", 0);
	СтруктураДанных.Вставить("СчетчикПопыток", 0);
	СтруктураДанных.Вставить("СчетчикЦиклов", 0);
	СтруктураДанных.Вставить("Код", "");
	СтруктураДанных.Вставить("Вызовы", Новый Массив);
	СтруктураДанных.Вставить("МетодыГлобальногоКонтекста", ПолучитьМетодыГлобальногоКонтекста());
	СтруктураДанных.Вставить("СтрокаПервойПодпрограммы", 0);
	Возврат СтруктураДанных;
КонецФункции

// Добавляет команду в массив команд виртуальной машины.
// Поддерживает вставку по позиции с автоматическим пересчётом адресов.
//
// Параметры:
//  ОпКод - Строка - код операции ВМ (LDVAR, JMP, CALLLOC и т.д.)
//  Аргумент - Число - аргумент команды
//  ДанныеВМ - Структура - контекст компиляции (семантические данные)
//  УзелСемантики - Структура - текущий узел AST (для подсчёта операций)
//  ПозицияВставки - УникальныйИдентификатор, Число, Неопределено - позиция вставки
//  ИдентификаторАрг - УникальныйИдентификатор, Неопределено - связанная команда
//  Сдвиг - Число - смещение для аргумента
//  ИдентификаторКоманды - УникальныйИдентификатор, Неопределено - явный идентификатор
//
// Возвращаемое значение:
//  УникальныйИдентификатор - идентификатор добавленной команды
Функция ДобавитьКомандуВМ(ОпКод, Аргумент, ДанныеВМ, УзелСемантики, Знач ПозицияВставки = Неопределено, ИдентификаторАрг = Неопределено, Сдвиг = 0, ИдентификаторКоманды = Неопределено) Экспорт
	КомандыВМ = ДанныеВМ.КомандыВМ;
	ДанныеКомандВМ = ДанныеВМ.ДанныеКомандВМ;
	ИдентификаторКоманды = ?(ИдентификаторКоманды = Неопределено, Новый УникальныйИдентификатор, ИдентификаторКоманды);
	Если ПозицияВставки = Неопределено Тогда
		КомандыВМ.Добавить(ИдентификаторКоманды);
		АдресКоманды = КомандыВМ.Количество() - 1;
	ИначеЕсли ТипЗнч(ПозицияВставки) = Тип("УникальныйИдентификатор") Тогда
		ПозицияВставки = ДанныеКомандВМ[ПозицияВставки].Адрес;
		АдресКоманды = ПозицияВставки + 1;
		КомандыВМ.Вставить(АдресКоманды, ИдентификаторКоманды);
		ПозицияВставки = АдресКоманды + 1;
		Пока ПозицияВставки < КомандыВМ.Количество() Цикл
			ТекущаяКомандаВМ = ДанныеКомандВМ[КомандыВМ[ПозицияВставки]];
			ТекущаяКомандаВМ.Адрес = ТекущаяКомандаВМ.Адрес + 1;
			ПозицияВставки = ПозицияВставки + 1;
		КонецЦикла;
	Иначе
		КомандыВМ.Вставить(ПозицияВставки, ИдентификаторКоманды);
		АдресКоманды = ПозицияВставки;
		ПозицияВставки = ПозицияВставки + 1;
		Пока ПозицияВставки < КомандыВМ.Количество() Цикл
			ТекущаяКомандаВМ = ДанныеКомандВМ[КомандыВМ[ПозицияВставки]];
			ТекущаяКомандаВМ.Адрес = ТекущаяКомандаВМ.Адрес + 1;
			ПозицияВставки = ПозицияВставки + 1;
		КонецЦикла;
	КонецЕсли;
	НоваяКоманда = Новый Структура("ОпКод,Аргумент,Идентификатор,ИдентификаторАргумента,Сдвиг,Адрес");
	Если ТипЗнч(ИдентификаторАрг) = Тип("УникальныйИдентификатор") Тогда
		НоваяКоманда.ИдентификаторАргумента = ИдентификаторАрг;
	КонецЕсли;
	НоваяКоманда.ОпКод = ОпКод;
	НоваяКоманда.Аргумент = Аргумент;
	НоваяКоманда.Идентификатор = ИдентификаторКоманды;
	НоваяКоманда.Сдвиг = Сдвиг;
	НоваяКоманда.Адрес = АдресКоманды;
	ДанныеКомандВМ.Вставить(ИдентификаторКоманды, НоваяКоманда);
	Атрибуты = УзелСемантики.Атрибуты;
	Атрибуты.КоличествоОпераций = Атрибуты.КоличествоОпераций + 1;
	Возврат ИдентификаторКоманды;
КонецФункции

// Возвращает адрес константы в таблице констант ВМ, создавая запись при необходимости.
//
// Параметры:
//  ЗначениеКонстанты - Произвольный - значение константы для поиска или добавления
//  ДанныеКомпиляции - Структура - данные компиляции, содержащие таблицу констант
//
// Возвращаемое значение:
//  Число - адрес (индекс) константы в таблице констант ВМ
Функция ПолучитьАдресКонстантыВМ(ЗначениеКонстанты, ДанныеКомпиляции) Экспорт
	Если ДанныеКомпиляции.Константы[ЗначениеКонстанты] = Неопределено Тогда
		ДанныеКомпиляции.Константы.Вставить(ЗначениеКонстанты, ДанныеКомпиляции.Константы.Количество());
	КонецЕсли;
	Возврат ДанныеКомпиляции.Константы[ЗначениеКонстанты];
КонецФункции

// Возвращает описание подпрограммы по имени, создавая запись при необходимости.
// Флаги: "Процедура"/"Функция", "ЭкспортПроцедура"/"ЭкспортФункция", "ВнешняяПроцедура"/"ВнешняяФункция"
//
// Параметры:
//  ИмяПодпрограммы - Строка - имя подпрограммы для поиска или создания
//  ДанныеПодпрограмм - Структура - данные, содержащие соответствие подпрограмм
//  ФлагПодпрограммы - Число, Строка, Неопределено - флаг типа подпрограммы
//  ЧислоАргументов - Число, Неопределено - количество формальных параметров
//
// Возвращаемое значение:
//  Структура - описание подпрограммы с полями Имя, Переменные, ЗначенияПоУмолчанию, Флаг, ЧислоАргументов, ТочкаВхода, Адрес
Функция ПолучитьПодпрограммуВМ(ИмяПодпрограммы, ДанныеПодпрограмм, ФлагПодпрограммы = Неопределено, ЧислоАргументов = Неопределено) Экспорт
	ОписаниеПодпрограммы = ДанныеПодпрограмм.Подпрограммы[ВРег(ИмяПодпрограммы)];
	Если ОписаниеПодпрограммы = Неопределено Тогда
		ОписаниеПодпрограммы = Новый Структура("Имя,Переменные,ЗначенияПоУмолчанию,Флаг,ЧислоАргументов,ТочкаВхода,Адрес", ИмяПодпрограммы, Новый Соответствие, Новый Массив, ФлагПодпрограммы, ЧислоАргументов, Неопределено, ДанныеПодпрограмм.Подпрограммы.Количество());
		ДанныеПодпрограмм.Подпрограммы.Вставить(ВРег(ОписаниеПодпрограммы.Имя), ОписаниеПодпрограммы);
	Иначе
		Если ФлагПодпрограммы <> Неопределено И (ОписаниеПодпрограммы.Флаг = Неопределено ИЛИ ОписаниеПодпрограммы.Флаг = "ВнешняяФункция" ИЛИ ОписаниеПодпрограммы.Флаг = "ВнешняяПроцедура") Тогда
			ОписаниеПодпрограммы.Флаг = ФлагПодпрограммы;
			ОписаниеПодпрограммы.ЧислоАргументов = ЧислоАргументов;
		КонецЕсли;
	КонецЕсли;
	Возврат ОписаниеПодпрограммы;
КонецФункции

// Определяет опкод загрузки и адрес переменной в контексте ВМ.
// Ищет сначала в локальных переменных подпрограммы, затем в модульных.
// Типы переменных: 0 - неявная модульная, 1 - неявная локальная, 2 - явная/внешняя
//
// Параметры:
//  ИмяПеременной - Строка - имя искомой переменной
//  КонтекстПеременных - Структура - контекст семантического анализа с переменными и подпрограммами
//  ФлагЭкспорта - Массив - массив ошибок/предупреждений для накопления
//  НомерСтроки - Число - номер строки в исходном коде
//  ТолькоЧтение - Булево - признак использования переменной только для чтения
//
// Возвращаемое значение:
//  Структура - данные переменной с полями ОпКод (Строка) и Адрес (Число)
Функция ПолучитьДанныеПеременнойВМ(ИмяПеременной, КонтекстПеременных, ФлагЭкспорта, НомерСтроки, ТолькоЧтение = Ложь) Экспорт
	РезультатПеременной = Новый Структура("ОпКод,Адрес");
	Если КонтекстПеременных.Свойство("ПеременнаяОжидающаяПрисваивания")
		И КонтекстПеременных.ПеременнаяОжидающаяПрисваивания = ВРег(ИмяПеременной) Тогда
		ФлагЭкспорта.Добавить(Новый Структура("Тип,Название,Строка", 0,
			НСтр("ru='Переменная не определена ';en='Variable is not defined '", ТекущийЯзыкСистемы())
			+ ИмяПеременной,
			НомерСтроки));
	КонецЕсли;
	ОпКодЗагрузки = "ПЕРЕМ";
	СписокПеременных = КонтекстПеременных.Переменные;
	Если КонтекстПеременных.ЧтениеПодпрограммы Тогда
		ПеременныеПодпрограммы = КонтекстПеременных.Подпрограммы[КонтекстПеременных.КлючТекущейПодпрограммы].Переменные;
		Если ПеременныеПодпрограммы[ВРег(ИмяПеременной)] <> Неопределено Тогда
			ОпКодЗагрузки = "ЛОК";
			СписокПеременных = ПеременныеПодпрограммы;
		КонецЕсли;
	КонецЕсли;
	ОписаниеПеременной = СписокПеременных[ВРег(ИмяПеременной)];
	Если ОписаниеПеременной = Неопределено Тогда
		ТипПеременной = ОпределитьТипНовойПеременной(КонтекстПеременных, ТолькоЧтение);
		Если ТипПеременной = "НеявнаяЛокальная" Тогда
			СписокПеременных = КонтекстПеременных.Подпрограммы[КонтекстПеременных.КлючТекущейПодпрограммы].Переменные;
			ОпКодЗагрузки = "ЛОК";
		КонецЕсли;
		ТипПеременной = УточнитьТипПеременной(ТипПеременной, ИмяПеременной, ФлагЭкспорта, НомерСтроки);
		Если ТипПеременной = "Внешняя" Тогда
			СписокПеременных = КонтекстПеременных.Переменные;
			ОпКодЗагрузки = "ПЕРЕМ";
		КонецЕсли;
		АдресНовойПеременной = СписокПеременных.Количество();
		СписокПеременных.Вставить(ВРег(ИмяПеременной), Новый Структура("Адрес,Флаг,Имя", АдресНовойПеременной, ТипПеременной, ИмяПеременной));
		ОписаниеПеременной = СписокПеременных[ВРег(ИмяПеременной)];
	КонецЕсли;
	РезультатПеременной.ОпКод = ОпКодЗагрузки;
	РезультатПеременной.Адрес = ОписаниеПеременной.Адрес;
	Возврат РезультатПеременной;
КонецФункции

// Возвращает идентификатор последней добавленной команды ВМ.
//
// Параметры:
//  ДанныеСемантики - Структура - данные семантического анализа с массивом команд ВМ
//
// Возвращаемое значение:
//  Произвольный, Неопределено - идентификатор последней команды или Неопределено, если команд нет
Функция ПолучитьИдентификаторПоследнейКоманды(ДанныеСемантики) Экспорт
	КомандыВМ = ДанныеСемантики.КомандыВМ;
	КоличествоКоманд = КомандыВМ.Количество();
	Если КоличествоКоманд > 0 Тогда
		Возврат КомандыВМ[КоличествоКоманд - 1];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Возвращает идентификатор команды с заданным смещением относительно указанной.
//
// Параметры:
//  ДанныеСемантики - Структура - данные семантического анализа
//  ИдентификаторКоманды - Произвольный - идентификатор базовой команды
//  Сдвиг - Число - смещение относительно базовой команды
//
// Возвращаемое значение:
//  Произвольный - идентификатор команды по вычисленному адресу
Функция ПолучитьИдентификаторКомандыОтносительноТекущего(ДанныеСемантики, ИдентификаторКоманды, Сдвиг) Экспорт
	Возврат ДанныеСемантики.КомандыВМ[ДанныеСемантики.ДанныеКомандВМ[ИдентификаторКоманды].Адрес + Сдвиг];
КонецФункции

// Возвращает данные команды ВМ по её идентификатору.
//
// Параметры:
//  ДанныеСемантики - Структура - данные семантического анализа
//  ИдентификаторКоманды - Произвольный - идентификатор команды ВМ
//
// Возвращаемое значение:
//  Структура, Неопределено - данные команды ВМ или Неопределено, если не найдена
Функция ПолучитьКомандуПоИдентификатору(ДанныеСемантики, ИдентификаторКоманды) Экспорт
	ДанныеКоманды = ДанныеСемантики.ДанныеКомандВМ[ИдентификаторКоманды];
	Если ДанныеКоманды <> Неопределено Тогда
		Возврат ДанныеКоманды;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Суммирует количество операций ВМ всех дочерних нетерминалов узла AST.
//
// Параметры:
//  Узел - Структура - узел AST-дерева, содержащий СоставУзла и Атрибуты.КоличествоОпераций
Процедура РассчитатьКоличествоОперацийУзла(Узел) Экспорт
	АтрибутыУзла = Узел.Атрибуты;
	Для Каждого ЭлементСостава Из Узел.СоставУзла Цикл
		Если ЭлементСостава.Свойство("Нетерминал") Тогда
			АтрибутыУзла.КоличествоОпераций = АтрибутыУзла.КоличествоОпераций + ЭлементСостава.Атрибуты.КоличествоОпераций;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Рекурсивно обходит AST-дерево в порядке post-order (дочерние узлы раньше родительских)
// и выполняет семантические действия (кодогенерацию) для каждого нетерминала.
//
// Порядок обхода идентичен порядку вызова семантических действий
// при bottom-up парсинге (shift-reduce), что обеспечивает корректность кодогенерации.
//
// Параметры:
//  Узел - Структура - узел AST с полями Нетерминал, СоставУзла, Атрибуты
//  ДанныеСемантики - Структура - контекст семантического анализа
//  Ошибки - Массив - накопитель ошибок
//  ДанныеКомпиляции - Структура, Неопределено - дополнительные данные компиляции
Процедура ОбойтиДеревоАСТ(Узел, ДанныеСемантики, Ошибки, ДанныеКомпиляции = Неопределено) Экспорт
	// Сначала обрабатываем дочерние нетерминалы (post-order)
	Для Каждого ЭлементСостава Из Узел.СоставУзла Цикл
		Если ЭлементСостава.Свойство("Нетерминал") Тогда
			ОбойтиДеревоАСТ(ЭлементСостава, ДанныеСемантики, Ошибки);
		КонецЕсли;
	КонецЦикла;
	// Затем выполняем семантическое действие для текущего узла
	ОбработатьСемантикуУзла(Узел, ДанныеСемантики, Ошибки, ДанныеКомпиляции);
КонецПроцедуры

// Обрабатывает семантику одного узла AST: рассчитывает операции и диспатчеризует
// семантическое действие по имени нетерминала.
//
// Параметры:
//  Узел - Структура - узел AST с полем Нетерминал
//  ДанныеСемантики - Структура - контекст семантического анализа
//  Ошибки - Массив - накопитель ошибок
//  ДанныеКомпиляции - Структура, Неопределено - дополнительные данные компиляции
Процедура ОбработатьСемантикуУзла(Узел, ДанныеСемантики, Ошибки, ДанныеКомпиляции = Неопределено) Экспорт
	РассчитатьКоличествоОперацийУзла(Узел);
	конс_КомпиляцияСемантикаКлиентСервер.ВыполнитьСемантическоеДействие(ДанныеСемантики, Узел, ДанныеКомпиляции, Ошибки);
КонецПроцедуры

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

#Область ИнициализацияИУтилиты

// Инициализирует переменные модуля из внешних параметров ВМ.
// Добавляет внешние переменные в контекст семантического анализа с типом "НеявнаяМодульная".
//
// Параметры:
//  ДанныеСемантикиИнициализации - Структура - контекст семантического анализа
//  ВнешниеПараметры - Структура, Неопределено - структура с полем Параметры (Массив имён переменных)
Процедура ИнициализироватьПеременные(ДанныеСемантикиИнициализации, ВнешниеПараметры)
	Если ВнешниеПараметры = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если НЕ ВнешниеПараметры.Свойство("Параметры") Тогда
		Возврат;
	КонецЕсли;
	АдресПараметра = 0;
	Для Каждого ИмяПараметра Из ВнешниеПараметры.Параметры Цикл
		ОписаниеПараметра = Новый Структура("Адрес,Имя,Флаг", АдресПараметра, ИмяПараметра, "НеявнаяМодульная");
		АдресПараметра = АдресПараметра + 1;
		ДанныеСемантикиИнициализации.Переменные.Вставить(ВРег(ИмяПараметра), ОписаниеПараметра);
	КонецЦикла;
КонецПроцедуры

// Определяет возможность выполнения скомпилированного кода по наличию критических ошибок.
//
// Параметры:
//  МассивОшибок - Массив - массив структур ошибок с полем Тип (0 - критическая, 1 - предупреждение)
//
// Возвращаемое значение:
//  Булево - Истина, если критических ошибок нет и код можно выполнить
Функция ОпределитьВозможностьВыполнения(МассивОшибок)
	Для Каждого ЭлементОшибки Из МассивОшибок Цикл
		Если ЭлементОшибки.Тип = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Определяет тип неявной переменной по контексту компиляции.
//
// Параметры:
//  КонтекстПеременных - Структура - контекст семантического анализа
//  ТолькоЧтение - Булево - переменная используется только для чтения
//
// Возвращаемое значение:
//  Строка - "НеявнаяЛокальная", "НеявнаяМодульная" или "Внешняя"
Функция ОпределитьТипНовойПеременной(КонтекстПеременных, ТолькоЧтение)
	Если КонтекстПеременных.ЧтениеПодпрограммы И ТолькоЧтение Тогда
		Возврат "НеявнаяЛокальная"; // 1 - неявная локальная
	ИначеЕсли НЕ КонтекстПеременных.ЧтениеПодпрограммы И ТолькоЧтение Тогда
		Возврат "НеявнаяМодульная"; // 0 - неявная модульная
	Иначе
		Возврат "Внешняя"; // 2 - явная/внешняя (по умолчанию)
	КонецЕсли;
КонецФункции

// Уточняет тип переменной: проверяет наличие во внешнем контексте.
// Если неявная переменная оказывается внешней - меняет тип на "Внешняя".
// Если тип "Внешняя", но во внешнем контексте не найдена - добавляет предупреждение.
//
// Параметры:
//  ТипПеременной - Строка - предварительно определённый тип
//  ИмяПеременной - Строка - имя переменной
//  СписокОшибок - Массив - массив ошибок/предупреждений
//  НомерСтроки - Число - номер строки в исходном коде
//
// Возвращаемое значение:
//  Строка - уточнённый тип переменной
Функция УточнитьТипПеременной(ТипПеременной, ИмяПеременной, СписокОшибок, НомерСтроки)
	Если ТипПеременной = "НеявнаяМодульная" ИЛИ ТипПеременной = "НеявнаяЛокальная" Тогда
		Если ЭтоВнешняяПеременная(ИмяПеременной) Тогда
			Возврат "Внешняя";
		КонецЕсли;
	ИначеЕсли ТипПеременной = "Внешняя" И НЕ ЭтоВнешняяПеременная(ИмяПеременной) Тогда
		ТекстОшибки = НСтр("ru = 'Переменная не определена ('; en = 'Variable is not defined ('", ТекущийЯзыкСистемы()) + ИмяПеременной + ")";
		СписокОшибок.Добавить(Новый Структура("Тип,Название,Строка", 1, ТекстОшибки, НомерСтроки));
	Иначе
		// Тип переменной не изменяется
	КонецЕсли;
	Возврат ТипПеременной;
КонецФункции

// Определяет тип подстроки в многострочном литерале:
// 0 - начало строки (начинается с кавычки, заканчивается закрытой кавычкой)
// 1 - конец строки (не начинается с кавычки, заканчивается открытой кавычкой)
// 2 - середина строки (не начинается с кавычки, не заканчивается открытой кавычкой)
// 3 - полная строка (начинается с кавычки, заканчивается открытой кавычкой)
//
// Параметры:
//  ТекстПодстроки - Строка - текст подстроки для анализа
//
// Возвращаемое значение:
//  Число - тип подстроки (0, 1, 2 или 3)
Функция ОпределитьТипПодстроки(ТекстПодстроки) Экспорт
	Если СтрНачинаетсяС(ТекстПодстроки, """") Тогда
		Если СтрокаЗаканчиваетсяОткрытойКавычкой(ТекстПодстроки) Тогда
			Возврат 3;
		Иначе
			Возврат 0;
		КонецЕсли;
	Иначе
		Если СтрокаЗаканчиваетсяОткрытойКавычкой(ТекстПодстроки) Тогда
			Возврат 1;
		Иначе
			Возврат 2;
		КонецЕсли;
	КонецЕсли;
КонецФункции
// Проверяет, заканчивается ли строка нечётным количеством кавычек (т.е. открытой кавычкой).
//
// Параметры:
//  СтроковоеЗначение - Строка - проверяемая строка
//
// Возвращаемое значение:
//  Булево - Истина, если строка заканчивается открытой (нечётной) кавычкой
Функция СтрокаЗаканчиваетсяОткрытойКавычкой(СтроковоеЗначение)
	ДлинаСтроки = СтрДлина(СтроковоеЗначение);
	Если ДлинаСтроки = 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	НечетноеКоличествоКавычек = Ложь;
	Пока ДлинаСтроки > 1 Цикл
		ТекСимвол = Сред(СтроковоеЗначение, ДлинаСтроки, 1);
		Если ТекСимвол = """" Тогда
			НечетноеКоличествоКавычек = НЕ НечетноеКоличествоКавычек;
		Иначе
			Прервать;
		КонецЕсли;
		ДлинаСтроки = ДлинаСтроки - 1;
	КонецЦикла;
	Возврат НечетноеКоличествоКавычек;
КонецФункции
// Проверяет, существует ли переменная во внешнем контексте виртуальной машины.
//
// Параметры:
//  ИмяПеременной - Строка - имя проверяемой переменной
//
// Возвращаемое значение:
//  Булево - Истина, если переменная существует во внешнем контексте ВМ
Функция ЭтоВнешняяПеременная(ИмяПеременной) Экспорт
	Попытка
		конс_ВМ_КлиентСервер.ПолучитьЗначениеВнешнейПеременной(ИмяПеременной);
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
КонецФункции

// Определяет флаг внешней подпрограммы (функция или процедура) по флагу глобального метода.
//
// Параметры:
//  ФлагГлобальногоМетода - Строка, Неопределено - флаг из МетодыГлобальногоКонтекста ("ВнешняяФункция" или "ВнешняяПроцедура")
//  ФлагПоУмолчанию - Строка - флаг при отсутствии в глобальном контексте
//  ФлагПроцедуры - Строка - флаг процедуры ("ВнешняяПроцедура")
//
// Возвращаемое значение:
//  Строка - "ВнешняяФункция" или "ВнешняяПроцедура"
Функция ОпределитьФлагВнешнейПодпрограммы(ФлагГлобальногоМетода, ФлагПоУмолчанию, ФлагПроцедуры) Экспорт
	Если ФлагГлобальногоМетода = Неопределено Тогда
		Возврат ФлагПоУмолчанию;
	ИначеЕсли ФлагГлобальногоМетода = ФлагПроцедуры Тогда
		Возврат "ВнешняяПроцедура";
	Иначе
		Возврат "ВнешняяФункция";
	КонецЕсли;
КонецФункции

// Определяет идентификатор команды перед выходом из тела цикла.
// Используется в _ЦиклДляКаждого и _ЦиклДля для устранения вложенных тернарных операторов.
//
// Параметры:
//  ЕстьТелоЦикла - Булево - есть ли тело цикла
//  ИдентификаторВыражения - УникальныйИдентификатор - идентификатор последней команды выражения
//  ИдентификаторТела - УникальныйИдентификатор, Неопределено - идентификатор последней команды тела
//  ИдентификаторАльтернативы - УникальныйИдентификатор - альтернативный идентификатор (строка/переход)
//
// Возвращаемое значение:
//  УникальныйИдентификатор - идентификатор команды до выхода
Функция ОпределитьИдентификаторКомандыДоВыхода(ЕстьТелоЦикла, ИдентификаторВыражения, ИдентификаторТела, ИдентификаторАльтернативы) Экспорт
	Если НЕ ЕстьТелоЦикла Тогда
		Возврат ИдентификаторАльтернативы;
	ИначеЕсли ИдентификаторВыражения = ИдентификаторТела Тогда
		Возврат ИдентификаторАльтернативы;
	Иначе
		Возврат ИдентификаторТела;
	КонецЕсли;
КонецФункции

#КонецОбласти // ИнициализацияИУтилиты

#Область ТаблицыВстроенныхФункций

// Формирует соответствие встроенных функций ВМ для компиляции.
// Ключ - имя функции в верхнем регистре, значение - соответствие количества параметров → опкод.
// Поддерживает полиморфные функции с несколькими вариантами по количеству аргументов.
//
// Возвращаемое значение:
//  Соответствие - имена встроенных функций → соответствие (КоличествоПараметров → ОпКод)
Функция ПолучитьИменаВстроенныхФункций()
	СоответствиеФункций = Новый Соответствие;
	ВстроенныеФункции = конс_ВМ_КлиентСервер.СформироватьСоответствиеВстроенныхФункций();
	Для Каждого ЭлементФункции Из ВстроенныеФункции Цикл
		Если ТипЗнч(ЭлементФункции.Значение) = Тип("Структура") Тогда
			СоответствиеФункций.Вставить(ЭлементФункции.Ключ, Новый Соответствие);
			СоответствиеФункций[ЭлементФункции.Ключ].Вставить(ЭлементФункции.Значение.КоличествоПараметров, ЭлементФункции.Ключ);
			СоответствиеФункций.Вставить(ВРег(ЭлементФункции.Значение.Имя), Новый Соответствие);
			СоответствиеФункций[ВРег(ЭлементФункции.Значение.Имя)].Вставить(ЭлементФункции.Значение.КоличествоПараметров, ЭлементФункции.Ключ);
		Иначе
			Для Каждого ВариантФункции Из ЭлементФункции.Значение Цикл
				Если СоответствиеФункций[ЭлементФункции.Ключ] = Неопределено Тогда
					СоответствиеФункций.Вставить(ЭлементФункции.Ключ, Новый Соответствие);
					СоответствиеФункций.Вставить(ВРег(ВариантФункции.Имя), Новый Соответствие);
				КонецЕсли;
				СоответствиеФункций[ЭлементФункции.Ключ].Вставить(ВариантФункции.КоличествоПараметров, ЭлементФункции.Ключ + "_" + ВариантФункции.Суффикс);
				СоответствиеФункций[ВРег(ВариантФункции.Имя)].Вставить(ВариантФункции.КоличествоПараметров, ЭлементФункции.Ключ + "_" + ВариантФункции.Суффикс);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	Возврат СоответствиеФункций;
КонецФункции

#КонецОбласти // ТаблицыВстроенныхФункций

#Область ОбработкаОшибок

// Добавляет ошибку компиляции с указанием позиции в исходном коде.
// Извлекает код программы из данных семантики и делегирует в ДобавитьОшибкуПарсера.
//
// Параметры:
//  Ошибки - Массив - накопитель ошибок (структуры с полями Тип, Название, Строка)
//  ТекстОшибки - Строка - текст сообщения об ошибке
//  ДанныеСемантики - Структура - контекст семантического анализа с полем Код
//  ЛексемаОшибки - Структура - лексема с полями НомерСтроки, Позиция, Значение
Процедура ДобавитьОшибкуКомпиляции(Ошибки, ТекстОшибки, ДанныеСемантики, ЛексемаОшибки) Экспорт
	ДобавитьОшибкуПарсера(Ошибки, ТекстОшибки, ДанныеСемантики.Код, ЛексемаОшибки);
КонецПроцедуры

// Добавляет ошибку парсера/компиляции в накопитель ошибок.
// Формирует сообщение с маркером позиции <<?>> в строке исходного кода.
//
// Параметры:
//  Ошибки - Массив - накопитель ошибок (структуры с полями Тип, Название, Строка)
//  ТекстОшибки - Строка - текст сообщения об ошибке
//  КодПрограммы - Строка - полный исходный код программы
//  ЛексемаПозиции - Структура - лексема с полями НомерСтроки, Позиция, Значение
Процедура ДобавитьОшибкуПарсера(Ошибки, ТекстОшибки, КодПрограммы, ЛексемаПозиции)
	СтрокаКода = СтрПолучитьСтроку(КодПрограммы, ЛексемаПозиции.НомерСтроки);
	КонецЛексемы = ЛексемаПозиции.Позиция + СтрДлина(ЛексемаПозиции.Значение);
	СтрокаСМаркером = Сред(СтрокаКода, 1, КонецЛексемы - 1) + "<<?>>" + Сред(СтрокаКода, КонецЛексемы);
	ПолноеСообщениеОшибки = ТекстОшибки + " (" + ЛексемаПозиции.НомерСтроки + ", " + КонецЛексемы + "): " + СтрокаСМаркером;
	Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 0, ПолноеСообщениеОшибки, ЛексемаПозиции.НомерСтроки));
КонецПроцедуры

#КонецОбласти // ОбработкаОшибок

#Область СправочникМетодовГлобальногоКонтекста

// Загружает словарь методов глобального контекста из JSON-макета.
// Каждая запись: "ИМЯ_МЕТОДА" → "ВнешняяФункция" или "ВнешняяПроцедура".
//
// Возвращаемое значение:
//  Соответствие - имена методов в верхнем регистре → строковые флаги
Функция ПолучитьМетодыГлобальногоКонтекста()
	ТекстJSON = ПолучитьОбщийМакет("конс_МетодыГлобальногоКонтекста").ПолучитьТекст();
	Возврат ЗагрузитьСоответствиеИзJSON(ТекстJSON);
КонецФункции

// Десериализует JSON-строку в Соответствие.
//
// Параметры:
//  ТекстJSON - Строка - JSON-текст вида {"Ключ": Значение, ...}
//
// Возвращаемое значение:
//  Соответствие - десериализованные данные
Функция ЗагрузитьСоответствиеИзJSON(ТекстJSON)
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТекстJSON);
	Результат = ПрочитатьJSON(ЧтениеJSON, Истина);
	ЧтениеJSON.Закрыть();
	Возврат Результат;
КонецФункции

#КонецОбласти // СправочникМетодовГлобальногоКонтекста

#КонецОбласти // СлужебныеПроцедурыИФункции

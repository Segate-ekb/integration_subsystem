// Построитель AST встроенного языка BSL (1C:Enterprise)
//
// Модуль-фасад для построения чистого AST-дерева из исходного кода BSL.
// Объединяет лексический анализ, обработку директив препроцессора
// и синтаксический анализ в единый конвейер.
//
// AST строится без побочных эффектов (без генерации байт-кода),
// что позволяет использовать его независимо от компилятора:
//   - Инлайнер
//   - Анализ кода
//   - Форматирование
//   - Рефакторинг
//   - Кастомная кодогенерация
//
// Зависимости:
//   конс_АСТ_ЛексерКлиентСервер — лексический анализ (ДКА)
//   конс_АСТ_ПарсерКлиентСервер — синтаксический анализ (shift-reduce МПА)
//   конс_АСТ_ПрепроцессорКлиентСервер — обработка директив препроцессора
//
// Точка входа:
//   Разобрать(ИсходныйКод, АдресТаблицПерехода, РежимВыполнить) → Структура

#Область ПрограммныйИнтерфейс

// Выполняет полный цикл построения AST из исходного кода BSL.
// Включает лексический анализ, обработку препроцессора и синтаксический анализ.
// Не выполняет семантический анализ и кодогенерацию.
//
// Параметры:
//  ИсходныйКод - Строка - исходный код BSL для разбора
//  АдресТаблицПерехода - Строка, Структура - адрес во временном хранилище
//    или структура таблиц перехода (ДКА + МПА)
//  РежимВыполнить - Булево - Истина если разбор в режиме оператора "Выполнить"
//  ПредварительныеЛексемыJSON - Строка - JSON-массив предварительных лексем от lezer.
//    Если непустая строка — ДКА-лексер пропускается, лексемы берутся из массива.
//    Формат элемента: {"t":"имя_терминала","v":"значение","l":номер_строки,"p":позиция}
//
// Возвращаемое значение:
//  Структура:
//    * Узел - Структура, Неопределено - корневой узел AST (нетерминал "S")
//      Каждый узел AST содержит:
//        * Нетерминал - Строка - имя нетерминала грамматики
//        * СоставУзла - Массив - дочерние узлы (нетерминалы) и листья (терминалы)
//        * Атрибуты - Структура - атрибуты узла (КоличествоОпераций)
//        * НомерСтроки - Число - номер строки в исходном коде
//      Каждый лист (терминал) содержит:
//        * Терминал - Строка - имя терминала (лексемы)
//        * Значение - Строка - текстовое значение лексемы
//        * НомерСтроки - Число - номер строки
//        * Позиция - Число - позиция в строке
//    * МассивЛексем - Массив - все распознанные лексемы
//    * Ошибки - Массив - ошибки лексического/синтаксического анализа
Функция Разобрать(ИсходныйКод, АдресТаблицПерехода, РежимВыполнить = Ложь, ПредварительныеЛексемыJSON = "") Экспорт
	Если ТипЗнч(АдресТаблицПерехода) = Тип("Строка") Тогда
		ДанныеТаблицПерехода = ПолучитьИзВременногоХранилища(АдресТаблицПерехода);
	Иначе
		ДанныеТаблицПерехода = АдресТаблицПерехода;
	КонецЕсли;
	СтруктураМПА = ДанныеТаблицПерехода.СтруктураМПА;
	СоответствиеУдаляемых = ДанныеТаблицПерехода.СоответствиеУдаляемых;
	СоответствиеРедукций = ДанныеТаблицПерехода.СоответствиеРедукций;
	СоответствиеЛексемУсловия = ДанныеТаблицПерехода.СоответствиеЛексемУсловияПрепроцессора;
	СтекПарсера = Новый Массив;
	СтекДиректив = Новый Массив;
	МассивОшибок = Новый Массив;
	МассивЛексем = Новый Массив;
	ТекущееДействие = Неопределено;
	ИспользуемыеТерминалы = Новый Соответствие;
	ВключенКод = Истина;
	ЕстьКритическаяОшибка = Ложь;
	ПеременныеПрепроцессора = конс_АСТ_ПрепроцессорКлиентСервер.ПолучитьСтруктуруПеременныхПрепроцессора();
	
	// Определяем источник лексем: предварительные (от lezer) или ДКА-лексер
	ИспользоватьПредвЛексемы = Ложь;
	ПредвЛексемы = Неопределено;
	ИндексПредвЛексем = 0;
	
	Если ЗначениеЗаполнено(ПредварительныеЛексемыJSON) Тогда
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ПредварительныеЛексемыJSON);
			ПредвЛексемы = ПрочитатьJSON(ЧтениеJSON, Истина);
			ЧтениеJSON.Закрыть();
			ИспользоватьПредвЛексемы = (ПредвЛексемы <> Неопределено)
				И (ТипЗнч(ПредвЛексемы) = Тип("Массив"))
				И (ПредвЛексемы.Количество() > 0);
		Исключение
			ИспользоватьПредвЛексемы = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если ИспользоватьПредвЛексемы Тогда
		// Виртуальный контекст лексера — совместим по интерфейсу (ЛексерЗавершен)
		КонтекстЛексера = Новый Структура;
		КонтекстЛексера.Вставить("ЛексерЗавершен", Ложь);
	Иначе
		КонтекстЛексера = конс_АСТ_ЛексерКлиентСервер.СоздатьКонтекстЛексера(
			ИсходныйКод, ДанныеТаблицПерехода.СоответствиеДКА, ДанныеТаблицПерехода.СоответствиеЛексемПеревода);
	КонецЕсли;
	
	СтекПарсера.Вставить(0, "0");
	Пока НЕ КонтекстЛексера.ЛексерЗавершен Цикл
		
		// Получение следующей лексемы из выбранного источника
		Если ИспользоватьПредвЛексемы Тогда
			Если ИндексПредвЛексем >= ПредвЛексемы.Количество() Тогда
				Прервать;
			КонецЕсли;
			Эл = ПредвЛексемы[ИндексПредвЛексем];
			ТекущаяЛексема = Новый Структура("Имя,Значение,НомерСтроки,Позиция",
				Эл["t"], Эл["v"], Эл["l"], Эл["p"]);
			ИндексПредвЛексем = ИндексПредвЛексем + 1;
			Если ТекущаяЛексема.Имя = "Спец_КонецФайла" Тогда
				КонтекстЛексера.ЛексерЗавершен = Истина;
			КонецЕсли;
		Иначе
			ТекущаяЛексема = конс_АСТ_ЛексерКлиентСервер.ПолучитьСледующуюЛексему(КонтекстЛексера);
		КонецЕсли;
		
		МассивЛексем.Добавить(ТекущаяЛексема);
		Если СоответствиеУдаляемых[ТекущаяЛексема.Имя] <> Неопределено Тогда
			ИспользуемыеТерминалы.Вставить(ТекущаяЛексема.Имя, Истина);
			Продолжить;
		КонецЕсли;
		Если ТекущаяЛексема.Имя = "Спец_Препроцессор" Тогда
			конс_АСТ_ПрепроцессорКлиентСервер.ОбработатьДирективуПрепроцессора(ТекущаяЛексема, ВключенКод, СтекДиректив, ПеременныеПрепроцессора, МассивОшибок, ЕстьКритическаяОшибка, СоответствиеЛексемУсловия);
			Если ЕстьКритическаяОшибка Тогда
				Прервать;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		Если НЕ ВключенКод И ТекущаяЛексема.Имя <> "Спец_КонецФайла" Тогда
			Продолжить;
		КонецЕсли;
		ТекущееДействие = конс_АСТ_ПарсерКлиентСервер.ВыполнитьЦиклПарсера(ТекущаяЛексема, СтекПарсера, СтруктураМПА, СоответствиеРедукций);
		Если ТекущееДействие = Неопределено Тогда
			СформироватьСообщениеОбОшибке(МассивОшибок, МассивЛексем, СоответствиеУдаляемых, ИсходныйКод);
			КонтекстЛексера.ЛексерЗавершен = Истина;
		КонецЕсли;
	КонецЦикла;
	
	// Fallback: если предварительные лексемы вызвали ошибку парсера,
	// повторяем разбор штатным ДКА-лексером
	// Fallback: lezer-лексемы не подошли — молча откатываемся на штатный ДКА-лексер.
	Если ИспользоватьПредвЛексемы И МассивОшибок.Количество() > 0 Тогда
		Возврат Разобрать(ИсходныйКод, ДанныеТаблицПерехода, РежимВыполнить, "");
	КонецЕсли;
	
	Возврат конс_АСТ_ПарсерКлиентСервер.СобратьРезультатПарсинга(ТекущееДействие, СтекПарсера, МассивОшибок, МассивЛексем, ИспользуемыеТерминалы, РежимВыполнить, ЕстьКритическаяОшибка, СтекДиректив);
КонецФункции

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

// Формирует сообщение об ошибке парсинга (синтаксическая ошибка).
Процедура СформироватьСообщениеОбОшибке(МассивОшибокПарсера, МассивЛексемПарсера, СоответствиеУдаляемыхПарсера, КодМодуля)
	ИндексЛексемы = МассивЛексемПарсера.Количество() - 1;
	ЛексемаОшибки = МассивЛексемПарсера[ИндексЛексемы];
	Пока ИндексЛексемы > 0 Цикл
		ИндексЛексемы = ИндексЛексемы - 1;
		ЛексемаОшибки = МассивЛексемПарсера[ИндексЛексемы];
		Если СоответствиеУдаляемыхПарсера[ЛексемаОшибки.Имя] = Неопределено Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ДобавитьОшибкуПарсера(МассивОшибокПарсера, НСтр("ru = 'Синтаксическая ошибка'; en = 'Syntax error'", ТекущийЯзыкСистемы()), КодМодуля, ЛексемаОшибки)
КонецПроцедуры

// Формирует запись об ошибке парсера с маркером позиции в коде.
Процедура ДобавитьОшибкуПарсера(Ошибки, ТекстОшибки, КодПрограммы, ЛексемаПозиции)
	СтрокаКода = СтрПолучитьСтроку(КодПрограммы, ЛексемаПозиции.НомерСтроки);
	КонецЛексемы = ЛексемаПозиции.Позиция + СтрДлина(ЛексемаПозиции.Значение);
	СтрокаСМаркером = Сред(СтрокаКода, 1, КонецЛексемы - 1) + "<<?>>" + Сред(СтрокаКода, КонецЛексемы);
	ПолноеСообщениеОшибки = ТекстОшибки + " (" + ЛексемаПозиции.НомерСтроки + ", " + КонецЛексемы + "): " + СтрокаСМаркером;
	Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 0, ПолноеСообщениеОшибки, ЛексемаПозиции.НомерСтроки));
КонецПроцедуры

#КонецОбласти // СлужебныеПроцедурыИФункции

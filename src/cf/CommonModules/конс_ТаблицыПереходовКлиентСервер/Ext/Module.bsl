
#Область Программный_интерфейс

Функция ПолучитьДанныеТаблицПерехода() Экспорт

	ДанныеТаблицПерехода = Новый Структура;
	ДанныеТаблицПерехода.Вставить("СтруктураМПА",                           ПолучитьСоответствияПереходовПарсера());
	ДанныеТаблицПерехода.Вставить("СоответствиеДКА",                        ПолучитьСоответствиеПереходовЛексера());
	ДанныеТаблицПерехода.Вставить("СоответствиеЛексемПеревода",             ПолучитьСоответствиеЛексемПеревода());
	ДанныеТаблицПерехода.Вставить("СоответствиеУдаляемых",                  ПолучитьСоответствиеУдаляемыхЛексем());
	ДанныеТаблицПерехода.Вставить("СоответствиеРедукций",                   ПолучитьСоответствиеРедукций());
	ДанныеТаблицПерехода.Вставить("СоответствиеЛексемУсловияПрепроцессора", ПолучитьСоответствиеЛексемУсловияПрепроцессора());

	Возврат ДанныеТаблицПерехода;
	
КонецФункции

Функция ПолучитьСоответствиеПереходовЛексера() Экспорт
	
	// Загружаем JSON: {transitions: {группа: {symbols, moves}}, finalStates: {токен: [состояния]}}
	ДанныеJSON = ЗагрузитьДанныеИзШаблона("конс_ТаблицаПереходовЛексера");
	
	СоответствиеПереходов    = Новый Соответствие;
	СоответствиеСпецсимволов = ПолучитьСоответствиеСпецсимволов();
	СоответствиеБукв         = ПолучитьСоответствиеБукв();
	СоответствиеГрупп        = Новый Соответствие; // кеш разрешённых групп для дифференциальных ссылок
	
	// Обработка переходов: каждая группа содержит symbols (символы) и moves (переходы DFA)
	Для Каждого ЭлементГруппы Из ДанныеJSON.transitions Цикл
		ДанныеГруппы = ЭлементГруппы.Значение;
		
		// Разрешаем символы группы
		Если ТипЗнч(ДанныеГруппы.symbols) = Тип("Массив") Тогда
			ГруппаСимволов = ДанныеГруппы.symbols;
		Иначе
			// Дифференциальная группа: {base, exclude} или {base, include}
			ОписаниеСимволов = ДанныеГруппы.symbols;
			БазовыйМассив = СоответствиеГрупп[ОписаниеСимволов.base];
			Исключаемые = Неопределено;
			Включаемые  = Неопределено;
			Если ТипЗнч(ОписаниеСимволов) = Тип("Структура") Тогда
				ОписаниеСимволов.Свойство("exclude", Исключаемые);
				ОписаниеСимволов.Свойство("include", Включаемые);
			КонецЕсли;
			Если Исключаемые <> Неопределено Тогда
				СоответствиеИсключаемых = Новый Соответствие;
				Для Каждого Символ Из Исключаемые Цикл
					СоответствиеИсключаемых.Вставить(Символ, Истина);
				КонецЦикла;
				ГруппаСимволов = Новый Массив;
				Для Каждого Символ Из БазовыйМассив Цикл
					Если СоответствиеИсключаемых[Символ] = Неопределено Тогда
						ГруппаСимволов.Добавить(Символ);
					КонецЕсли;
				КонецЦикла;
			Иначе
				ГруппаСимволов = Новый Массив;
				Для Каждого Символ Из БазовыйМассив Цикл
					ГруппаСимволов.Добавить(Символ);
				КонецЦикла;
				Если Включаемые <> Неопределено Тогда
					Для Каждого Символ Из Включаемые Цикл
						ГруппаСимволов.Добавить(Символ);
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		СоответствиеГрупп.Вставить(ЭлементГруппы.Ключ, ГруппаСимволов);
		
		// Обработка переходов (moves) группы
		Для Каждого Переход Из ДанныеГруппы.moves Цикл
			Если ТипЗнч(Переход.from) = Тип("Массив") Тогда
				МассивИсходных = Переход.from;
			Иначе
				МассивИсходных = Новый Массив;
				МассивИсходных.Добавить(Переход.from);
			КонецЕсли;
			
			СледСостояние = Строка(Переход.to);
			
			Для Каждого ИсходноеСостояние Из МассивИсходных Цикл
				ТекСостояние = Строка(ИсходноеСостояние);
				
				Для Каждого Символ Из ГруппаСимволов Цикл
					ТекСимвол = ?(СоответствиеСпецсимволов[Символ] = Неопределено, Символ, СоответствиеСпецсимволов[Символ]);
					
					Если СоответствиеПереходов[ТекСимвол] = Неопределено Тогда
						СоответствиеПереходов.Вставить(ТекСимвол, Новый Соответствие);
					КонецЕсли;
					
					СоответствиеПереходов[ТекСимвол].Вставить(ТекСостояние, Новый Структура("СледСостояние,Вывод", СледСостояние, ""));
					
					Если СоответствиеБукв[ТекСимвол] <> Неопределено Тогда
						Если СоответствиеПереходов[НРег(ТекСимвол)] = Неопределено Тогда
							СоответствиеПереходов.Вставить(НРег(ТекСимвол), Новый Соответствие);
						КонецЕсли;
						
						СоответствиеПереходов[НРег(ТекСимвол)].Вставить(ТекСостояние, Новый Структура("СледСостояние,Вывод", СледСостояние, ""));
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	// Финальные состояния: finalStates = {имяТокена: [состояния], ...}
	СоответствиеПереходов.Вставить("&!", Новый Соответствие);
	Для Каждого ТокенИСостояния Из ДанныеJSON.finalStates Цикл
		ИмяЛексемы = ТокенИСостояния.Ключ;
		Для Каждого Состояние Из ТокенИСостояния.Значение Цикл
			СоответствиеПереходов["&!"].Вставить(Строка(Состояние), Новый Структура("СледСостояние,Вывод", "S", ИмяЛексемы));
		КонецЦикла;
	КонецЦикла;
	
	Возврат СоответствиеПереходов;
	
КонецФункции

Функция ПолучитьСоответствияПереходовПарсера() Экспорт
	
	СтруктураМПА             = Новый Структура;
	СоответствиеТерминалов   = Новый Соответствие;
	СоответствиеНетерминалов = Новый Соответствие;
	ДанныеФормирования       = ПолучитьДанныеФормированияТаблицыПереходовПарсера();
	
	Для Каждого стПереход Из ДанныеФормирования.МассивПереходов Цикл
		
		// Проверяем является ли символ ключом группы в соответствии
		ГруппаСимволов = ДанныеФормирования.СоответствиеГруппСимволов[стПереход.Символ];
		
		Если ГруппаСимволов <> Неопределено Тогда
			// Раскрываем группу символов
			Для Каждого Символ Из ГруппаСимволов Цикл
				ДобавитьЗначениеВСоответствиеПереходов(СоответствиеТерминалов, СоответствиеНетерминалов, стПереход, Символ);
			КонецЦикла;
		Иначе
			// Конкретный символ (строка-имя токена)
			ДобавитьЗначениеВСоответствиеПереходов(СоответствиеТерминалов, СоответствиеНетерминалов, стПереход);
		КонецЕсли;
			
	КонецЦикла;
	
	СтруктураМПА.Вставить("СоответствиеТерминалов",   СоответствиеТерминалов);
	СтруктураМПА.Вставить("СоответствиеНетерминалов", СоответствиеНетерминалов);
		
	Возврат СтруктураМПА;
	
КонецФункции

Функция ПолучитьСоответствиеЛексемПеревода() Экспорт
	
	СоответствиеЛексемПеревода = Новый Соответствие;
	
	СоответствиеЛексемПеревода.Вставить("Спец_ПереводСтроки", Истина);
	
	Возврат СоответствиеЛексемПеревода;
	
КонецФункции

Функция ПолучитьСоответствиеУдаляемыхЛексем() Экспорт
	
	СоответствиеУдаляемых = Новый Соответствие;
	
	СоответствиеУдаляемых.Вставить("Спец_Комментарий", Истина);   // Remark - комментарий
	СоответствиеУдаляемых.Вставить("Спец_ПереводСтроки", Истина);   // Line Feed
	СоответствиеУдаляемых.Вставить("Спец_Табуляция", Истина);  // Табуляция
	СоответствиеУдаляемых.Вставить("Спец_НПП", Истина);   // Non-breaking space
	СоответствиеУдаляемых.Вставить("Спец_Директива", Истина);   // Директива препроцессора
	СоответствиеУдаляемых.Вставить("Спец_ВозвратКаретки", Истина);   // Carriage Return
	СоответствиеУдаляемых.Вставить("Спец_Метка", Истина);   // Пробел (Blank)
	
	Возврат СоответствиеУдаляемых;
	
КонецФункции

Функция ПолучитьСоответствиеЛексемУсловияПрепроцессора() Экспорт

	СписокЛексем       = "Сервер,Server,НаСервере,AtServer,Клиент,Client,НаКлиенте,AtClient,ТонкийКлиент,ThinClient,МобильныйКлиент,MobileClient,ВебКлиент,WebClient,ВнешнееСоединение,ExternalConnection,ТолстыйКлиентУправляемоеПриложение,ThickClientManagedApplication,ТолстыйКлиентОбычноеПриложение,ThickClientOrdinaryApplication,МобильноеПриложениеКлиент,MobileAppClient,МобильноеПриложениеСервер,MobileAppServer,МобильныйАвтономныйСервер,MobileStandaloneServer,И,And,ИЛИ,Or,НЕ,Not,(,)";
	МассивЛексем       = СтрРазделить(СписокЛексем, ",", Ложь);
	СоответствиеЛексем = Новый Соответствие;
	
	Для Каждого Лексема Из МассивЛексем Цикл
		СоответствиеЛексем.Вставить(ВРег(Лексема), Истина);
	КонецЦикла;
	
	Возврат СоответствиеЛексем;
	
КонецФункции

Функция ПолучитьСоответствиеРедукций() Экспорт
	
	ГрамматикаПарсера = ПолучитьДанныеФормированияТаблицыРедукций();
	
	СоответствиеРедукций = Новый Соответствие;
	
	Для Каждого Стр Из ГрамматикаПарсера Цикл
		
		Альтернативы = ВыполнитьРазборСтроки(Стр.Выражение, "|");
		Для Каждого Альтернатива Из Альтернативы Цикл
			Ключ     = Стр.Идентификатор + " <= " + Альтернатива;
			Операнды = ВыполнитьРазборСтроки(Альтернатива, ",");

			Если Операнды[0] = """Emp""" Тогда
				Операнды.Удалить(0);
				Ключ = Стр.Идентификатор + " <= "
			КонецЕсли;
			СоответствиеРедукций.Вставить(Ключ, Новый Структура("Символы,Нетерминал", Операнды, Стр.Идентификатор));
		КонецЦикла;
	КонецЦикла;
	
	Возврат СоответствиеРедукций;
	
КонецФункции

#КонецОбласти

#Область Служебные_процедуры_и_функции

Функция ПолучитьСоответствиеБукв()

	СтрокаБуквы = "А,Б,В,Г,Д,Е,Ё,Ж,З,И,Й,К,Л,М,Н,О,П,Р,С,Т,У,Ф,Х,Ц,Ч,Ш,Щ,Ь,Ы,Ъ,Э,Ю,Я,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z";
	МассивБукв  = СтрРазделить(СтрокаБуквы, ",", Ложь);
	
	СоответствиеБукв = Новый Соответствие;
	
	Для Каждого Буква Из МассивБукв Цикл
		СоответствиеБукв.Вставить(Буква, Истина);
	КонецЦикла;
	
	Возврат СоответствиеБукв;
	
КонецФункции

Функция ПолучитьСоответствиеСпецсимволов()

	СоответствиеСпецсимволов = Новый Соответствие;
	
	СоответствиеСпецсимволов.Вставить("\N",  Символы.ПС);
	СоответствиеСпецсимволов.Вставить("\B",  Символы.НПП);
	СоответствиеСпецсимволов.Вставить("\C",  Символы.ВК);
	СоответствиеСпецсимволов.Вставить("\Q",  """");
	СоответствиеСпецсимволов.Вставить("\V",  "|");
	СоответствиеСпецсимволов.Вставить("\T",  Символы.Таб);
	СоответствиеСпецсимволов.Вставить("\Cm", ",");
	
	Возврат СоответствиеСпецсимволов;
	
КонецФункции

Функция ВыполнитьРазборСтроки(СтрокаРазбора, Разделитель)
	
	Сч              = 1;
	ДлинаСтроки     = СтрДлина(СтрокаРазбора);
	ОткрытаСкобка   = Ложь;
	ОткрытаКавычка  = Ложь;
	МассивРезультат = Новый Массив;
	ТекСтрока       = "";
	
	Пока Сч <= ДлинаСтроки Цикл
		Символ = Сред(СтрокаРазбора, Сч, 1);
		Если Символ = "(" ИЛИ Символ = "{" ИЛИ Символ = "[" Тогда
			ОткрытаСкобка = Истина;
		КонецЕсли;
		
		Если Символ = ")" ИЛИ Символ = "}" ИЛИ Символ = "]" Тогда
			ОткрытаСкобка = Ложь;
		КонецЕсли;
		
		Если Символ = """" Тогда
			ОткрытаКавычка = Не ОткрытаКавычка;
		КонецЕсли;
		
		Если Символ = Разделитель И Не ОткрытаСкобка
			И Не (Разделитель = "," И ОткрытаКавычка) Тогда
			МассивРезультат.Добавить(ТекСтрока);
			ТекСтрока = "";
		Иначе
			ТекСтрока = ТекСтрока + Символ;
		КонецЕсли;
		Сч = Сч + 1;
	КонецЦикла;
	
	Если ТекСтрока <> "" Тогда
		МассивРезультат.Добавить(ТекСтрока);
	КонецЕсли;
	
	Возврат МассивРезультат;
	
КонецФункции

// Загружает секцию переходов (shifts/reductions/gotos/accepts) из JSON
// и добавляет в общий МассивПереходов, восстанавливая полную структуру записи.
// Поддерживает группированный формат: "states" (массив) или "state" (одиночное значение).
Процедура ЗагрузитьСекциюПереходов(МассивПереходов, МассивСекции, ТипСимвола, ТипДействия)
	
	Для Каждого Переход Из МассивСекции Цикл
		// Получаем значения полей (могут отсутствовать в JSON — подставляем значения по умолчанию)
		Символ   = "";
		Редукция = "";
		Переход_ = "";
		Переход.Свойство("symbol",    Символ);
		Переход.Свойство("reduction",  Редукция);
		ЗначениеGoto = Неопределено;
		Если Переход.Свойство("goto", ЗначениеGoto) Тогда
			Переход_ = Строка(ЗначениеGoto);
		КонецЕсли;
		
		// Раскрываем states/state
		МассивСостояний = Неопределено;
		Переход.Свойство("states", МассивСостояний);
		
		Если МассивСостояний <> Неопределено Тогда
			Для Каждого Состояние Из МассивСостояний Цикл
				МассивПереходов.Добавить(Новый Структура("Состояние,Символ,ТипСимвола,Редукция,Переход,ТипДействия",
					Строка(Состояние), Символ, ТипСимвола, Редукция, Переход_, ТипДействия));
			КонецЦикла;
		Иначе
			МассивПереходов.Добавить(Новый Структура("Состояние,Символ,ТипСимвола,Редукция,Переход,ТипДействия",
				Строка(Переход.state), Символ, ТипСимвола, Редукция, Переход_, ТипДействия));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьЗначениеВСоответствиеПереходов(СоответствиеТерминалов, СоответствиеНетерминалов, стПереход, Символ = Неопределено)
	
	стМПА = Новый Структура("ТипДействия,Редукция,Переход");
	Ключ  = стПереход.Состояние + "_" + ?(Символ = Неопределено, стПереход.Символ, Символ);
	ЗаполнитьЗначенияСвойств(стМПА, стПереход);
	
	Если стПереход.ТипСимвола = "T" Тогда
		СоответствиеТерминалов.Вставить(Ключ, стМПА);
	Иначе
		СоответствиеНетерминалов.Вставить(Ключ, стМПА);
	КонецЕсли;
	
КонецПроцедуры

// Загружает и парсит JSON из общего макета
// Параметры:
//   ИмяШаблона - Строка - имя общего макета с JSON
// Возвращаемое значение:
//   Произвольный - результат парсинга JSON (Структура, Массив или примитив)
Функция ЗагрузитьДанныеИзШаблона(ИмяШаблона)
	
#Если Сервер Или ВнешнееСоединение Тогда
	Попытка
		Макет = ПолучитьОбщийМакет(ИмяШаблона);
	Исключение
		Сообщить("[ERR] ЗагрузитьДанныеИзШаблона: Ошибка получения макета: " + ОписаниеОшибки());
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		ТекстJSON = Макет.ПолучитьТекст();
	Исключение
		Сообщить("[ERR] ЗагрузитьДанныеИзШаблона: Ошибка получения текста: " + ОписаниеОшибки());
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТекстJSON);
		Данные = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
	Исключение
		Сообщить("[ERR] ЗагрузитьДанныеИзШаблона: Ошибка парсинга JSON: " + ОписаниеОшибки());
		Сообщить("[ERR] Первые 500 символов: " + Лев(ТекстJSON, 500));
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Данные;
#Иначе
	ВызватьИсключение "Функция ЗагрузитьДанныеИзШаблона доступна только на сервере";
#КонецЕсли
	
КонецФункции

#КонецОбласти

#Область Служебные_функции_получения_данных
  
Функция ПолучитьДанныеФормированияТаблицыПереходовПарсера()
	
	// Загружаем данные из JSON шаблона
	ДанныеJSON = ЗагрузитьДанныеИзШаблона("конс_ТаблицаПереходовПарсера");
	
	// Группы символов (соответствие: имя группы -> массив токенов)
	Попытка
		СоответствиеГруппСимволов = Новый Соответствие;
		Для Каждого КлючИЗначение Из ДанныеJSON.symbolGroups Цикл
			СоответствиеГруппСимволов.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	Исключение
		Сообщить("[ERR] Парсер: Ошибка обработки symbolGroups: " + ОписаниеОшибки());
		ВызватьИсключение;
	КонецПопытки;
	
	// Переходы LR-таблицы
	// Формат JSON: 4 секции (shifts, reductions, gotos, accepts) вместо единого transitions
	Попытка
		МассивПереходов = Новый Массив;
		
		// Сдвиги: symbolType=T, action=Сдвиг, есть goto, нет reduction
		ЗагрузитьСекциюПереходов(МассивПереходов, ДанныеJSON.shifts, "T", "Сдвиг");
		
		// Редукции: symbolType=T, action=Редукция, есть reduction, нет goto
		ЗагрузитьСекциюПереходов(МассивПереходов, ДанныеJSON.reductions, "T", "Редукция");
		
		// Переходы по нетерминалам: symbolType=N, action=Переход, есть goto, нет reduction
		ЗагрузитьСекциюПереходов(МассивПереходов, ДанныеJSON.gotos, "N", "Переход");
		
		// Завершение: symbolType=T, action=Завершение, нет goto, нет reduction
		ЗагрузитьСекциюПереходов(МассивПереходов, ДанныеJSON.accepts, "T", "Завершение");
		
	Исключение
		Сообщить("[ERR] Парсер: Ошибка обработки transitions: " + ОписаниеОшибки());
		ВызватьИсключение;
	КонецПопытки;

	ДанныеТаблицы = Новый Структура("СоответствиеГруппСимволов,МассивПереходов", СоответствиеГруппСимволов, МассивПереходов);

	Возврат ДанныеТаблицы;

КонецФункции

Функция ПолучитьДанныеФормированияТаблицыРедукций()
	
	// Загружаем данные из JSON шаблона
	ДанныеJSON = ЗагрузитьДанныеИзШаблона("конс_Грамматика");
	
	// Правила грамматики
	Попытка
		МассивГрамматики = Новый Массив;
		Для Каждого Правило Из ДанныеJSON.rules Цикл
			МассивГрамматики.Добавить(Новый Структура("Идентификатор,Выражение",
				Правило.id, Правило.expr));
		КонецЦикла;
	Исключение
		Сообщить("[ERR] Грамматика: Ошибка обработки rules: " + ОписаниеОшибки());
		ВызватьИсключение;
	КонецПопытки;

	Возврат МассивГрамматики;

КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// инт_ГенераторОбработок
//
// Генерация внешних обработок (EPF) из текста обработчика.
// Поддержка процедур/функций в коде обработчиков потоков данных и подписчиков.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Функция - Скомпилировать обработку
// Генерирует внешнюю обработку (EPF) из текста обработчика.
// Текст парсится: процедуры/функции остаются на уровне модуля,
// остальной код оборачивается в экспортную функцию Обработать().
//
// Параметры:
//  ТекстОбработчика     - Строка - Исходный текст обработчика из редактора кода.
//  ДополнительныеПеременные - Структура, Неопределено - Дополнительные переменные модуля.
//    Ключ - имя переменной, значение - начальное значение (Строка) или пустая строка.
//    Например: Новый Структура("Ответ", "") — добавит "Перем Ответ Экспорт;" в модуль.
//  ХешТекста            - Строка - Необязательный. Предварительно вычисленный хеш текста обработчика.
//    Если не указан — вычисляется автоматически.
//  СмещенияМодуля       - Неопределено, Структура - Выходной параметр. Если передана переменная,
//    заполняется структурой с ключами "СмещениеТелаКода", "СмещениеПроцедур" для пересчёта
//    номеров строк ошибок из сгенерированного модуля в строки исходного кода.
//
// Возвращаемое значение:
//  ДвоичныеДанные - Скомпилированная внешняя обработка (EPF).
//
Функция СкомпилироватьОбработку(Знач ТекстОбработчика, Знач ДополнительныеПеременные = Неопределено, Знач ХешТекста = "", СмещенияМодуля = Неопределено) Экспорт
	
	РезультатГенерации = СформироватьМодульОбъекта(ТекстОбработчика, ДополнительныеПеременные);
	МодульОбъекта = РезультатГенерации.ТекстМодуля;
	СмещениеТела = РезультатГенерации.СмещениеТелаКода;
	СмещениеПроцедур = РезультатГенерации.СмещениеПроцедур;
	
	СмещенияМодуля = Новый Структура("СмещениеТелаКода, СмещениеПроцедур", СмещениеТела, СмещениеПроцедур);
	
	ВременныйКаталог = ПолучитьИмяВременногоФайла() + "\";
	СоздатьКаталог(ВременныйКаталог);
	
	Попытка
		// Записываем XML-скелет обработки.
		КорневойФайл = ВременныйКаталог + "Обработка.xml";
		ПолучитьОбщийМакет("инт_СтруктураВнешнейОбработки").Записать(КорневойФайл);
		
		// Записываем модуль объекта.
		КаталогМодуля = ВременныйКаталог + "Обработка" + ПолучитьРазделительПути() + "Ext" + ПолучитьРазделительПути();
		СоздатьКаталог(КаталогМодуля);
		
		ТекДок = Новый ТекстовыйДокумент;
		ТекДок.УстановитьТекст(МодульОбъекта);
		ТекДок.Записать(КаталогМодуля + "ObjectModule.bsl", КодировкаТекста.UTF8);
		
		// Компилируем XML -> EPF через Конфигуратор.
		ФайлEPF = ВременныйКаталог + "Обработка.epf";
		СкомпилироватьXMLвEPF(КорневойФайл, ФайлEPF, СмещениеТела, СмещениеПроцедур);
		
		// Читаем результат.
		Результат = Новый ДвоичныеДанные(ФайлEPF);
	Исключение
		// Очистка при ошибке.
		Попытка
			УдалитьФайлы(ВременныйКаталог);
		Исключение
			// Игнорируем ошибки удаления.
		КонецПопытки;
		ВызватьИсключение;
	КонецПопытки;
	
	// Очистка.
	Попытка
		УдалитьФайлы(ВременныйКаталог);
	Исключение
		// Игнорируем ошибки удаления.
	КонецПопытки;
	
	// Помещаем скомпилированный EPF в файловый кэш.
	ПоместитьВКэш(Результат);
	
	Возврат Результат;
	
КонецФункции

// Функция - Хеш текста обработчика
// Вычисляет MD5-хеш текста для определения необходимости перекомпиляции.
//
// Параметры:
//  ТекстОбработчика - Строка - Текст обработчика.
//
// Возвращаемое значение:
//  Строка - MD5-хеш текста в HEX-представлении.
//
Функция ХешТекстаОбработчика(Знач ТекстОбработчика) Экспорт
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеширование.Добавить(ТекстОбработчика);
	
	Возврат СтрЗаменить(Хеширование.ХешСумма, " ", "");
	
КонецФункции

// Функция - Каталог кэша объекта
// Возвращает путь к подкаталогу кэша для конкретного объекта (потока/подписчика).
// Используется для организации EPF-файлов по GUID объектов:
//   {корень кэша}/{ИдОбъекта}/
//
// Параметры:
//  ИдОбъекта - Строка - Уникальный идентификатор объекта (GUID).
//
// Возвращаемое значение:
//  Строка - Полный путь к каталогу кэша объекта (с завершающим разделителем).
//
Функция КаталогКэшаОбъекта(Знач ИдОбъекта) Экспорт
	
	Каталог = инт_ГенераторОбработокПовтИсп.КорневойКаталогКэша() + ИдОбъекта + ПолучитьРазделительПути();
	
	КаталогФайл = Новый Файл(Каталог);
	Если Не КаталогФайл.Существует() Тогда
		СоздатьКаталог(Каталог);
	КонецЕсли;
	
	Возврат Каталог;
	
КонецФункции

// Функция - Обеспечить EPF на диске
// Гарантирует наличие файла EPF в каталоге кэша объекта.
// Если файл уже существует — возвращает путь без записи.
//
// Параметры:
//  ДвоичныеДанныеEPF - ДвоичныеДанные - Скомпилированная внешняя обработка.
//  ИдОбъекта         - Строка - GUID объекта (потока/подписчика).
//  ХешТекста         - Строка - MD5-хеш текста обработчика.
//
// Возвращаемое значение:
//  Строка - Полный путь к EPF-файлу в кэше объекта.
//
Функция ОбеспечитьEPFНаДиске(Знач ДвоичныеДанныеEPF, Знач ИдОбъекта, Знач ХешТекста) Экспорт
	
	КаталогОбъекта = КаталогКэшаОбъекта(ИдОбъекта);
	ПутьКФайлу = КаталогОбъекта + ХешТекста + ".epf";
	
	Файл = Новый Файл(ПутьКФайлу);
	Если Файл.Существует() Тогда
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.КэшEPF",
			УровеньЖурналаРегистрации.Примечание, , ,
			СтрШаблон("ОбеспечитьEPFНаДиске: уже существует. Объект: %1, Хеш: %2, Путь: %3", ИдОбъекта, ХешТекста, ПутьКФайлу));
	Иначе
		ДвоичныеДанныеEPF.Записать(ПутьКФайлу);
		ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.КэшEPF",
			УровеньЖурналаРегистрации.Примечание, , ,
			СтрШаблон("ОбеспечитьEPFНаДиске: записан новый файл. Объект: %1, Хеш: %2, Путь: %3", ИдОбъекта, ХешТекста, ПутьКФайлу));
	КонецЕсли;
	
	Возврат ПутьКФайлу;
	
КонецФункции

// Функция - Исполнить обработку
// Создает экземпляр внешней обработки из двоичных данных или по пути к файлу
// и вызывает точку входа. Используется для потоков данных.
// EPF кэшируется на диске по хешу содержимого.
//
// Параметры:
//  ДвоичныеДанныеИлиПутьEPF - ДвоичныеДанные, Строка - Скомпилированная внешняя обработка
//    или полный путь к EPF-файлу на диске.
//  ИсходныеДанные       - Произвольный - Данные для обработки (ссылка на объект или соответствие).
//  РазрешитьФиксациюИзменений - Булево - Разрешить фиксацию транзакции.
//
// Возвращаемое значение:
//  Соответствие - Результат выполнения обработчика.
//
Функция ИсполнитьОбработку(Знач ДвоичныеДанныеИлиПутьEPF, ИсходныеДанные, РазрешитьФиксациюИзменений = Ложь) Экспорт
	
	Если ТипЗнч(ДвоичныеДанныеИлиПутьEPF) = Тип("Строка") Тогда
		ИмяФайла = ДвоичныеДанныеИлиПутьEPF;
	Иначе
		ИмяФайла = ПолучитьФайлИзКэша(ДвоичныеДанныеИлиПутьEPF);
	КонецЕсли;
	
	// Создаём экземпляр обработки ДО установки безопасного режима,
	// т.к. ВнешниеОбработки.Создать() требует полных привилегий.
	Обработка = ВнешниеОбработки.Создать(ИмяФайла, Ложь);
	
	Попытка
		УстановитьБезопасныйРежим(Истина);
		НачатьТранзакцию();
		Попытка
			Результат = Обработка.Обработать(ИсходныеДанные);
			
			Если РазрешитьФиксациюИзменений Тогда
				ЗафиксироватьТранзакцию();
			Иначе
				ВызватьИсключение "ПлановыйОткатТранзакции";
			КонецЕсли;
		Исключение
			ОтменитьТранзакцию();
			Если Не ИнформацияОбОшибке().Описание = "ПлановыйОткатТранзакции" Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
		УстановитьБезопасныйРежим(Ложь);
	Исключение
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Функция - Исполнить обработку подписчика
// Создает экземпляр внешней обработки из двоичных данных или по пути к файлу
// и вызывает точку входа подписчика.
// Подписчик получает Ответ и ИсходныеДанные. EPF кэшируется на диске по хешу содержимого.
//
// Параметры:
//  ДвоичныеДанныеИлиПутьEPF - ДвоичныеДанные, Строка - Скомпилированная внешняя обработка
//    или полный путь к EPF-файлу на диске.
//  Ответ                - Произвольный - Ответ от HTTP/JRPC запроса.
//  ИсходныеДанные       - Произвольный - Исходные данные сообщения.
//  РазрешитьФиксациюИзменений - Булево - Разрешить фиксацию транзакции.
//
Процедура ИсполнитьОбработкуПодписчика(Знач ДвоичныеДанныеИлиПутьEPF, Ответ, ИсходныеДанные, РазрешитьФиксациюИзменений = Ложь) Экспорт
	
	Если ТипЗнч(ДвоичныеДанныеИлиПутьEPF) = Тип("Строка") Тогда
		ИмяФайла = ДвоичныеДанныеИлиПутьEPF;
	Иначе
		ИмяФайла = ПолучитьФайлИзКэша(ДвоичныеДанныеИлиПутьEPF);
	КонецЕсли;
	
	// Создаём экземпляр обработки ДО установки безопасного режима,
	// т.к. ВнешниеОбработки.Создать() требует полных привилегий.
	Обработка = ВнешниеОбработки.Создать(ИмяФайла, Ложь);
	
	Попытка
		УстановитьБезопасныйРежим(Истина);
		НачатьТранзакцию();
		Попытка
			Обработка.ОбработатьПостПроцессинг(Ответ, ИсходныеДанные);
			
			Если РазрешитьФиксациюИзменений Тогда
				ЗафиксироватьТранзакцию();
			Иначе
				ОтменитьТранзакцию();
			КонецЕсли;
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		УстановитьБезопасныйРежим(Ложь);
	Исключение
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Функция - Сформировать модуль объекта
// Формирует текст модуля объекта внешней обработки из текста обработчика.
// Процедуры/функции из исходного кода помещаются на уровень модуля,
// остальной код оборачивается в функцию Обработать() Экспорт.
//
// Параметры:
//  ТекстОбработчика         - Строка - Исходный текст обработчика.
//  ДополнительныеПеременные - Структура, Неопределено - Дополнительные переменные модуля (для подписчиков).
//
// Возвращаемое значение:
//  Строка - Текст модуля объекта.
//
Функция СформироватьМодульОбъекта(Знач ТекстОбработчика, Знач ДополнительныеПеременные = Неопределено) Экспорт
	
	Блоки = РазобратьКодНаБлоки(ТекстОбработчика);
	
	Строки = Новый Массив;
	
	// Объявление переменных модуля.
	Строки.Добавить("Перем Результат Экспорт;");
	Строки.Добавить("Перем ИсходныеДанные;");
	
	Если ДополнительныеПеременные <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ДополнительныеПеременные Цикл
			Строки.Добавить("Перем " + КлючИЗначение.Ключ + ";");
		КонецЦикла;
	КонецЕсли;
	
	Строки.Добавить("");
	
	// Запоминаем номер строки, с которой начинаются процедуры/функции пользователя.
	// Нумерация с 1, а Строки.Количество() — это индекс следующей строки (с 0), значит + 1.
	СмещениеПроцедур = Строки.Количество() + 1;
	
	// Блоки процедур/функций пользователя.
	Для Каждого БлокПроцедуры Из Блоки.БлокиПроцедур Цикл
		Строки.Добавить(БлокПроцедуры);
		Строки.Добавить("");
	КонецЦикла;
	
	// Точка входа для потоков данных.
	Строки.Добавить("Функция Обработать(пИсходныеДанные) Экспорт");
	Строки.Добавить("	ИсходныеДанные = пИсходныеДанные;");
	Строки.Добавить("	Результат = Новый Соответствие;");
	
	Если ДополнительныеПеременные <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ДополнительныеПеременные Цикл
			Если ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
				Строки.Добавить("	" + КлючИЗначение.Ключ + " = " + КлючИЗначение.Значение + ";");
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Встраиваемый код (всё что не процедуры/функции).
	// Запоминаем смещение: номер строки в модуле, где начинается тело кода пользователя.
	Если ЗначениеЗаполнено(Блоки.ТелоКода) Тогда
		Строки.Добавить("	");
		СмещениеТелаКода = Строки.Количество() + 1; // следующая добавленная строка — первая строка тела
		// Добавляем каждую строку тела код с отступом.
		СтрокиТела = СтрРазделить(Блоки.ТелоКода, Символы.ПС);
		Для Каждого СтрокаТела Из СтрокиТела Цикл
			Строки.Добавить("	" + СтрокаТела);
		КонецЦикла;
	Иначе
		СмещениеТелаКода = 0;
	КонецЕсли;
	
	Строки.Добавить("	");
	Строки.Добавить("	Возврат Результат;");
	Строки.Добавить("КонецФункции");
	
	// Точка входа для подписчиков (если есть дополнительные переменные).
	Если ДополнительныеПеременные <> Неопределено И ДополнительныеПеременные.Свойство("Ответ") Тогда
		Строки.Добавить("");
		Строки.Добавить("Процедура ОбработатьПостПроцессинг(пОтвет, пИсходныеДанные) Экспорт");
		Строки.Добавить("	Ответ = пОтвет;");
		Строки.Добавить("	ИсходныеДанные = пИсходныеДанные;");
		Строки.Добавить("	Результат = Новый Соответствие;");
		
		Если ЗначениеЗаполнено(Блоки.ТелоКода) Тогда
			Строки.Добавить("	");
			СтрокиТела = СтрРазделить(Блоки.ТелоКода, Символы.ПС);
			Для Каждого СтрокаТела Из СтрокиТела Цикл
				Строки.Добавить("	" + СтрокаТела);
			КонецЦикла;
		КонецЕсли;
		
		Строки.Добавить("КонецПроцедуры");
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("ТекстМодуля", СтрСоединить(Строки, Символы.ПС));
	Результат.Вставить("СмещениеТелаКода", СмещениеТелаКода);
	Результат.Вставить("СмещениеПроцедур", СмещениеПроцедур);
	
	Возврат Результат;
	
КонецФункции

// Функция - Разобрать код на блоки
// Разбирает текст обработчика на блоки процедур/функций и тело кода.
//
// Параметры:
//  ТекстОбработчика - Строка - Исходный текст обработчика.
//
// Возвращаемое значение:
//  Структура:
//    * БлокиПроцедур - Массив из Строка - Тексты процедур/функций.
//    * ТелоКода      - Строка - Код, не входящий в процедуры/функции.
//
Функция РазобратьКодНаБлоки(Знач ТекстОбработчика) Экспорт
	
	БлокиПроцедур = Новый Массив;
	СтрокиТела = Новый Массив;
	
	Строки = СтрРазделить(ТекстОбработчика, Символы.ПС);
	
	ВнутриБлока = Ложь;
	ТекущийБлок = Новый Массив;
	ГлубинаВложенности = 0;
	
	Для Каждого Строка Из Строки Цикл
		
		СтрокаОбрезанная = СокрЛП(ВРег(Строка));
		
		// Пропускаем пустые строки и комментарии для анализа ключевых слов.
		ЭтоКомментарий = СтрНачинаетсяС(СтрокаОбрезанная, "//");
		
		Если Не ВнутриБлока Тогда
			// Ищем начало процедуры/функции.
			Если Не ЭтоКомментарий И ЭтоНачалоБлока(СтрокаОбрезанная) Тогда
				ВнутриБлока = Истина;
				ГлубинаВложенности = 1;
				ТекущийБлок = Новый Массив;
				ТекущийБлок.Добавить(Строка);
			Иначе
				СтрокиТела.Добавить(Строка);
			КонецЕсли;
		Иначе
			ТекущийБлок.Добавить(Строка);
			
			Если Не ЭтоКомментарий Тогда
				// Вложенные процедуры/функции (если/когда будут поддержаны),
				// а пока учитываем Если/Цикл/Попытка для корректности не нужно,
				// т.к. КонецПроцедуры/КонецФункции уникальны.
				Если ЭтоКонецБлока(СтрокаОбрезанная) Тогда
					ГлубинаВложенности = ГлубинаВложенности - 1;
					Если ГлубинаВложенности <= 0 Тогда
						БлокиПроцедур.Добавить(СтрСоединить(ТекущийБлок, Символы.ПС));
						ВнутриБлока = Ложь;
						ТекущийБлок = Новый Массив;
					КонецЕсли;
				ИначеЕсли ЭтоНачалоБлока(СтрокаОбрезанная) Тогда
					ГлубинаВложенности = ГлубинаВложенности + 1;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	// Если блок не был закрыт — добавляем как тело.
	Если ВнутриБлока И ТекущийБлок.Количество() > 0 Тогда
		Для Каждого СтрокаБлока Из ТекущийБлок Цикл
			СтрокиТела.Добавить(СтрокаБлока);
		КонецЦикла;
	КонецЕсли;
	
	// Убираем завершающие пустые строки из тела.
	Пока СтрокиТела.Количество() > 0 И ПустаяСтрока(СтрокиТела[СтрокиТела.ВГраница()]) Цикл
		СтрокиТела.Удалить(СтрокиТела.ВГраница());
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("БлокиПроцедур", БлокиПроцедур);
	Результат.Вставить("ТелоКода", СтрСоединить(СтрокиТела, Символы.ПС));
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ЭтоНачалоБлока(Знач СтрокаВерхнемРегистре)
	Возврат СтрНачинаетсяС(СтрокаВерхнемРегистре, "ПРОЦЕДУРА ")
		ИЛИ СтрНачинаетсяС(СтрокаВерхнемРегистре, "ФУНКЦИЯ ")
		ИЛИ СтрокаВерхнемРегистре = "ПРОЦЕДУРА"
		ИЛИ СтрокаВерхнемРегистре = "ФУНКЦИЯ";
КонецФункции

Функция ЭтоКонецБлока(Знач СтрокаВерхнемРегистре)
	Возврат СтрНачинаетсяС(СтрокаВерхнемРегистре, "КОНЕЦПРОЦЕДУРЫ")
		ИЛИ СтрНачинаетсяС(СтрокаВерхнемРегистре, "КОНЕЦФУНКЦИИ");
КонецФункции

// Функция - Получить файл из кэша
// Проверяет наличие EPF-файла в файловом кэше по хешу двоичных данных.
// Если файл отсутствует — записывает его в кэш. Возвращает путь к файлу.
//
// Параметры:
//  ДвоичныеДанныеEPF - ДвоичныеДанные - Скомпилированная внешняя обработка.
//
// Возвращаемое значение:
//  Строка - Полный путь к EPF-файлу в кэше.
//
Функция ПолучитьФайлИзКэша(Знач ДвоичныеДанныеEPF)
	
	Хеш = ХешДвоичныхДанных(ДвоичныеДанныеEPF);
	Каталог = КаталогКэшаEPF();
	ПутьКФайлу = Каталог + Хеш + ".epf";
	
	Файл = Новый Файл(ПутьКФайлу);
	Если Не Файл.Существует() Тогда
		ДвоичныеДанныеEPF.Записать(ПутьКФайлу);
	КонецЕсли;
	
	Возврат ПутьКФайлу;
	
КонецФункции

// Процедура - Поместить в кэш
// Записывает скомпилированный EPF-файл в файловый кэш, используя хеш как имя файла.
//
// Параметры:
//  ДвоичныеДанныеEPF - ДвоичныеДанные - Скомпилированная внешняя обработка.
//
Процедура ПоместитьВКэш(Знач ДвоичныеДанныеEPF)
	
	Хеш = ХешДвоичныхДанных(ДвоичныеДанныеEPF);
	Каталог = КаталогКэшаEPF();
	ПутьКФайлу = Каталог + Хеш + ".epf";
	
	Файл = Новый Файл(ПутьКФайлу);
	Если Не Файл.Существует() Тогда
		ДвоичныеДанныеEPF.Записать(ПутьКФайлу);
	КонецЕсли;
	
КонецПроцедуры

// Функция - Каталог кэша EPF
// Возвращает путь к каталогу файлового кэша EPF. Создаёт каталог при первом обращении.
//
// Возвращаемое значение:
//  Строка - Путь к каталогу кэша (с завершающим разделителем пути).
//
Функция КаталогКэшаEPF()
	
	Возврат инт_ГенераторОбработокПовтИсп.КорневойКаталогКэша();
	
КонецФункции

// Функция - Хеш двоичных данных
// Вычисляет MD5-хеш двоичных данных для использования в качестве ключа кэша.
//
// Параметры:
//  ДвоичныеДанные - ДвоичныеДанные - Данные для хеширования.
//
// Возвращаемое значение:
//  Строка - MD5-хеш в HEX-представлении (без пробелов).
//
Функция ХешДвоичныхДанных(Знач ДвоичныеДанные)
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеширование.Добавить(ДвоичныеДанные);
	
	Возврат СтрЗаменить(Хеширование.ХешСумма, " ", "");
	
КонецФункции

Процедура СкомпилироватьXMLвEPF(Знач КорневойФайлXML, Знач ФайлEPF, Знач СмещениеТела = 0, Знач СмещениеПроцедур = 0)
	
	ПутьКПлатформе = ОпределитьПутьКПлатформе();
	КаталогБазы = ОпределитьКаталогБазы();
	ФайлЛога = ПолучитьИмяВременногоФайла("log");
	
	// Создаём пустую временную базу для компиляции.
	СоздатьВременнуюБазу(ПутьКПлатформе, КаталогБазы);
	
	Попытка
		ЭтоLinux = ЭтоLinuxСервер();
		Если ЭтоLinux Тогда
			СтрокаЗапуска = ПутьКПлатформе + "1cv8 DESIGNER /F""" 
				+ КаталогБазы + """ /LoadExternalDataProcessorOrReportFromFiles """ 
				+ КорневойФайлXML + """ """ + ФайлEPF + """ /Out """ + ФайлЛога + """";
		Иначе
			СтрокаЗапуска = """" + ПутьКПлатформе + "1cv8"" DESIGNER /F """ 
				+ КаталогБазы + """ /LoadExternalDataProcessorOrReportFromFiles """ 
				+ КорневойФайлXML + """ """ + ФайлEPF + """ /Out """ + ФайлЛога + """";
		КонецЕсли;
		
		КодВозврата = ЗапуститьПриложениеСкрытно(СтрокаЗапуска);
		
		Если КодВозврата <> 0 Тогда
			ТекстОшибки = ПрочитатьЛогКомпиляции(ФайлЛога, СмещениеТела, СмещениеПроцедур);
			Если ПустаяСтрока(ТекстОшибки) Тогда
				ТекстОшибки = СтрШаблон("Ошибка компиляции обработки. Код возврата: %1.", КодВозврата);
			КонецЕсли;
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		
		ФайлРезультат = Новый Файл(ФайлEPF);
		Если Не ФайлРезультат.Существует() Тогда
			ТекстОшибки = ПрочитатьЛогКомпиляции(ФайлЛога, СмещениеТела, СмещениеПроцедур);
			Если ПустаяСтрока(ТекстОшибки) Тогда
				ТекстОшибки = "Ошибка компиляции обработки: файл EPF не был создан.";
			КонецЕсли;
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
	Исключение
		// Очистка временной базы при ошибке.
		Попытка
			УдалитьФайлы(КаталогБазы);
		Исключение
			// Игнорируем.
		КонецПопытки;
		ВызватьИсключение;
	КонецПопытки;
	
	// Очистка временной базы.
	Попытка
		УдалитьФайлы(КаталогБазы);
	Исключение
		// Игнорируем.
	КонецПопытки;
	
КонецПроцедуры

Процедура СоздатьВременнуюБазу(Знач ПутьКПлатформе, Знач КаталогБазы)
	
	СоздатьКаталог(КаталогБазы);
	
	ЭтоLinux = ЭтоLinuxСервер();
	Если ЭтоLinux Тогда
		СтрокаЗапуска = ПутьКПлатформе + "1cv8 CREATEINFOBASE File=""" + КаталогБазы + """";
	Иначе
		СтрокаЗапуска = """" + ПутьКПлатформе + "1cv8"" CREATEINFOBASE File=""" + КаталогБазы + """";
	КонецЕсли;
	
	КодВозврата = ЗапуститьПриложениеСкрытно(СтрокаЗапуска);
	
	Если КодВозврата <> 0 Тогда
		ВызватьИсключение СтрШаблон("Ошибка создания временной базы для компиляции EPF. Код возврата: %1.
			|Команда: %2", КодВозврата, СтрокаЗапуска);
	КонецЕсли;
	
КонецПроцедуры

Функция ОпределитьПутьКПлатформе()
	
	Возврат инт_ГенераторОбработокПовтИсп.ПутьКПлатформе();
	
КонецФункции

Функция ОпределитьКаталогБазы()
	
	// Используем каталог временной базы.
	Возврат ПолучитьИмяВременногоФайла() + "_ib";
	
КонецФункции

Функция ВерсияПриложения()
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ВерсияПриложения;
КонецФункции

Функция ЭтоLinuxСервер()
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 
		ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
КонецФункции

// Функция - Запустить приложение скрытно
// Запускает команду без отображения окна процесса (не сбивает фокус).
// На Windows использует WScript.Shell с параметром intWindowStyle = 0 (SW_HIDE),
// на Linux использует стандартный ЗапуститьПриложение().
//
// Параметры:
//  СтрокаЗапуска - Строка - Командная строка для запуска.
//
// Возвращаемое значение:
//  Число - Код возврата процесса.
//
Функция ЗапуститьПриложениеСкрытно(Знач СтрокаЗапуска)
	
	Если ЭтоLinuxСервер() Тогда
		КодВозврата = Неопределено;
		ЗапуститьПриложение(СтрокаЗапуска, , Истина, КодВозврата);
		Возврат КодВозврата;
	КонецЕсли;
	
	// Windows: запускаем через WScript.Shell с скрытым окном.
	// Run(Команда, 0 = SW_HIDE, Истина = дождаться завершения)
	Shell = Новый COMОбъект("WScript.Shell");
	КодВозврата = Shell.Run(СтрокаЗапуска, 0, Истина);
	Возврат КодВозврата;
	
КонецФункции

// Функция - Прочитать лог компиляции
// Читает файл лога DESIGNER и пересчитывает номера строк модуля в номера строк
// исходного кода обработчика, чтобы ошибки были привязаны к редактору.
//
// Параметры:
//  ФайлЛога          - Строка - Путь к файлу лога.
//  СмещениеТела      - Число  - Номер строки модуля, с которой начинается тело кода (inline).
//  СмещениеПроцедур  - Число  - Номер строки модуля, с которой начинаются процедуры/функции.
//
// Возвращаемое значение:
//  Строка - Текст ошибок с пересчитанными номерами строк. Пустая строка, если лог не найден.
//
Функция ПрочитатьЛогКомпиляции(Знач ФайлЛога, Знач СмещениеТела, Знач СмещениеПроцедур)
	
	ЛогФайл = Новый Файл(ФайлЛога);
	Если Не ЛогФайл.Существует() Тогда
		Возврат "";
	КонецЕсли;
	
	Попытка
		ТекДок = Новый ТекстовыйДокумент;
		ТекДок.Прочитать(ФайлЛога, КодировкаТекста.UTF8);
		СодержимоеЛога = ТекДок.ПолучитьТекст();
	Исключение
		Возврат "";
	КонецПопытки;
	
	Если ПустаяСтрока(СодержимоеЛога) Тогда
		Возврат "";
	КонецЕсли;
	
	// Пересчитываем номера строк в сообщениях вида {ObjectModule}(15,5): или {Обработка.ObjectModule}(15,5):
	// Формат: (НомерСтроки,НомерСтолбца)
	Результат = СодержимоеЛога;
	
	Если СмещениеТела > 0 ИЛИ СмещениеПроцедур > 0 Тогда
		СтрокиЛога = СтрРазделить(СодержимоеЛога, Символы.ПС);
		ОбработанныеСтроки = Новый Массив;
		
		Для Каждого СтрокаЛога Из СтрокиЛога Цикл
			ОбработанныеСтроки.Добавить(ПересчитатьСтрокуОшибки(СтрокаЛога, СмещениеТела, СмещениеПроцедур));
		КонецЦикла;
		
		Результат = СтрСоединить(ОбработанныеСтроки, Символы.ПС);
	КонецЕсли;
	
	// Удаляем временный файл лога.
	Попытка
		УдалитьФайлы(ФайлЛога);
	Исключение
		// Игнорируем.
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Функция - Пересчитать строку ошибки
// Заменяет номер строки модуля на номер строки в исходном коде обработчика.
//
// Параметры:
//  СтрокаЛога        - Строка - Строка из лога компиляции.
//  СмещениеТела      - Число  - Смещение тела кода.
//  СмещениеПроцедур  - Число  - Смещение процедур/функций.
//
// Возвращаемое значение:
//  Строка - Строка с пересчитанным номером.
//
Функция ПересчитатьСтрокуОшибки(Знач СтрокаЛога, Знач СмещениеТела, Знач СмещениеПроцедур)
	
	// Ищем паттерн (НомерСтроки,НомерСтолбца): после ObjectModule
	ПозОткр = СтрНайти(СтрокаЛога, "(");
	Если ПозОткр = 0 Тогда
		Возврат СтрокаЛога;
	КонецЕсли;
	
	ПозЗакр = СтрНайти(СтрокаЛога, ")", , ПозОткр);
	Если ПозЗакр = 0 Тогда
		Возврат СтрокаЛога;
	КонецЕсли;
	
	СодержимоеСкобок = Сред(СтрокаЛога, ПозОткр + 1, ПозЗакр - ПозОткр - 1);
	Части = СтрРазделить(СодержимоеСкобок, ",");
	Если Части.Количество() < 2 Тогда
		Возврат СтрокаЛога;
	КонецЕсли;
	
	Попытка
		НомерСтрокиМодуля = Число(СокрЛП(Части[0]));
	Исключение
		Возврат СтрокаЛога;
	КонецПопытки;
	
	// Определяем, к какой части кода относится строка.
	// Если строка >= СмещениеТела и СмещениеТела > 0 — это тело кода обработчика.
	// Если строка >= СмещениеПроцедур и строка < СмещениеТела — это пользовательские процедуры.
	// Для тела кода пересчёт: ИсходнаяСтрока = НомерСтрокиМодуля - СмещениеТела + 1
	// (прибавляем количество строк в процедурах, т.к. в исходном коде процедуры идут вперемешку с телом)
	Если СмещениеТела > 0 И НомерСтрокиМодуля >= СмещениеТела Тогда
		НомерСтрокиИсходный = НомерСтрокиМодуля - СмещениеТела + 1;
	ИначеЕсли СмещениеПроцедур > 0 И НомерСтрокиМодуля >= СмещениеПроцедур Тогда
		НомерСтрокиИсходный = НомерСтрокиМодуля - СмещениеПроцедур + 1;
	Иначе
		// Строка в обвязке — не пересчитываем.
		Возврат СтрокаЛога;
	КонецЕсли;
	
	НовоеСодержимое = "(" + Формат(НомерСтрокиИсходный, "ЧГ=") + "," + СокрЛП(Части[1]) + ")";
	Возврат Лев(СтрокаЛога, ПозОткр - 1) + НовоеСодержимое + Сред(СтрокаЛога, ПозЗакр + 1);
	
КонецФункции

#КонецОбласти

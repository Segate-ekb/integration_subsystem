////////////////////////////////////////////////////////////////////////////////
// инт_ГенераторОбработок
//
// Генерация внешних обработок (EPF) из текста обработчика.
// Поддержка процедур/функций в коде обработчиков потоков данных и подписчиков.
//
// Компиляция EPF выполняется редактированием бинарного контейнера в памяти
// (без вызова Конфигуратора, создания временных файлов и баз данных)
// с использованием обработки инт_РедакторОбработки.
//
// Кэширование:
//   1. БД — СкомпилированныйОбработчик (ХранилищеЗначения) в справочнике потоков/подписчиков.
//   2. Сеанс — ПовтИсп (инт_ГенераторОбработокПовтИсп) хранит ДвоичныеДанные EPF.
// Дисковый кэш не используется; EPF подключается из временного хранилища.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Функция - Скомпилировать обработку
// Генерирует внешнюю обработку (EPF) из текста обработчика.
// Текст парсится: процедуры/функции остаются на уровне модуля,
// остальной код оборачивается в экспортную функцию Обработать().
//
// Параметры:
//  ТекстОбработчика     - Строка - Исходный текст обработчика из редактора кода.
//  ДополнительныеПеременные - Структура, Неопределено - Дополнительные переменные модуля.
//    Ключ - имя переменной, значение - начальное значение (Строка) или пустая строка.
//    Например: Новый Структура("Ответ", "") — добавит "Перем Ответ Экспорт;" в модуль.
//  ХешТекста            - Строка - Необязательный. Предварительно вычисленный хеш текста обработчика.
//    Если не указан — вычисляется автоматически.
//  СмещенияМодуля       - Неопределено, Структура - Выходной параметр. Если передана переменная,
//    заполняется структурой с ключами "СмещениеТелаКода", "СмещениеПроцедур" для пересчёта
//    номеров строк ошибок из сгенерированного модуля в строки исходного кода.
//
// Возвращаемое значение:
//  ДвоичныеДанные - Скомпилированная внешняя обработка (EPF).
//
Функция СкомпилироватьОбработку(Знач ТекстОбработчика, Знач ДополнительныеПеременные = Неопределено, Знач ХешТекста = "", СмещенияМодуля = Неопределено) Экспорт
	
	РезультатГенерации = СформироватьМодульОбъекта(ТекстОбработчика, ДополнительныеПеременные);
	МодульОбъекта = РезультатГенерации.ТекстМодуля;
	СмещениеТела = РезультатГенерации.СмещениеТелаКода;
	СмещениеПроцедур = РезультатГенерации.СмещениеПроцедур;
	
	СмещенияМодуля = Новый Структура("СмещениеТелаКода, СмещениеПроцедур", СмещениеТела, СмещениеПроцедур);
	
	// Компилируем EPF редактированием бинарного контейнера в памяти
	// (без вызова Конфигуратора и без создания временных файлов/баз).
	Возврат СкомпилироватьEPFВПамяти(МодульОбъекта);
	
КонецФункции

// Функция - Хеш текста обработчика
// Вычисляет MD5-хеш текста для определения необходимости перекомпиляции.
//
// Параметры:
//  ТекстОбработчика - Строка - Текст обработчика.
//
// Возвращаемое значение:
//  Строка - MD5-хеш текста в HEX-представлении.
//
Функция ХешТекстаОбработчика(Знач ТекстОбработчика) Экспорт
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеширование.Добавить(ТекстОбработчика);
	
	Возврат СтрЗаменить(Хеширование.ХешСумма, " ", "");
	
КонецФункции

// Функция - Разрешить EPF
// Двухуровневый кэш: двоичные данные из БД → компиляция из текста.
// Возвращает двоичные данные скомпилированного EPF.
//
// Параметры:
//  ТекстОбработчика        - Строка - Исходный текст обработчика.
//  ДвоичныеДанныеИзБД      - ДвоичныеДанные, Неопределено - Предкомпилированный EPF из базы.
//  ДополнительныеПеременные - Структура, Неопределено - Переменные для компиляции (Ответ, ИсходныеДанные и т.п.).
//
// Возвращаемое значение:
//  ДвоичныеДанные - Скомпилированная внешняя обработка (EPF).
//
Функция РазрешитьEPF(Знач ТекстОбработчика,
	Знач ДвоичныеДанныеИзБД = Неопределено,
	Знач ДополнительныеПеременные = Неопределено) Экспорт
	
	// 1. EPF из БД.
	Если ДвоичныеДанныеИзБД <> Неопределено Тогда
		Возврат ДвоичныеДанныеИзБД;
	КонецЕсли;
	
	// 2. Компилируем заново из текста.
	Возврат СкомпилироватьОбработку(ТекстОбработчика, ДополнительныеПеременные);
	
КонецФункции

// Функция - Подключить обработку
// Помещает двоичные данные EPF во временное хранилище,
// подключает внешнюю обработку и возвращает её имя.
// После подключения обработка остаётся в памяти сеанса —
// повторные вызовы ВнешниеОбработки.Создать(Имя) не требуют повторного подключения.
//
// Параметры:
//  ДвоичныеДанныеEPF - ДвоичныеДанные - Скомпилированная внешняя обработка.
//
// Возвращаемое значение:
//  Строка - Имя подключённой обработки (для ВнешниеОбработки.Создать()).
//
Функция ПодключитьОбработку(Знач ДвоичныеДанныеEPF) Экспорт
	
	АдресEPF = ПоместитьВоВременноеХранилище(ДвоичныеДанныеEPF);
	Возврат ВнешниеОбработки.Подключить(АдресEPF, , Ложь);
	
КонецФункции

// Функция - Исполнить обработку
// Создает экземпляр внешней обработки и вызывает точку входа.
// Используется для потоков данных.
//
// Параметры:
//  ИмяИлиДвоичныеДанныеEPF - Строка, ДвоичныеДанные - Имя подключённой обработки
//    или двоичные данные EPF (будут подключены автоматически).
//  ИсходныеДанные       - Произвольный - Данные для обработки (ссылка на объект или соответствие).
//  РазрешитьФиксациюИзменений - Булево - Разрешить фиксацию транзакции.
//
// Возвращаемое значение:
//  Соответствие - Результат выполнения обработчика.
//
Функция ИсполнитьОбработку(Знач ИмяИлиДвоичныеДанныеEPF, ИсходныеДанные, РазрешитьФиксациюИзменений = Ложь) Экспорт
	
	ИмяОбработки = РазрешитьИмяОбработки(ИмяИлиДвоичныеДанныеEPF);
	Обработка = ВнешниеОбработки.Создать(ИмяОбработки, Ложь);
	
	Попытка
		УстановитьБезопасныйРежим(Истина);
		НачатьТранзакцию();
		Попытка
			Результат = Обработка.Обработать(ИсходныеДанные);
			
			Если РазрешитьФиксациюИзменений Тогда
				ЗафиксироватьТранзакцию();
			Иначе
				ВызватьИсключение "ПлановыйОткатТранзакции";
			КонецЕсли;
		Исключение
			ОтменитьТранзакцию();
			Если Не ИнформацияОбОшибке().Описание = "ПлановыйОткатТранзакции" Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
		УстановитьБезопасныйРежим(Ложь);
	Исключение
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Процедура - Исполнить обработку подписчика
// Создает экземпляр внешней обработки и вызывает точку входа подписчика.
// Подписчик получает Ответ и ИсходныеДанные.
//
// Параметры:
//  ИмяИлиДвоичныеДанныеEPF - Строка, ДвоичныеДанные - Имя подключённой обработки
//    или двоичные данные EPF (будут подключены автоматически).
//  Ответ                - Произвольный - Ответ от HTTP/JRPC запроса.
//  ИсходныеДанные       - Произвольный - Исходные данные сообщения.
//  РазрешитьФиксациюИзменений - Булево - Разрешить фиксацию транзакции.
//
Процедура ИсполнитьОбработкуПодписчика(Знач ИмяИлиДвоичныеДанныеEPF, Ответ, ИсходныеДанные, РазрешитьФиксациюИзменений = Ложь) Экспорт
	
	ИмяОбработки = РазрешитьИмяОбработки(ИмяИлиДвоичныеДанныеEPF);
	Обработка = ВнешниеОбработки.Создать(ИмяОбработки, Ложь);
	
	Попытка
		УстановитьБезопасныйРежим(Истина);
		НачатьТранзакцию();
		Попытка
			Обработка.ОбработатьПостПроцессинг(Ответ, ИсходныеДанные);
			
			Если РазрешитьФиксациюИзменений Тогда
				ЗафиксироватьТранзакцию();
			Иначе
				ОтменитьТранзакцию();
			КонецЕсли;
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		УстановитьБезопасныйРежим(Ложь);
	Исключение
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Функция - Сформировать модуль объекта
// Формирует текст модуля объекта внешней обработки из текста обработчика.
// Процедуры/функции из исходного кода помещаются на уровень модуля,
// остальной код оборачивается в функцию Обработать() Экспорт.
//
// Параметры:
//  ТекстОбработчика         - Строка - Исходный текст обработчика.
//  ДополнительныеПеременные - Структура, Неопределено - Дополнительные переменные модуля (для подписчиков).
//
// Возвращаемое значение:
//  Строка - Текст модуля объекта.
//
Функция СформироватьМодульОбъекта(Знач ТекстОбработчика, Знач ДополнительныеПеременные = Неопределено) Экспорт
	
	Блоки = РазобратьКодНаБлоки(ТекстОбработчика);
	
	Строки = Новый Массив;
	
	// Объявление переменных модуля.
	Строки.Добавить("Перем Результат Экспорт;");
	Строки.Добавить("Перем ИсходныеДанные;");
	
	Если ДополнительныеПеременные <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ДополнительныеПеременные Цикл
			Строки.Добавить("Перем " + КлючИЗначение.Ключ + ";");
		КонецЦикла;
	КонецЕсли;
	
	Строки.Добавить("");
	
	// Запоминаем номер строки, с которой начинаются процедуры/функции пользователя.
	// Нумерация с 1, а Строки.Количество() — это индекс следующей строки (с 0), значит + 1.
	СмещениеПроцедур = Строки.Количество() + 1;
	
	// Блоки процедур/функций пользователя.
	Для Каждого БлокПроцедуры Из Блоки.БлокиПроцедур Цикл
		Строки.Добавить(БлокПроцедуры);
		Строки.Добавить("");
	КонецЦикла;
	
	// Точка входа для потоков данных.
	Строки.Добавить("Функция Обработать(пИсходныеДанные) Экспорт");
	Строки.Добавить("	ИсходныеДанные = пИсходныеДанные;");
	Строки.Добавить("	Результат = Новый Соответствие;");
	
	Если ДополнительныеПеременные <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ДополнительныеПеременные Цикл
			Если ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
				Строки.Добавить("	" + КлючИЗначение.Ключ + " = " + КлючИЗначение.Значение + ";");
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Встраиваемый код (всё что не процедуры/функции).
	// Запоминаем смещение: номер строки в модуле, где начинается тело кода пользователя.
	Если ЗначениеЗаполнено(Блоки.ТелоКода) Тогда
		Строки.Добавить("	");
		СмещениеТелаКода = Строки.Количество() + 1; // следующая добавленная строка — первая строка тела
		// Добавляем каждую строку тела код с отступом.
		СтрокиТела = СтрРазделить(Блоки.ТелоКода, Символы.ПС);
		Для Каждого СтрокаТела Из СтрокиТела Цикл
			Строки.Добавить("	" + СтрокаТела);
		КонецЦикла;
	Иначе
		СмещениеТелаКода = 0;
	КонецЕсли;
	
	Строки.Добавить("	");
	Строки.Добавить("	Возврат Результат;");
	Строки.Добавить("КонецФункции");
	
	// Точка входа для подписчиков (если есть дополнительные переменные).
	Если ДополнительныеПеременные <> Неопределено И ДополнительныеПеременные.Свойство("Ответ") Тогда
		Строки.Добавить("");
		Строки.Добавить("Процедура ОбработатьПостПроцессинг(пОтвет, пИсходныеДанные) Экспорт");
		Строки.Добавить("	Ответ = пОтвет;");
		Строки.Добавить("	ИсходныеДанные = пИсходныеДанные;");
		Строки.Добавить("	Результат = Новый Соответствие;");
		
		Если ЗначениеЗаполнено(Блоки.ТелоКода) Тогда
			Строки.Добавить("	");
			СтрокиТела = СтрРазделить(Блоки.ТелоКода, Символы.ПС);
			Для Каждого СтрокаТела Из СтрокиТела Цикл
				Строки.Добавить("	" + СтрокаТела);
			КонецЦикла;
		КонецЕсли;
		
		Строки.Добавить("КонецПроцедуры");
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("ТекстМодуля", СтрСоединить(Строки, Символы.ПС));
	Результат.Вставить("СмещениеТелаКода", СмещениеТелаКода);
	Результат.Вставить("СмещениеПроцедур", СмещениеПроцедур);
	
	Возврат Результат;
	
КонецФункции

// Функция - Разобрать код на блоки
// Разбирает текст обработчика на блоки процедур/функций и тело кода.
//
// Параметры:
//  ТекстОбработчика - Строка - Исходный текст обработчика.
//
// Возвращаемое значение:
//  Структура:
//    * БлокиПроцедур - Массив из Строка - Тексты процедур/функций.
//    * ТелоКода      - Строка - Код, не входящий в процедуры/функции.
//
Функция РазобратьКодНаБлоки(Знач ТекстОбработчика) Экспорт
	
	БлокиПроцедур = Новый Массив;
	СтрокиТела = Новый Массив;
	
	Строки = СтрРазделить(ТекстОбработчика, Символы.ПС);
	
	ВнутриБлока = Ложь;
	ТекущийБлок = Новый Массив;
	ГлубинаВложенности = 0;
	
	Для Каждого Строка Из Строки Цикл
		
		СтрокаОбрезанная = СокрЛП(ВРег(Строка));
		
		// Пропускаем пустые строки и комментарии для анализа ключевых слов.
		ЭтоКомментарий = СтрНачинаетсяС(СтрокаОбрезанная, "//");
		
		Если Не ВнутриБлока Тогда
			// Ищем начало процедуры/функции.
			Если Не ЭтоКомментарий И ЭтоНачалоБлока(СтрокаОбрезанная) Тогда
				ВнутриБлока = Истина;
				ГлубинаВложенности = 1;
				ТекущийБлок = Новый Массив;
				ТекущийБлок.Добавить(Строка);
			Иначе
				СтрокиТела.Добавить(Строка);
			КонецЕсли;
		Иначе
			ТекущийБлок.Добавить(Строка);
			
			Если Не ЭтоКомментарий Тогда
				// Вложенные процедуры/функции (если/когда будут поддержаны),
				// а пока учитываем Если/Цикл/Попытка для корректности не нужно,
				// т.к. КонецПроцедуры/КонецФункции уникальны.
				Если ЭтоКонецБлока(СтрокаОбрезанная) Тогда
					ГлубинаВложенности = ГлубинаВложенности - 1;
					Если ГлубинаВложенности <= 0 Тогда
						БлокиПроцедур.Добавить(СтрСоединить(ТекущийБлок, Символы.ПС));
						ВнутриБлока = Ложь;
						ТекущийБлок = Новый Массив;
					КонецЕсли;
				ИначеЕсли ЭтоНачалоБлока(СтрокаОбрезанная) Тогда
					ГлубинаВложенности = ГлубинаВложенности + 1;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	// Если блок не был закрыт — добавляем как тело.
	Если ВнутриБлока И ТекущийБлок.Количество() > 0 Тогда
		Для Каждого СтрокаБлока Из ТекущийБлок Цикл
			СтрокиТела.Добавить(СтрокаБлока);
		КонецЦикла;
	КонецЕсли;
	
	// Убираем завершающие пустые строки из тела.
	Пока СтрокиТела.Количество() > 0 И ПустаяСтрока(СтрокиТела[СтрокиТела.ВГраница()]) Цикл
		СтрокиТела.Удалить(СтрокиТела.ВГраница());
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("БлокиПроцедур", БлокиПроцедур);
	Результат.Вставить("ТелоКода", СтрСоединить(СтрокиТела, Символы.ПС));
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция - Разрешить имя обработки
// Если передано имя (Строка) — возвращает как есть.
// Если переданы ДвоичныеДанные — подключает и возвращает имя.
//
Функция РазрешитьИмяОбработки(Знач ИмяИлиДвоичныеДанныеEPF)
	
	Если ТипЗнч(ИмяИлиДвоичныеДанныеEPF) = Тип("Строка") Тогда
		Возврат ИмяИлиДвоичныеДанныеEPF;
	КонецЕсли;
	
	Возврат ПодключитьОбработку(ИмяИлиДвоичныеДанныеEPF);
	
КонецФункции

// Функция - Скомпилировать EPF в памяти
// Генерирует бинарный EPF из текста модуля объекта путём редактирования
// бинарного контейнера шаблона в памяти. Не требует вызова Конфигуратора,
// создания временных файлов или баз данных.
//
// Параметры:
//  ТекстМодуляОбъекта - Строка - Полный текст модуля объекта обработки.
//
// Возвращаемое значение:
//  ДвоичныеДанные - Скомпилированная внешняя обработка (EPF).
//
Функция СкомпилироватьEPFВПамяти(Знач ТекстМодуляОбъекта)
	
	// GUID внутреннего файла модуля объекта в бинарном контейнере EPF-шаблона.
	ИдентификаторМодуляОбъекта = "00ab4620-8498-4b18-a4f8-18b53138fcb5.0";
	
	Редактор = Обработки.инт_РедакторОбработки.Создать();
	Редактор.ЗагрузитьШаблон();
	Редактор.УстановитьДанныеФайла(ИдентификаторМодуляОбъекта + "/text", ТекстМодуляОбъекта);
	
	Возврат Редактор.СформироватьОбработку();
	
КонецФункции

Функция ЭтоНачалоБлока(Знач СтрокаВерхнемРегистре)
	Возврат СтрНачинаетсяС(СтрокаВерхнемРегистре, "ПРОЦЕДУРА ")
		ИЛИ СтрНачинаетсяС(СтрокаВерхнемРегистре, "ФУНКЦИЯ ")
		ИЛИ СтрокаВерхнемРегистре = "ПРОЦЕДУРА"
		ИЛИ СтрокаВерхнемРегистре = "ФУНКЦИЯ";
КонецФункции

Функция ЭтоКонецБлока(Знач СтрокаВерхнемРегистре)
	Возврат СтрНачинаетсяС(СтрокаВерхнемРегистре, "КОНЕЦПРОЦЕДУРЫ")
		ИЛИ СтрНачинаетсяС(СтрокаВерхнемРегистре, "КОНЕЦФУНКЦИИ");
КонецФункции

#КонецОбласти

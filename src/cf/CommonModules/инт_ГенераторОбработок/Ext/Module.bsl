////////////////////////////////////////////////////////////////////////////////
// инт_ГенераторОбработок
//
// Генерация внешних обработок (EPF) из текста обработчика.
// Поддержка процедур/функций в коде обработчиков потоков данных и подписчиков.
//
// Компиляция EPF выполняется редактированием бинарного контейнера в памяти
// (без вызова Конфигуратора, создания временных файлов и баз данных)
// с использованием обработки инт_РедакторОбработки.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Функция - Скомпилировать обработку
// Генерирует внешнюю обработку (EPF) из текста обработчика.
// Текст парсится: процедуры/функции остаются на уровне модуля,
// остальной код оборачивается в экспортную функцию Обработать().
//
// Параметры:
//  ТекстОбработчика     - Строка - Исходный текст обработчика из редактора кода.
//  ДополнительныеПеременные - Структура, Неопределено - Дополнительные переменные модуля.
//    Ключ - имя переменной, значение - начальное значение (Строка) или пустая строка.
//    Например: Новый Структура("Ответ", "") — добавит "Перем Ответ Экспорт;" в модуль.
//  ХешТекста            - Строка - Необязательный. Предварительно вычисленный хеш текста обработчика.
//    Если не указан — вычисляется автоматически.
//  СмещенияМодуля       - Неопределено, Структура - Выходной параметр. Если передана переменная,
//    заполняется структурой с ключами "СмещениеТелаКода", "СмещениеПроцедур" для пересчёта
//    номеров строк ошибок из сгенерированного модуля в строки исходного кода.
//
// Возвращаемое значение:
//  ДвоичныеДанные - Скомпилированная внешняя обработка (EPF).
//
Функция СкомпилироватьОбработку(Знач ТекстОбработчика, Знач ДополнительныеПеременные = Неопределено, Знач ХешТекста = "", СмещенияМодуля = Неопределено) Экспорт
	
	РезультатГенерации = СформироватьМодульОбъекта(ТекстОбработчика, ДополнительныеПеременные);
	МодульОбъекта = РезультатГенерации.ТекстМодуля;
	СмещениеТела = РезультатГенерации.СмещениеТелаКода;
	СмещениеПроцедур = РезультатГенерации.СмещениеПроцедур;
	
	СмещенияМодуля = Новый Структура("СмещениеТелаКода, СмещениеПроцедур", СмещениеТела, СмещениеПроцедур);
	
	// Компилируем EPF редактированием бинарного контейнера в памяти
	// (без вызова Конфигуратора и без создания временных файлов/баз).
	Результат = СкомпилироватьEPFВПамяти(МодульОбъекта);
	
	// Помещаем скомпилированный EPF в файловый кэш.
	ПоместитьВКэш(Результат);
	
	Возврат Результат;
	
КонецФункции

// Функция - Хеш текста обработчика
// Вычисляет MD5-хеш текста для определения необходимости перекомпиляции.
//
// Параметры:
//  ТекстОбработчика - Строка - Текст обработчика.
//
// Возвращаемое значение:
//  Строка - MD5-хеш текста в HEX-представлении.
//
Функция ХешТекстаОбработчика(Знач ТекстОбработчика) Экспорт
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеширование.Добавить(ТекстОбработчика);
	
	Возврат СтрЗаменить(Хеширование.ХешСумма, " ", "");
	
КонецФункции

// Функция - Каталог кэша объекта
// Возвращает путь к подкаталогу кэша для конкретного объекта (потока/подписчика).
// Используется для организации EPF-файлов по GUID объектов:
//   {корень кэша}/{ИдОбъекта}/
//
// Параметры:
//  ИдОбъекта - Строка - Уникальный идентификатор объекта (GUID).
//
// Возвращаемое значение:
//  Строка - Полный путь к каталогу кэша объекта (с завершающим разделителем).
//
Функция КаталогКэшаОбъекта(Знач ИдОбъекта) Экспорт
	
	Каталог = инт_ГенераторОбработокПовтИсп.КорневойКаталогКэша() + ИдОбъекта + ПолучитьРазделительПути();
	
	КаталогФайл = Новый Файл(Каталог);
	Если Не КаталогФайл.Существует() Тогда
		СоздатьКаталог(Каталог);
	КонецЕсли;
	
	Возврат Каталог;
	
КонецФункции

// Функция - Путь EPF в кэше объекта
// Вычисляет ожидаемый путь к файлу EPF по тексту обработчика и GUID объекта.
// Не создаёт файл, не проверяет его наличие — только формирует путь.
//
// Параметры:
//  ТекстОбработчика - Строка - Текст обработчика.
//  ИдОбъекта        - Строка - GUID объекта (потока/подписчика).
//
// Возвращаемое значение:
//  Строка - Полный ожидаемый путь к EPF-файлу.
//
Функция ПутьEPFВКэше(Знач ТекстОбработчика, Знач ИдОбъекта) Экспорт
	
	ХешТекста = ХешТекстаОбработчика(ТекстОбработчика);
	КаталогОбъекта = КаталогКэшаОбъекта(ИдОбъекта);
	
	Возврат КаталогОбъекта + ХешТекста + ".epf";
	
КонецФункции

// Функция - Разрешить EPF по кэшу
// Трёхуровневый кэш: диск → двоичные данные из БД → компиляция из текста.
// Гарантирует наличие файла EPF на диске и возвращает путь к нему.
//
// Параметры:
//  ТекстОбработчика        - Строка - Исходный текст обработчика.
//  ИдОбъекта               - Строка - GUID объекта (потока/подписчика).
//  ДвоичныеДанныеИзБД      - ДвоичныеДанные, Неопределено - Предкомпилированный EPF из базы.
//  ДополнительныеПеременные - Структура, Неопределено - Переменные для компиляции (Ответ, ИсходныеДанные и т.п.).
//  Представление            - Произвольный - Объект для колонки «Данные» журнала регистрации.
//
// Возвращаемое значение:
//  Строка - Полный путь к EPF-файлу на диске.
//
Функция РазрешитьEPFПоКэшу(Знач ТекстОбработчика, Знач ИдОбъекта,
	Знач ДвоичныеДанныеИзБД = Неопределено,
	Знач ДополнительныеПеременные = Неопределено,
	Представление = Неопределено) Экспорт
	
	ПутьКФайлу = ПутьEPFВКэше(ТекстОбработчика, ИдОбъекта);
	
	// 1. Кэш-попадание: файл уже на диске.
	Файл = Новый Файл(ПутьКФайлу);
	Если Файл.Существует() Тогда
		ЗаписатьТрейсКэша("Кэш-попадание (диск)", ПутьКФайлу, Представление);
		Возврат ПутьКФайлу;
	КонецЕсли;
	
	// 2. Кэш-промах: записываем предкомпилированный EPF из БД.
	Если ДвоичныеДанныеИзБД <> Неопределено Тогда
		ДвоичныеДанныеИзБД.Записать(ПутьКФайлу);
		ЗаписатьТрейсКэша("Кэш-промах (диск). Записан из БД", ПутьКФайлу, Представление);
		Возврат ПутьКФайлу;
	КонецЕсли;
	
	// 3. Полный промах: компилируем заново из текста.
	ДвоичныеДанные = СкомпилироватьОбработку(ТекстОбработчика, ДополнительныеПеременные);
	ДвоичныеДанные.Записать(ПутьКФайлу);
	ЗаписатьТрейсКэша("Кэш-промах (диск+БД). Скомпилирован заново", ПутьКФайлу, Представление, Истина);
	
	Возврат ПутьКФайлу;
	
КонецФункции

// Функция - Обеспечить EPF на диске
// Гарантирует наличие файла EPF в каталоге кэша объекта.
// Если файл уже существует — возвращает путь без записи.
//
// Параметры:
//  ДвоичныеДанныеEPF - ДвоичныеДанные - Скомпилированная внешняя обработка.
//  ИдОбъекта         - Строка - GUID объекта (потока/подписчика).
//  ХешТекста         - Строка - MD5-хеш текста обработчика.
//
// Возвращаемое значение:
//  Строка - Полный путь к EPF-файлу в кэше объекта.
//
Функция ОбеспечитьEPFНаДиске(Знач ДвоичныеДанныеEPF, Знач ИдОбъекта, Знач ХешТекста) Экспорт
	
	КаталогОбъекта = КаталогКэшаОбъекта(ИдОбъекта);
	ПутьКФайлу = КаталогОбъекта + ХешТекста + ".epf";
	
	Файл = Новый Файл(ПутьКФайлу);
	Если Файл.Существует() Тогда
		ЗаписатьТрейсКэша("ОбеспечитьEPFНаДиске: уже существует", ПутьКФайлу);
	Иначе
		ДвоичныеДанныеEPF.Записать(ПутьКФайлу);
		ЗаписатьТрейсКэша("ОбеспечитьEPFНаДиске: записан новый файл", ПутьКФайлу);
	КонецЕсли;
	
	Возврат ПутьКФайлу;
	
КонецФункции

// Функция - Исполнить обработку
// Создает экземпляр внешней обработки из двоичных данных или по пути к файлу
// и вызывает точку входа. Используется для потоков данных.
// EPF кэшируется на диске по хешу содержимого.
//
// Параметры:
//  ДвоичныеДанныеИлиПутьEPF - ДвоичныеДанные, Строка - Скомпилированная внешняя обработка
//    или полный путь к EPF-файлу на диске.
//  ИсходныеДанные       - Произвольный - Данные для обработки (ссылка на объект или соответствие).
//  РазрешитьФиксациюИзменений - Булево - Разрешить фиксацию транзакции.
//
// Возвращаемое значение:
//  Соответствие - Результат выполнения обработчика.
//
Функция ИсполнитьОбработку(Знач ДвоичныеДанныеИлиПутьEPF, ИсходныеДанные, РазрешитьФиксациюИзменений = Ложь) Экспорт
	
	Если ТипЗнч(ДвоичныеДанныеИлиПутьEPF) = Тип("Строка") Тогда
		ИмяФайла = ДвоичныеДанныеИлиПутьEPF;
	Иначе
		ИмяФайла = ПолучитьФайлИзКэша(ДвоичныеДанныеИлиПутьEPF);
	КонецЕсли;
	
	// Создаём экземпляр обработки ДО установки безопасного режима,
	// т.к. ВнешниеОбработки.Создать() требует полных привилегий.
	Обработка = ВнешниеОбработки.Создать(ИмяФайла, Ложь);
	
	Попытка
		УстановитьБезопасныйРежим(Истина);
		НачатьТранзакцию();
		Попытка
			Результат = Обработка.Обработать(ИсходныеДанные);
			
			Если РазрешитьФиксациюИзменений Тогда
				ЗафиксироватьТранзакцию();
			Иначе
				ВызватьИсключение "ПлановыйОткатТранзакции";
			КонецЕсли;
		Исключение
			ОтменитьТранзакцию();
			Если Не ИнформацияОбОшибке().Описание = "ПлановыйОткатТранзакции" Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
		УстановитьБезопасныйРежим(Ложь);
	Исключение
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Функция - Исполнить обработку подписчика
// Создает экземпляр внешней обработки из двоичных данных или по пути к файлу
// и вызывает точку входа подписчика.
// Подписчик получает Ответ и ИсходныеДанные. EPF кэшируется на диске по хешу содержимого.
//
// Параметры:
//  ДвоичныеДанныеИлиПутьEPF - ДвоичныеДанные, Строка - Скомпилированная внешняя обработка
//    или полный путь к EPF-файлу на диске.
//  Ответ                - Произвольный - Ответ от HTTP/JRPC запроса.
//  ИсходныеДанные       - Произвольный - Исходные данные сообщения.
//  РазрешитьФиксациюИзменений - Булево - Разрешить фиксацию транзакции.
//
Процедура ИсполнитьОбработкуПодписчика(Знач ДвоичныеДанныеИлиПутьEPF, Ответ, ИсходныеДанные, РазрешитьФиксациюИзменений = Ложь) Экспорт
	
	Если ТипЗнч(ДвоичныеДанныеИлиПутьEPF) = Тип("Строка") Тогда
		ИмяФайла = ДвоичныеДанныеИлиПутьEPF;
	Иначе
		ИмяФайла = ПолучитьФайлИзКэша(ДвоичныеДанныеИлиПутьEPF);
	КонецЕсли;
	
	// Создаём экземпляр обработки ДО установки безопасного режима,
	// т.к. ВнешниеОбработки.Создать() требует полных привилегий.
	Обработка = ВнешниеОбработки.Создать(ИмяФайла, Ложь);
	
	Попытка
		УстановитьБезопасныйРежим(Истина);
		НачатьТранзакцию();
		Попытка
			Обработка.ОбработатьПостПроцессинг(Ответ, ИсходныеДанные);
			
			Если РазрешитьФиксациюИзменений Тогда
				ЗафиксироватьТранзакцию();
			Иначе
				ОтменитьТранзакцию();
			КонецЕсли;
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		УстановитьБезопасныйРежим(Ложь);
	Исключение
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Функция - Сформировать модуль объекта
// Формирует текст модуля объекта внешней обработки из текста обработчика.
// Процедуры/функции из исходного кода помещаются на уровень модуля,
// остальной код оборачивается в функцию Обработать() Экспорт.
//
// Параметры:
//  ТекстОбработчика         - Строка - Исходный текст обработчика.
//  ДополнительныеПеременные - Структура, Неопределено - Дополнительные переменные модуля (для подписчиков).
//
// Возвращаемое значение:
//  Строка - Текст модуля объекта.
//
Функция СформироватьМодульОбъекта(Знач ТекстОбработчика, Знач ДополнительныеПеременные = Неопределено) Экспорт
	
	Блоки = РазобратьКодНаБлоки(ТекстОбработчика);
	
	Строки = Новый Массив;
	
	// Объявление переменных модуля.
	Строки.Добавить("Перем Результат Экспорт;");
	Строки.Добавить("Перем ИсходныеДанные;");
	
	Если ДополнительныеПеременные <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ДополнительныеПеременные Цикл
			Строки.Добавить("Перем " + КлючИЗначение.Ключ + ";");
		КонецЦикла;
	КонецЕсли;
	
	Строки.Добавить("");
	
	// Запоминаем номер строки, с которой начинаются процедуры/функции пользователя.
	// Нумерация с 1, а Строки.Количество() — это индекс следующей строки (с 0), значит + 1.
	СмещениеПроцедур = Строки.Количество() + 1;
	
	// Блоки процедур/функций пользователя.
	Для Каждого БлокПроцедуры Из Блоки.БлокиПроцедур Цикл
		Строки.Добавить(БлокПроцедуры);
		Строки.Добавить("");
	КонецЦикла;
	
	// Точка входа для потоков данных.
	Строки.Добавить("Функция Обработать(пИсходныеДанные) Экспорт");
	Строки.Добавить("	ИсходныеДанные = пИсходныеДанные;");
	Строки.Добавить("	Результат = Новый Соответствие;");
	
	Если ДополнительныеПеременные <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ДополнительныеПеременные Цикл
			Если ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
				Строки.Добавить("	" + КлючИЗначение.Ключ + " = " + КлючИЗначение.Значение + ";");
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Встраиваемый код (всё что не процедуры/функции).
	// Запоминаем смещение: номер строки в модуле, где начинается тело кода пользователя.
	Если ЗначениеЗаполнено(Блоки.ТелоКода) Тогда
		Строки.Добавить("	");
		СмещениеТелаКода = Строки.Количество() + 1; // следующая добавленная строка — первая строка тела
		// Добавляем каждую строку тела код с отступом.
		СтрокиТела = СтрРазделить(Блоки.ТелоКода, Символы.ПС);
		Для Каждого СтрокаТела Из СтрокиТела Цикл
			Строки.Добавить("	" + СтрокаТела);
		КонецЦикла;
	Иначе
		СмещениеТелаКода = 0;
	КонецЕсли;
	
	Строки.Добавить("	");
	Строки.Добавить("	Возврат Результат;");
	Строки.Добавить("КонецФункции");
	
	// Точка входа для подписчиков (если есть дополнительные переменные).
	Если ДополнительныеПеременные <> Неопределено И ДополнительныеПеременные.Свойство("Ответ") Тогда
		Строки.Добавить("");
		Строки.Добавить("Процедура ОбработатьПостПроцессинг(пОтвет, пИсходныеДанные) Экспорт");
		Строки.Добавить("	Ответ = пОтвет;");
		Строки.Добавить("	ИсходныеДанные = пИсходныеДанные;");
		Строки.Добавить("	Результат = Новый Соответствие;");
		
		Если ЗначениеЗаполнено(Блоки.ТелоКода) Тогда
			Строки.Добавить("	");
			СтрокиТела = СтрРазделить(Блоки.ТелоКода, Символы.ПС);
			Для Каждого СтрокаТела Из СтрокиТела Цикл
				Строки.Добавить("	" + СтрокаТела);
			КонецЦикла;
		КонецЕсли;
		
		Строки.Добавить("КонецПроцедуры");
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("ТекстМодуля", СтрСоединить(Строки, Символы.ПС));
	Результат.Вставить("СмещениеТелаКода", СмещениеТелаКода);
	Результат.Вставить("СмещениеПроцедур", СмещениеПроцедур);
	
	Возврат Результат;
	
КонецФункции

// Функция - Разобрать код на блоки
// Разбирает текст обработчика на блоки процедур/функций и тело кода.
//
// Параметры:
//  ТекстОбработчика - Строка - Исходный текст обработчика.
//
// Возвращаемое значение:
//  Структура:
//    * БлокиПроцедур - Массив из Строка - Тексты процедур/функций.
//    * ТелоКода      - Строка - Код, не входящий в процедуры/функции.
//
Функция РазобратьКодНаБлоки(Знач ТекстОбработчика) Экспорт
	
	БлокиПроцедур = Новый Массив;
	СтрокиТела = Новый Массив;
	
	Строки = СтрРазделить(ТекстОбработчика, Символы.ПС);
	
	ВнутриБлока = Ложь;
	ТекущийБлок = Новый Массив;
	ГлубинаВложенности = 0;
	
	Для Каждого Строка Из Строки Цикл
		
		СтрокаОбрезанная = СокрЛП(ВРег(Строка));
		
		// Пропускаем пустые строки и комментарии для анализа ключевых слов.
		ЭтоКомментарий = СтрНачинаетсяС(СтрокаОбрезанная, "//");
		
		Если Не ВнутриБлока Тогда
			// Ищем начало процедуры/функции.
			Если Не ЭтоКомментарий И ЭтоНачалоБлока(СтрокаОбрезанная) Тогда
				ВнутриБлока = Истина;
				ГлубинаВложенности = 1;
				ТекущийБлок = Новый Массив;
				ТекущийБлок.Добавить(Строка);
			Иначе
				СтрокиТела.Добавить(Строка);
			КонецЕсли;
		Иначе
			ТекущийБлок.Добавить(Строка);
			
			Если Не ЭтоКомментарий Тогда
				// Вложенные процедуры/функции (если/когда будут поддержаны),
				// а пока учитываем Если/Цикл/Попытка для корректности не нужно,
				// т.к. КонецПроцедуры/КонецФункции уникальны.
				Если ЭтоКонецБлока(СтрокаОбрезанная) Тогда
					ГлубинаВложенности = ГлубинаВложенности - 1;
					Если ГлубинаВложенности <= 0 Тогда
						БлокиПроцедур.Добавить(СтрСоединить(ТекущийБлок, Символы.ПС));
						ВнутриБлока = Ложь;
						ТекущийБлок = Новый Массив;
					КонецЕсли;
				ИначеЕсли ЭтоНачалоБлока(СтрокаОбрезанная) Тогда
					ГлубинаВложенности = ГлубинаВложенности + 1;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	// Если блок не был закрыт — добавляем как тело.
	Если ВнутриБлока И ТекущийБлок.Количество() > 0 Тогда
		Для Каждого СтрокаБлока Из ТекущийБлок Цикл
			СтрокиТела.Добавить(СтрокаБлока);
		КонецЦикла;
	КонецЕсли;
	
	// Убираем завершающие пустые строки из тела.
	Пока СтрокиТела.Количество() > 0 И ПустаяСтрока(СтрокиТела[СтрокиТела.ВГраница()]) Цикл
		СтрокиТела.Удалить(СтрокиТела.ВГраница());
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("БлокиПроцедур", БлокиПроцедур);
	Результат.Вставить("ТелоКода", СтрСоединить(СтрокиТела, Символы.ПС));
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция - Скомпилировать EPF в памяти
// Генерирует бинарный EPF из текста модуля объекта путём редактирования
// бинарного контейнера шаблона в памяти. Не требует вызова Конфигуратора,
// создания временных файлов или баз данных.
//
// Параметры:
//  ТекстМодуляОбъекта - Строка - Полный текст модуля объекта обработки.
//
// Возвращаемое значение:
//  ДвоичныеДанные - Скомпилированная внешняя обработка (EPF).
//
Функция СкомпилироватьEPFВПамяти(Знач ТекстМодуляОбъекта)
	
	// GUID внутреннего файла модуля объекта в бинарном контейнере EPF-шаблона.
	ИдентификаторМодуляОбъекта = "00ab4620-8498-4b18-a4f8-18b53138fcb5.0";
	
	Редактор = Обработки.инт_РедакторОбработки.Создать();
	Редактор.ЗагрузитьШаблон();
	Редактор.УстановитьДанныеФайла(ИдентификаторМодуляОбъекта + "/text", ТекстМодуляОбъекта);
	
	Возврат Редактор.СформироватьОбработку();
	
КонецФункции

// Процедура - Записать трейс кэша EPF
// Единая точка логирования операций файлового кэша EPF.
//
// Параметры:
//  Сообщение     - Строка - Текстовое описание события (без пути).
//  Путь          - Строка - Полный путь к файлу EPF.
//  Представление - Произвольный, Неопределено - Объект для колонки «Данные» журнала регистрации.
//  Предупреждение - Булево - Истина → УровеньЖурналаРегистрации.Предупреждение, иначе Примечание.
//
Процедура ЗаписатьТрейсКэша(Знач Сообщение, Знач Путь, Представление = Неопределено, Знач Предупреждение = Ложь)
	
	Уровень = ?(Предупреждение,
		УровеньЖурналаРегистрации.Предупреждение,
		УровеньЖурналаРегистрации.Примечание);
	
	ЗаписьЖурналаРегистрации("ПодсистемаИнтеграции.КэшEPF",
		Уровень, , Представление,
		СтрШаблон("%1: %2", Сообщение, Путь));
	
КонецПроцедуры

Функция ЭтоНачалоБлока(Знач СтрокаВерхнемРегистре)
	Возврат СтрНачинаетсяС(СтрокаВерхнемРегистре, "ПРОЦЕДУРА ")
		ИЛИ СтрНачинаетсяС(СтрокаВерхнемРегистре, "ФУНКЦИЯ ")
		ИЛИ СтрокаВерхнемРегистре = "ПРОЦЕДУРА"
		ИЛИ СтрокаВерхнемРегистре = "ФУНКЦИЯ";
КонецФункции

Функция ЭтоКонецБлока(Знач СтрокаВерхнемРегистре)
	Возврат СтрНачинаетсяС(СтрокаВерхнемРегистре, "КОНЕЦПРОЦЕДУРЫ")
		ИЛИ СтрНачинаетсяС(СтрокаВерхнемРегистре, "КОНЕЦФУНКЦИИ");
КонецФункции

// Функция - Получить файл из кэша
// Проверяет наличие EPF-файла в файловом кэше по хешу двоичных данных.
// Если файл отсутствует — записывает его в кэш. Возвращает путь к файлу.
//
// Параметры:
//  ДвоичныеДанныеEPF - ДвоичныеДанные - Скомпилированная внешняя обработка.
//
// Возвращаемое значение:
//  Строка - Полный путь к EPF-файлу в кэше.
//
Функция ПолучитьФайлИзКэша(Знач ДвоичныеДанныеEPF)
	
	Хеш = ХешДвоичныхДанных(ДвоичныеДанныеEPF);
	Каталог = КаталогКэшаEPF();
	ПутьКФайлу = Каталог + Хеш + ".epf";
	
	Файл = Новый Файл(ПутьКФайлу);
	Если Не Файл.Существует() Тогда
		ДвоичныеДанныеEPF.Записать(ПутьКФайлу);
	КонецЕсли;
	
	Возврат ПутьКФайлу;
	
КонецФункции

// Процедура - Поместить в кэш
// Записывает скомпилированный EPF-файл в файловый кэш, используя хеш как имя файла.
//
// Параметры:
//  ДвоичныеДанныеEPF - ДвоичныеДанные - Скомпилированная внешняя обработка.
//
Процедура ПоместитьВКэш(Знач ДвоичныеДанныеEPF)
	
	Хеш = ХешДвоичныхДанных(ДвоичныеДанныеEPF);
	Каталог = КаталогКэшаEPF();
	ПутьКФайлу = Каталог + Хеш + ".epf";
	
	Файл = Новый Файл(ПутьКФайлу);
	Если Не Файл.Существует() Тогда
		ДвоичныеДанныеEPF.Записать(ПутьКФайлу);
	КонецЕсли;
	
КонецПроцедуры

// Функция - Каталог кэша EPF
// Возвращает путь к каталогу файлового кэша EPF. Создаёт каталог при первом обращении.
//
// Возвращаемое значение:
//  Строка - Путь к каталогу кэша (с завершающим разделителем пути).
//
Функция КаталогКэшаEPF()
	
	Возврат инт_ГенераторОбработокПовтИсп.КорневойКаталогКэша();
	
КонецФункции

// Функция - Хеш двоичных данных
// Вычисляет MD5-хеш двоичных данных для использования в качестве ключа кэша.
//
// Параметры:
//  ДвоичныеДанные - ДвоичныеДанные - Данные для хеширования.
//
// Возвращаемое значение:
//  Строка - MD5-хеш в HEX-представлении (без пробелов).
//
Функция ХешДвоичныхДанных(Знач ДвоичныеДанные)
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеширование.Добавить(ДвоичныеДанные);
	
	Возврат СтрЗаменить(Хеширование.ХешСумма, " ", "");
	
КонецФункции

#КонецОбласти

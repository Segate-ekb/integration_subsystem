////////////////////////////////////////////////////////////////////////////////
// инт_МенеджерВходящихПотоков
//
// Модуль управления консьюмерами для входящих потоков данных.
// Запускается регламентным заданием, мониторит и перезапускает консьюмеры.
//
// Архитектура:
// - Один консьюмер на группу подписок одного эндпоинта (Kafka брокера)
// - Режим обработки (асинх/синх) определяется настройкой потока данных
// - Валидация и маршрутизация выполняются в инт_КонсьюмерОчередей
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Точка входа регламентного задания.
// Запускает консьюмеры для всех активных входящих потоков.
//
Процедура ЗапуститьКонсьюмерыАсинхронныхПодписок() Экспорт
	
	// Проверяем глобальный флаг graceful stop
	Если РежимGracefulStop() Тогда
		Возврат;
	КонецЕсли;
	
	// Получаем все активные входящие потоки с подписками
	МассивПодписок = ПолучитьАктивныеПодписки();
	
	Если МассивПодписок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Группируем подписки по эндпоинтам
	ПодпискиПоЭндпоинтам = СгруппироватьПодпискиПоЭндпоинтам(МассивПодписок);
	
	// Запускаем консьюмер для каждой группы эндпоинтов
	Для Каждого КлючЗначение Из ПодпискиПоЭндпоинтам Цикл
		ОбработатьПодпискиЭндпоинта(КлючЗначение.Значение);
	КонецЦикла;
	
	// Очищаем записи об остановленных заданиях
	ОчиститьНеактивныеЗаписи();
	
КонецПроцедуры

// Принудительно останавливает все консьюмеры.
//
Процедура ОстановитьВсеКонсьюмеры() Экспорт
	
	АктивныеКонсьюмеры = РегистрыСведений.инт_АктивныеКонсьюмеры.ПолучитьАктивныеКонсьюмеры();
	
	Для Каждого Запись Из АктивныеКонсьюмеры Цикл
		Попытка
			Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Запись.ИдентификаторФоновогоЗадания);
			Если Задание <> Неопределено И Задание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
				Задание.Отменить();
			КонецЕсли;
		Исключение
			// Задание могло завершиться самостоятельно
		КонецПопытки;
		
		РегистрыСведений.инт_АктивныеКонсьюмеры.УдалитьКонсьюмер(
			Запись.Подписка, 
			Запись.ИдентификаторФоновогоЗадания);
	КонецЦикла;
	
КонецПроцедуры

// Переводит подписку в режим drain.
// Консьюмер, читающий топик этой подписки, будет остановлен и перезапущен без неё.
// Для восстановления используйте ВосстановитьПодписку().
//
// Параметры:
//  Подписка - ОпределяемыйТип.инт_Подписка - Ссылка на подписчика Kafka/RabbitMQ
//
Процедура DrainПодписку(Подписка) Экспорт
	
	РегистрыСведений.инт_АктивныеКонсьюмеры.УстановитьСтатусDrained(Подписка);
	
	ЗаписьЖурналаРегистрации(
		"ПодсистемаИнтеграции.МенеджерВходящихПотоков",
		УровеньЖурналаРегистрации.Информация,
		,
		Подписка,
		"Подписка переведена в режим Drain");
	
КонецПроцедуры

// Восстанавливает подписку после drain. При следующем тике менеджера
// подписка будет включена обратно в консьюмер-группу.
//
// Параметры:
//  Подписка - ОпределяемыйТип.инт_Подписка - Ссылка на подписчика Kafka/RabbitMQ
//
Процедура ВосстановитьПодписку(Подписка) Экспорт
	
	РегистрыСведений.инт_АктивныеКонсьюмеры.СнятьСтатусDrained(Подписка);
	
	ЗаписьЖурналаРегистрации(
		"ПодсистемаИнтеграции.МенеджерВходящихПотоков",
		УровеньЖурналаРегистрации.Информация,
		,
		Подписка,
		"Подписка восстановлена после Drain");
	
КонецПроцедуры

// Получает список остановленных (drained) подписок.
//
// Возвращаемое значение:
//  Массив из Структура - Список drained подписок:
//   * Подписка  - ОпределяемыйТип.инт_Подписка - Ссылка на подписку
//   * ДатаDrain - Дата - Время установки статуса Drained
//
Функция ПолучитьОстановленныеПодписки() Экспорт
	
	Возврат РегистрыСведений.инт_АктивныеКонсьюмеры.ПолучитьDrainedПодписки();
	
КонецФункции

// Грейсфул-стоп всех консьюмеров.
// Все активные консьюмеры корректно завершат работу при следующем poll-е,
// новые консьюмеры не будут запускаться.
// Для возобновления используйте ВозобновитьВсеКонсьюмеры().
//
Процедура ГрейсфулСтопВсехКонсьюмеров() Экспорт
	
	// Устанавливаем глобальный флаг — менеджер не будет запускать новые консьюмеры
	Константы.инт_ОстановитьВсеКонсьюмеры.Установить(Истина);
	
	// Сигнализируем всем активным консьюмерам через регистр
	РегистрыСведений.инт_АктивныеКонсьюмеры.УстановитьГрейсфулСтоп();
	
	ЗаписьЖурналаРегистрации(
		"ПодсистемаИнтеграции.МенеджерВходящихПотоков",
		УровеньЖурналаРегистрации.Информация,
		,
		,
		"Запущен graceful stop всех консьюмеров");
	
КонецПроцедуры

// Возобновляет работу всех консьюмеров после graceful stop.
// Сбрасывает глобальный флаг и очищает статусы GracefulStop.
//
Процедура ВозобновитьВсеКонсьюмеры() Экспорт
	
	// Сбрасываем глобальный флаг
	Константы.инт_ОстановитьВсеКонсьюмеры.Установить(Ложь);
	
	// Очищаем статусы GracefulStop
	РегистрыСведений.инт_АктивныеКонсьюмеры.ОчиститьGracefulStop();
	
	ЗаписьЖурналаРегистрации(
		"ПодсистемаИнтеграции.МенеджерВходящихПотоков",
		УровеньЖурналаРегистрации.Информация,
		,
		,
		"Консьюмеры возобновлены после graceful stop");
	
КонецПроцедуры

// Проверяет, активен ли режим graceful stop.
//
// Возвращаемое значение:
//  Булево - Истина, если graceful stop активен
//
Функция РежимGracefulStop() Экспорт
	
	Возврат Константы.инт_ОстановитьВсеКонсьюмеры.Получить();
	
КонецФункции

// Останавливает консьюмеры для указанной подписки.
//
// Параметры:
//  Подписка - ОпределяемыйТип.инт_Подписка - Ссылка на подписчика Kafka/RabbitMQ
//
Процедура ОстановитьКонсьюмерыПодписки(Подписка) Экспорт
	
	АктивныеКонсьюмеры = РегистрыСведений.инт_АктивныеКонсьюмеры.ПолучитьАктивныеКонсьюмеры(Подписка);
	
	Для Каждого Запись Из АктивныеКонсьюмеры Цикл
		Попытка
			Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Запись.ИдентификаторФоновогоЗадания);
			Если Задание <> Неопределено И Задание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
				Задание.Отменить();
			КонецЕсли;
		Исключение
			// Задание могло завершиться самостоятельно
		КонецПопытки;
		
		РегистрыСведений.инт_АктивныеКонсьюмеры.УдалитьКонсьюмер(
			Запись.Подписка, 
			Запись.ИдентификаторФоновогоЗадания);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает все активные подписки для входящих потоков.
//
// Возвращаемое значение:
//  Массив из Структура:
//   * ПотокДанных - СправочникСсылка.инт_ПотокиДанных
//   * Подписка    - СправочникСсылка.инт_ПодписчикиKafka
//
Функция ПолучитьАктивныеПодписки()
	
	Результат = Новый Массив;
	
	// Получаем список drained подписок для исключения
	DrainedПодписки = РегистрыСведений.инт_АктивныеКонсьюмеры.ПолучитьDrainedПодписки();
	DrainedСсылки = Новый Массив;
	Для Каждого Элемент Из DrainedПодписки Цикл
		DrainedСсылки.Добавить(Элемент.Подписка);
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ПотокиДанных.Ссылка КАК ПотокДанных,
		|	ПодпискиТЧ.Подписка КАК Подписка
		|ИЗ
		|	Справочник.инт_ПотокиДанных КАК ПотокиДанных
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.инт_ПотокиДанных.ПодпискиНаВходящиеСообщения КАК ПодпискиТЧ
		|		ПО ПотокиДанных.Ссылка = ПодпискиТЧ.Ссылка
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.инт_ПодписчикиKafka КАК ПодписчикиKafka
		|		ПО ПодпискиТЧ.Подписка = ПодписчикиKafka.Ссылка
		|ГДЕ
		|	ПотокиДанных.Активен = ИСТИНА
		|	И ПотокиДанных.НаправлениеПотока = ЗНАЧЕНИЕ(Перечисление.инт_НаправлениеПотокаДанных.Входящий)
		|	И ПодписчикиKafka.Активен = ИСТИНА";
	
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		// Исключаем drained подписки
		Если DrainedСсылки.Найти(Выборка.Подписка) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаПодписки = Новый Структура("ПотокДанных, Подписка");
		ЗаполнитьЗначенияСвойств(СтрокаПодписки, Выборка);
		Результат.Добавить(СтрокаПодписки);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Обрабатывает подписки одного эндпоинта — запускает консьюмер, если его нет.
//
// Параметры:
//  МассивПодписок - Массив из Структура - Подписки одного эндпоинта
//
Процедура ОбработатьПодпискиЭндпоинта(МассивПодписок)
	
	Если МассивПодписок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Проверяем наличие активного консьюмера
	// Используем первую подписку как идентификатор группы
	ПерваяПодписка = МассивПодписок[0].Подписка;
	АктивныеКонсьюмеры = РегистрыСведений.инт_АктивныеКонсьюмеры.ПолучитьАктивныеКонсьюмеры(ПерваяПодписка);
	
	Для Каждого Запись Из АктивныеКонсьюмеры Цикл
		Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Запись.ИдентификаторФоновогоЗадания);
		Если Задание <> Неопределено И Задание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			// Консьюмер активен, выходим
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
	// Запускаем консьюмер
	ЗапуститьКонсьюмер(МассивПодписок);
	
КонецПроцедуры

// Проверяет наличие активного фонового задания для консьюмера.
//
// Возвращаемое значение:
//  Булево - Истина, если есть активное задание
//
Функция ЕстьАктивноеЗаданиеКонсьюмера()
	
	АктивныеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(
		Новый Структура("ИмяМетода, Состояние", 
			"инт_КонсьюмерОчередей.ЧитатьСообщения",
			СостояниеФоновогоЗадания.Активно));
	
	Возврат АктивныеЗадания.Количество() > 0;
	
КонецФункции

// Группирует подписки по эндпоинтам Kafka.
//
// Параметры:
//  МассивПодписок - Массив из Структура - Подписки для группировки
//
// Возвращаемое значение:
//  Соответствие - Ключ: СправочникСсылка.инт_Эндпоинты, Значение: Массив подписок
//
Функция СгруппироватьПодпискиПоЭндпоинтам(МассивПодписок)
	
	Результат = Новый Соответствие;
	
	Для Каждого СтрокаПодписки Из МассивПодписок Цикл
		// Получаем эндпоинт подписчика
		Эндпоинт = СтрокаПодписки.Подписка.Эндпоинт;
		
		Если Результат.Получить(Эндпоинт) = Неопределено Тогда
			Результат.Вставить(Эндпоинт, Новый Массив);
		КонецЕсли;
		
		Результат.Получить(Эндпоинт).Добавить(СтрокаПодписки);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Запускает консьюмер для группы подписок.
//
// Параметры:
//  МассивПодписок - Массив из Структура - Подписки одного эндпоинта
//
Процедура ЗапуститьКонсьюмер(МассивПодписок)
	
	Если МассивПодписок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Формируем параметры для ФЗ
	ПараметрыЗадания = Новый Массив;
	ПараметрыЗадания.Добавить(МассивПодписок);
	
	// Запускаем ФЗ
	Задание = ФоновыеЗадания.Выполнить(
		"инт_КонсьюмерОчередей.ЧитатьСообщения",
		ПараметрыЗадания,
		,
		"Консьюмер входящих сообщений");
	
	// Регистрируем консьюмер в регистре (используем первую подписку как идентификатор группы)
	РегистрыСведений.инт_АктивныеКонсьюмеры.ЗарегистрироватьКонсьюмер(
		МассивПодписок[0].Подписка,
		Задание.УникальныйИдентификатор,
		"Kafka");
	
КонецПроцедуры

// Очищает записи о неактивных фоновых заданиях.
// Не удаляет записи со статусом Drained — они должны сохраняться до явного восстановления.
//
Процедура ОчиститьНеактивныеЗаписи()
	
	АктивныеКонсьюмеры = РегистрыСведений.инт_АктивныеКонсьюмеры.ПолучитьАктивныеКонсьюмеры();
	
	Для Каждого Запись Из АктивныеКонсьюмеры Цикл
		// Не удаляем записи со статусом Drained
		Если Запись.СтатусАктивности = "Drained" Тогда
			Продолжить;
		КонецЕсли;
		
		Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Запись.ИдентификаторФоновогоЗадания);
		
		Если Задание = Неопределено ИЛИ Задание.Состояние <> СостояниеФоновогоЗадания.Активно Тогда
			РегистрыСведений.инт_АктивныеКонсьюмеры.УдалитьКонсьюмер(
				Запись.Подписка, 
				Запись.ИдентификаторФоновогоЗадания);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// инт_КонсьюмерОчередей
//
// Модуль реализации цикла чтения сообщений из Kafka/RabbitMQ.
// Вызывается из фоновых заданий менеджера входящих потоков.
// 
// Архитектура обработки сообщений:
// 1. Десериализация JSON → при ошибке: DLQ))
// 2. Валидация по схеме (если включена в потоке) → при ошибке: DLQ
// 3. Отправка на обработку через инт_ОбработкаВходящихПотоков.ОбработкаВходящегоСообщенияПоПотоку
//    - для асинхронных потоков: запись в очередь входящих сообщений
//    - для синхронных потоков: немедленное выполнение обработчика
// 4. При ошибке обработки: регистрация в очереди входящих со статусом ОшибкаОбработки
//    (retry через регламентное задание инт_ОбработкаВходящейОчереди)
// 5. Если регистрация для retry невозможна: DLQ
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Читает сообщения из Kafka для указанных подписок.
// Подписки сгруппированы по эндпоинту (одна consumer group на эндпоинт).
// Режим обработки (асинх/синх) определяется настройкой потока данных.
//
// Параметры:
//  МассивПодписок - Массив из Структура - Подписки для обработки:
//   * Подписка     - СправочникСсылка.инт_ПодписчикиKafka
//   * ПотокДанных  - СправочникСсылка.инт_ПотокиДанных
//
Процедура ЧитатьСообщения(МассивПодписок) Экспорт
	
	Если МассивПодписок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Получаем параметры первой подписки для инициализации консьюмера
	ПерваяПодписка = МассивПодписок[0].Подписка;
	
	// Получаем адрес брокера
	Брокеры = ПерваяПодписка.Эндпоинт.АдресРесурса;
	
	// Формируем список топиков и соответствие топик -> структура подписки
	МассивТопиков = Новый Массив;
	СоответствиеТопикПодписка = Новый Соответствие;
	
	Для Каждого СтрокаПодписки Из МассивПодписок Цикл
		Топик = СтрокаПодписки.Подписка.ИмяТопика;
		Если МассивТопиков.Найти(Топик) = Неопределено Тогда
			МассивТопиков.Добавить(Топик);
		КонецЕсли;
		
		// Сохраняем полную структуру подписки для топика
		СоответствиеТопикПодписка.Вставить(Топик, СтрокаПодписки);
	КонецЦикла;
	
	// Используем консьюмер-группу по умолчанию (consumer group из константы)
	ГруппаКонсьюмеров = инт_КонсьюмерОчередейСлужебный.СформироватьИдентификаторГруппы("consumer");
	
	// Создаём консьюмер
	Компонента = инт_КонсьюмерОчередейСлужебный.СоздатьКонсьюмер(Брокеры, ГруппаКонсьюмеров, МассивТопиков);
	
	Если Компонента = Неопределено Тогда
		ВызватьИсключение "Не удалось создать консьюмер Kafka";
	КонецЕсли;
	
	Попытка
		// Основной цикл чтения
		ЦиклЧтенияСообщений(Компонента, СоответствиеТопикПодписка, МассивПодписок);
	Исключение
		ЗаписьЖурналаРегистрации(
			"ПодсистемаИнтеграции.КонсьюмерОчередей",
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ОписаниеОшибки());
	КонецПопытки;
	
	// Останавливаем консьюмер
	инт_КонсьюмерОчередейСлужебный.ОстановитьКонсьюмер(Компонента);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Основной цикл чтения сообщений.
// Обрабатывает сообщения через универсальный метод ОбработатьВходящееСообщение.
//
Процедура ЦиклЧтенияСообщений(Компонента, СоответствиеТопикПодписка, МассивПодписок)
	
	РазрешеноСлушать = Истина;
	
	Пока РазрешеноСлушать Цикл
		
		// Читаем сообщение
		РезультатЧтения = Компонента.ПрочитатьСообщение();
		Если НЕ РезультатЧтения Тогда
			// Проверяем флаг активности подписок
			РазрешеноСлушать = ПроверитьАктивностьПодписок(МассивПодписок);
			Продолжить;
		КонецЕсли;
		
		// Получаем данные сообщения
		ДанныеСообщения = Компонента.ПолучитьДанныеСообщения();
		ТопикСообщения = Компонента.ПолучитьТопикСообщения();
		СмещениеСообщения = Компонента.ПолучитьСмещениеСообщения();
		РазделСообщения = Компонента.ПолучитьРазделСообщения();
		
		// Находим структуру подписки для этого топика
		СтруктураПодписки = СоответствиеТопикПодписка.Получить(ТопикСообщения);
		
		Если СтруктураПодписки = Неопределено Тогда
			ЗаписьЖурналаРегистрации(
				"ПодсистемаИнтеграции.КонсьюмерОчередей",
				УровеньЖурналаРегистрации.Предупреждение,
				,
				,
				СтрШаблон("Получено сообщение из неизвестного топика: %1", ТопикСообщения));
			
			// Фиксируем смещение чтобы не застрять
			ЗафиксироватьСмещение(Компонента, ТопикСообщения, СмещениеСообщения, РазделСообщения);
			Продолжить;
		КонецЕсли;
		
		// Обрабатываем сообщение через универсальный метод
		РезультатОбработки = ОбработатьВходящееСообщение(
			ДанныеСообщения,
			СтруктураПодписки.ПотокДанных,
			СтруктураПодписки.Подписка);
		
		Если РезультатОбработки.ОтправитьВDLQ Тогда
			// Отправляем в DLQ только при ошибках валидации/десериализации
			// или если не удалось зарегистрировать для повторной обработки
			ОтправитьВDLQПриОшибке(
				СтруктураПодписки.Подписка,
				ДанныеСообщения,
				ТопикСообщения,
				СмещениеСообщения,
				РазделСообщения,
				РезультатОбработки.ОписаниеОшибки);
		КонецЕсли;
		
		// Фиксируем смещение (даже при ошибке, т.к. сообщение ушло в DLQ или зарегистрировано для retry)
		ЗафиксироватьСмещение(Компонента, ТопикСообщения, СмещениеСообщения, РазделСообщения);
		
	КонецЦикла;
	
КонецПроцедуры

// Обрабатывает входящее сообщение: десериализация, валидация, обработка.
// 
// Логика ошибок:
//  - Ошибка десериализации/валидации → ОтправитьВDLQ (retry бессмысленен)
//  - Ошибка обработки → регистрация в очереди входящих для retry через scheduled job
//  - Невозможно зарегистрировать для retry → ОтправитьВDLQ (крайний случай)
//
// Параметры:
//  ДанныеСообщения - Строка - Тело сообщения (JSON)
//  ПотокДанных     - СправочникСсылка.инт_ПотокиДанных - Поток данных
//  Подписка        - СправочникСсылка.инт_ПодписчикиKafka - Подписка
//
// Возвращаемое значение:
//  Структура:
//   * Успех          - Булево - Сообщение обработано или зарегистрировано для retry
//   * ОписаниеОшибки - Строка - Текст ошибки (при ОтправитьВDLQ = Истина)
//   * ОтправитьВDLQ  - Булево - Требуется отправка в Dead Letter Queue
//
Функция ОбработатьВходящееСообщение(ДанныеСообщения, ПотокДанных, Подписка)
	
	Результат = Новый Структура("Успех, ОписаниеОшибки, ОтправитьВDLQ", Ложь, "", Ложь);
	
	// 1. Десериализация JSON → при ошибке DLQ
	Попытка
		МодельДанных = инт_КоннекторHTTP.JsonВОбъект(ДанныеСообщения);
	Исключение
		Результат.ОписаниеОшибки = СтрШаблон("Ошибка десериализации JSON: %1", ОписаниеОшибки());
		Результат.ОтправитьВDLQ = Истина;
		ЗаписатьОшибкуВЖурнал(ПотокДанных, Результат.ОписаниеОшибки);
		Возврат Результат;
	КонецПопытки;
	
	// 2. Валидация по схеме → при ошибке DLQ
	Если ПотокДанных.Валидация Тогда
		Попытка
			Справочники.инт_ПотокиДанных.ВалидироватьСообщениеПоПотоку(МодельДанных, ПотокДанных);
		Исключение
			Результат.ОписаниеОшибки = СтрШаблон("Ошибка валидации: %1", ОписаниеОшибки());
			Результат.ОтправитьВDLQ = Истина;
			ЗаписатьОшибкуВЖурнал(ПотокДанных, Результат.ОписаниеОшибки);
			Возврат Результат;
		КонецПопытки;
	КонецЕсли;
	
	// 3. Обработка (асинх/синх определяется внутри)
	Попытка
		ИдентификаторСообщения = Новый УникальныйИдентификатор;
		инт_ОбработкаВходящихПотоков.ОбработкаВходящегоСообщенияПоПотоку(
			МодельДанных,
			ПотокДанных,
			ИдентификаторСообщения);
		
		Результат.Успех = Истина;
	Исключение
		ОписаниеОшибкиОбработки = СтрШаблон("Ошибка обработки: %1", ОписаниеОшибки());
		ЗаписатьОшибкуВЖурнал(ПотокДанных, ОписаниеОшибкиОбработки);
		
		// Пытаемся зарегистрировать в очереди входящих для повторной обработки
		ЗарегистрироватьДляПовторнойОбработки(Результат, МодельДанных, ПотокДанных, ОписаниеОшибкиОбработки);
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Регистрирует сообщение в очереди входящих для повторной обработки через scheduled job.
// Записывает сообщение со статусом ОшибкаОбработки — retry будет выполнен
// регламентным заданием инт_ОбработкаВходящейОчереди с учётом паузы и лимита попыток.
//
// Параметры:
//  Результат              - Структура - Результат обработки (модифицируется):
//   * Успех               - Булево
//   * ОписаниеОшибки      - Строка
//   * ОтправитьВDLQ       - Булево
//  МодельДанных           - Произвольный - Десериализованные данные сообщения
//  ПотокДанных            - СправочникСсылка.инт_ПотокиДанных - Поток данных
//  ОписаниеОшибкиОбработки - Строка - Текст ошибки обработки
//
Процедура ЗарегистрироватьДляПовторнойОбработки(Результат, МодельДанных, ПотокДанных, ОписаниеОшибкиОбработки)
	
	НовыйИдентификатор = Новый УникальныйИдентификатор;
	
	НачатьТранзакцию();
	Попытка
		РегистрыСведений.инт_ОчередьВходящихСообщений.ЗарегистрироватьСообщение(
			МодельДанных,
			ПотокДанных,
			НовыйИдентификатор);
		
		// Устанавливаем статус ОшибкаОбработки — увеличит счётчик попыток и рассчитает дату следующей попытки
		РегистрыСведений.инт_ТекущийСтатусВходящихСообщений.ЗаписатьСтатусСообщения(
			НовыйИдентификатор,
			Перечисления.инт_СтатусыВходящихСообщений.ОшибкаОбработки,
			ОписаниеОшибкиОбработки);
		
		ЗафиксироватьТранзакцию();
		
		Результат.Успех = Истина;
		
		ЗаписьЖурналаРегистрации(
			"ПодсистемаИнтеграции.КонсьюмерОчередей.Retry",
			УровеньЖурналаРегистрации.Информация,
			,
			ПотокДанных,
			СтрШаблон("Сообщение зарегистрировано для повторной обработки (ID: %1). Ошибка: %2",
				НовыйИдентификатор, ОписаниеОшибкиОбработки));
	Исключение
		ОтменитьТранзакцию();
		// Не удалось зарегистрировать — отправляем в DLQ
		Результат.ОписаниеОшибки = СтрШаблон(
			"Ошибка обработки: %1. Не удалось зарегистрировать для повторной обработки: %2",
			ОписаниеОшибкиОбработки,
			ОписаниеОшибки());
		Результат.ОтправитьВDLQ = Истина;
		ЗаписатьОшибкуВЖурнал(ПотокДанных, Результат.ОписаниеОшибки);
	КонецПопытки;
	
КонецПроцедуры

// Отправляет сообщение в DLQ при ошибке.
//
Процедура ОтправитьВDLQПриОшибке(Подписка, ДанныеСообщения, ТопикСообщения, СмещениеСообщения, РазделСообщения, ОписаниеОшибки)
	
	ИмяDLQТопика = Подписка.ИмяDLQТопика;
	
	Если НЕ ЗначениеЗаполнено(ИмяDLQТопика) Тогда
		// DLQ не настроен - просто логируем
		ЗаписьЖурналаРегистрации(
			"ПодсистемаИнтеграции.КонсьюмерОчередей.DLQ",
			УровеньЖурналаРегистрации.Предупреждение,
			,
			Подписка,
			СтрШаблон("DLQ не настроен. Сообщение потеряно. Топик: %1, Смещение: %2. Ошибка: %3",
				ТопикСообщения, СмещениеСообщения, ОписаниеОшибки));
		Возврат;
	КонецЕсли;
	
	инт_КонсьюмерОчередейСлужебный.ОтправитьВDLQ(
		Подписка.Эндпоинт,
		ИмяDLQТопика,
		ДанныеСообщения,
		ТопикСообщения,
		СмещениеСообщения,
		РазделСообщения,
		ОписаниеОшибки);
	
КонецПроцедуры

// Записывает ошибку в журнал регистрации.
//
Процедура ЗаписатьОшибкуВЖурнал(ПотокДанных, ОписаниеОшибки)
	
	ЗаписьЖурналаРегистрации(
		"ПодсистемаИнтеграции.КонсьюмерОчередей",
		УровеньЖурналаРегистрации.Ошибка,
		,
		ПотокДанных,
		ОписаниеОшибки);
	
КонецПроцедуры

// Проверяет активность подписок.
//
// Возвращаемое значение:
//  Булево - Истина, если хотя бы одна подписка активна
//
Функция ПроверитьАктивностьПодписок(МассивПодписок)
	
	Для Каждого СтрокаПодписки Из МассивПодписок Цикл
		Если СтрокаПодписки.Подписка.Активен Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Фиксирует смещение в Kafka.
//
Процедура ЗафиксироватьСмещение(Компонента, Топик, Смещение, Раздел)
	
	НовоеСмещение = Число(Смещение) + 1;
	Компонента.ЗафиксироватьСмещение(Топик, НовоеСмещение, Раздел);
	
КонецПроцедуры

#КонецОбласти

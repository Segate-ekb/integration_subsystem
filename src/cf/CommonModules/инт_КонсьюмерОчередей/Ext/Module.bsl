////////////////////////////////////////////////////////////////////////////////
// инт_КонсьюмерОчередей
//
// Модуль реализации цикла чтения сообщений из Kafka/RabbitMQ.
// Вызывается из фоновых заданий менеджера входящих потоков.
// 
// Архитектура обработки сообщений:
// 1. Десериализация JSON
// 2. Валидация по схеме (если включена в потоке)
// 3. Отправка на обработку через инт_ОбработкаВходящихПотоков.ОбработкаВходящегоСообщенияПоПотоку
//    - для асинхронных потоков: запись в очередь входящих сообщений
//    - для синхронных потоков: немедленное выполнение обработчика
// 4. При любой ошибке: отправка в DLQ (Dead Letter Queue)
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Читает сообщения из Kafka для указанных подписок.
// Подписки сгруппированы по эндпоинту (одна consumer group на эндпоинт).
// Режим обработки (асинх/синх) определяется настройкой потока данных.
//
// Параметры:
//  МассивПодписок - Массив из Структура - Подписки для обработки:
//   * Подписка     - СправочникСсылка.инт_ПодписчикиKafka
//   * ПотокДанных  - СправочникСсылка.инт_ПотокиДанных
//
Процедура ЧитатьСообщения(МассивПодписок) Экспорт
	
	Если МассивПодписок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Получаем параметры первой подписки для инициализации консьюмера
	ПерваяПодписка = МассивПодписок[0].Подписка;
	
	// Получаем адрес брокера
	Брокеры = ПерваяПодписка.Эндпоинт.АдресРесурса;
	
	// Формируем список топиков и соответствие топик -> структура подписки
	МассивТопиков = Новый Массив;
	СоответствиеТопикПодписка = Новый Соответствие;
	
	Для Каждого СтрокаПодписки Из МассивПодписок Цикл
		Топик = СтрокаПодписки.Подписка.ИмяТопика;
		Если МассивТопиков.Найти(Топик) = Неопределено Тогда
			МассивТопиков.Добавить(Топик);
		КонецЕсли;
		
		// Сохраняем полную структуру подписки для топика
		СоответствиеТопикПодписка.Вставить(Топик, СтрокаПодписки);
	КонецЦикла;
	
	// Генерируем consumer group ID
	ГруппаКонсьюмеров = инт_КонсьюмерОчередейСлужебный.СформироватьИдентификаторГруппы("consumer");
	
	// Создаём консьюмер
	Компонента = инт_КонсьюмерОчередейСлужебный.СоздатьКонсьюмер(Брокеры, ГруппаКонсьюмеров, МассивТопиков);
	
	Если Компонента = Неопределено Тогда
		ВызватьИсключение "Не удалось создать консьюмер Kafka";
	КонецЕсли;
	
	Попытка
		// Основной цикл чтения
		ЦиклЧтенияСообщений(Компонента, СоответствиеТопикПодписка, МассивПодписок);
	Исключение
		ЗаписьЖурналаРегистрации(
			"ПодсистемаИнтеграции.КонсьюмерОчередей",
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ОписаниеОшибки());
	КонецПопытки;
	
	// Останавливаем консьюмер
	инт_КонсьюмерОчередейСлужебный.ОстановитьКонсьюмер(Компонента);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Основной цикл чтения сообщений.
// Обрабатывает сообщения через универсальный метод ОбработатьВходящееСообщение.
//
Процедура ЦиклЧтенияСообщений(Компонента, СоответствиеТопикПодписка, МассивПодписок)
	
	РазрешеноСлушать = Истина;
	
	Пока РазрешеноСлушать Цикл
		
		// Читаем сообщение
		РезультатЧтения = Компонента.ПрочитатьСообщение();
		Если НЕ РезультатЧтения Тогда
			// Проверяем флаг активности подписок
			РазрешеноСлушать = ПроверитьАктивностьПодписок(МассивПодписок);
			Продолжить;
		КонецЕсли;
		
		// Получаем данные сообщения
		ДанныеСообщения = Компонента.ПолучитьДанныеСообщения();
		ТопикСообщения = Компонента.ПолучитьТопикСообщения();
		СмещениеСообщения = Компонента.ПолучитьСмещениеСообщения();
		РазделСообщения = Компонента.ПолучитьРазделСообщения();
		
		// Находим структуру подписки для этого топика
		СтруктураПодписки = СоответствиеТопикПодписка.Получить(ТопикСообщения);
		
		Если СтруктураПодписки = Неопределено Тогда
			ЗаписьЖурналаРегистрации(
				"ПодсистемаИнтеграции.КонсьюмерОчередей",
				УровеньЖурналаРегистрации.Предупреждение,
				,
				,
				СтрШаблон("Получено сообщение из неизвестного топика: %1", ТопикСообщения));
			
			// Фиксируем смещение чтобы не застрять
			ЗафиксироватьСмещение(Компонента, ТопикСообщения, СмещениеСообщения, РазделСообщения);
			Продолжить;
		КонецЕсли;
		
		// Обрабатываем сообщение через универсальный метод
		РезультатОбработки = ОбработатьВходящееСообщение(
			ДанныеСообщения,
			СтруктураПодписки.ПотокДанных,
			СтруктураПодписки.Подписка);
		
		Если НЕ РезультатОбработки.Успех Тогда
			// Отправляем в DLQ при любой ошибке (валидации или обработки)
			ОтправитьВDLQПриОшибке(
				СтруктураПодписки.Подписка,
				ДанныеСообщения,
				ТопикСообщения,
				СмещениеСообщения,
				РазделСообщения,
				РезультатОбработки.ОписаниеОшибки);
		КонецЕсли;
		
		// Фиксируем смещение (даже при ошибке, т.к. сообщение ушло в DLQ или обработано)
		ЗафиксироватьСмещение(Компонента, ТопикСообщения, СмещениеСообщения, РазделСообщения);
		
	КонецЦикла;
	
КонецПроцедуры

// Обрабатывает входящее сообщение: валидация + обработка.
// Маршрутизация асинх/синх выполняется внутри инт_ОбработкаВходящихПотоков.
//
// Параметры:
//  ДанныеСообщения - Строка - Тело сообщения (JSON)
//  ПотокДанных     - СправочникСсылка.инт_ПотокиДанных - Поток данных
//  Подписка        - СправочникСсылка.инт_ПодписчикиKafka - Подписка
//
// Возвращаемое значение:
//  Структура:
//   * Успех          - Булево
//   * ОписаниеОшибки - Строка
//
Функция ОбработатьВходящееСообщение(ДанныеСообщения, ПотокДанных, Подписка)
	
	Результат = Новый Структура("Успех, ОписаниеОшибки", Ложь, "");
	
	// 1. Десериализация JSON
	Попытка
		МодельДанных = инт_КоннекторHTTP.JsonВОбъект(ДанныеСообщения);
	Исключение
		Результат.ОписаниеОшибки = СтрШаблон("Ошибка десериализации JSON: %1", ОписаниеОшибки());
		ЗаписатьОшибкуВЖурнал(ПотокДанных, Результат.ОписаниеОшибки);
		Возврат Результат;
	КонецПопытки;
	
	// 2. Валидация по схеме (если включена в потоке)
	Если ПотокДанных.Валидация Тогда
		Попытка
			Справочники.инт_ПотокиДанных.ВалидироватьСообщениеПоПотоку(МодельДанных, ПотокДанных);
		Исключение
			Результат.ОписаниеОшибки = СтрШаблон("Ошибка валидации: %1", ОписаниеОшибки());
			ЗаписатьОшибкуВЖурнал(ПотокДанных, Результат.ОписаниеОшибки);
			Возврат Результат;
		КонецПопытки;
	КонецЕсли;
	
	// 3. Отправка на обработку (асинх/синх определяется внутри)
	// Для асинхронных - запись в очередь, для синхронных - немедленная обработка
	Попытка
		ИдентификаторСообщения = Новый УникальныйИдентификатор;
		инт_ОбработкаВходящихПотоков.ОбработкаВходящегоСообщенияПоПотоку(
			МодельДанных,
			ПотокДанных,
			ИдентификаторСообщения);
		
		Результат.Успех = Истина;
	Исключение
		Результат.ОписаниеОшибки = СтрШаблон("Ошибка обработки: %1", ОписаниеОшибки());
		ЗаписатьОшибкуВЖурнал(ПотокДанных, Результат.ОписаниеОшибки);
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Отправляет сообщение в DLQ при ошибке.
//
Процедура ОтправитьВDLQПриОшибке(Подписка, ДанныеСообщения, ТопикСообщения, СмещениеСообщения, РазделСообщения, ОписаниеОшибки)
	
	ИмяDLQТопика = Подписка.ИмяDLQТопика;
	
	Если НЕ ЗначениеЗаполнено(ИмяDLQТопика) Тогда
		// DLQ не настроен - просто логируем
		ЗаписьЖурналаРегистрации(
			"ПодсистемаИнтеграции.КонсьюмерОчередей.DLQ",
			УровеньЖурналаРегистрации.Предупреждение,
			,
			Подписка,
			СтрШаблон("DLQ не настроен. Сообщение потеряно. Топик: %1, Смещение: %2. Ошибка: %3",
				ТопикСообщения, СмещениеСообщения, ОписаниеОшибки));
		Возврат;
	КонецЕсли;
	
	инт_КонсьюмерОчередейСлужебный.ОтправитьВDLQ(
		Подписка.Эндпоинт,
		ИмяDLQТопика,
		ДанныеСообщения,
		ТопикСообщения,
		СмещениеСообщения,
		РазделСообщения,
		ОписаниеОшибки);
	
КонецПроцедуры

// Записывает ошибку в журнал регистрации.
//
Процедура ЗаписатьОшибкуВЖурнал(ПотокДанных, ОписаниеОшибки)
	
	ЗаписьЖурналаРегистрации(
		"ПодсистемаИнтеграции.КонсьюмерОчередей",
		УровеньЖурналаРегистрации.Ошибка,
		,
		ПотокДанных,
		ОписаниеОшибки);
	
КонецПроцедуры

// Проверяет активность подписок.
//
// Возвращаемое значение:
//  Булево - Истина, если хотя бы одна подписка активна
//
Функция ПроверитьАктивностьПодписок(МассивПодписок)
	
	Для Каждого СтрокаПодписки Из МассивПодписок Цикл
		Если СтрокаПодписки.Подписка.Активен Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Фиксирует смещение в Kafka.
//
Процедура ЗафиксироватьСмещение(Компонента, Топик, Смещение, Раздел)
	
	НовоеСмещение = Число(Смещение) + 1;
	Компонента.ЗафиксироватьСмещение(Топик, НовоеСмещение, Раздел);
	
КонецПроцедуры

#КонецОбласти

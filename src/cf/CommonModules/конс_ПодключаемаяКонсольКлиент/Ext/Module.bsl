////////////////////////////////////////////////////////////////////////////////
// конс_ПодключаемаяКонсольКлиент: Клиентский API для подключения редактора кода
////////////////////////////////////////////////////////////////////////////////
// 
// МИНИМАЛЬНОЕ ПОДКЛЮЧЕНИЕ РЕДАКТОРА (3 строки):
// 
// 1. Добавить на форму элемент типа ПолеHTML с именем "HTML"
//    (событие ДокументСформирован → HTMLДокументСформирован)
// 
// 2. В ПриСозданииНаСервере:
//    конс_ПодключаемаяКонсольСервер.ИнициализироватьРедактор(ЭтотОбъект, УникальныйИдентификатор);
// 
// 3. В ПриОткрытии:
//    конс_ПодключаемаяКонсольКлиент.ПодключитьРедактор(ЭтаФорма);
// 
// 4. В HTMLДокументСформирован:
//    конс_ПодключаемаяКонсольКлиент.ОбработчикДокументСформирован(ЭтаФорма);
// 
// РАБОТА С ТЕКСТОМ:
//    Текст = конс_ПодключаемаяКонсольКлиент.ПолучитьТекст(ЭтаФорма);
//    конс_ПодключаемаяКонсольКлиент.УстановитьТекст(ЭтаФорма, Текст);
// 
// ВЫПОЛНЕНИЕ КОДА:
//    конс_ПодключаемаяКонсольКлиент.ВыполнитьКод(ЭтаФорма);
// 
// ПЕРЕОПРЕДЕЛЕНИЕ НАСТРОЕК (в ПриСозданииНаСервере):
//    Параметры = Новый Структура("ПереопределитьНастройки", Новый Структура("КартаКода", Ложь));
//    конс_ПодключаемаяКонсольСервер.ИнициализироватьРедактор(ЭтотОбъект, УникальныйИдентификатор, Параметры);
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область Инициализация

// Подключает редактор кода к форме.
// Вызывать в обработчике ПриОткрытии формы.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с полем HTML редактора
//   ИмяПоляHTML - Строка - имя элемента ПолеHTML на форме. 
//                          Если не указано - берется из реквизита конс_ИмяПоляHTML или "HTML"
//
// Пример:
//   конс_ПодключаемаяКонсольКлиент.ПодключитьРедактор(ЭтаФорма);
//
Процедура ПодключитьРедактор(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	НачатьИнициализациюРедактора(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML));
	
КонецПроцедуры

// Обработчик события ДокументСформирован поля HTML.
// Вызывать из обработчика события ДокументСформирован.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка - если не указано, берется из формы
//
// Пример:
//   &НаКлиенте
//   Процедура HTMLДокументСформирован(Элемент)
//       конс_ПодключаемаяКонсольКлиент.ОбработчикДокументСформирован(ЭтаФорма);
//   КонецПроцедуры
//
Процедура ОбработчикДокументСформирован(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	ОбработчикOnReady(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML));
	
КонецПроцедуры

// Обработчик события ПриНажатии поля HTML.
// Вызывать из обработчика события ПриНажатии (OnClick).
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ДанныеСобытия - Структура
//   ИмяПоляHTML - Строка - если не указано, берется из формы
//
// Пример:
//   &НаКлиенте
//   Процедура HTMLПриНажатии(Элемент, ДанныеСобытия, СтандартнаяОбработка)
//       конс_ПодключаемаяКонсольКлиент.ОбработчикПриНажатии(ЭтаФорма, ДанныеСобытия);
//   КонецПроцедуры
//
Процедура ОбработчикПриНажатии(Форма, ДанныеСобытия, ИмяПоляHTML = Неопределено) Экспорт
	
	ОбработчикOnClick(Форма, ДанныеСобытия, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML));
	
КонецПроцедуры

#КонецОбласти

#Область РаботаСТекстом

// Получает текст из редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
// Возвращаемое значение:
//   Строка - текст из редактора
//
Функция ПолучитьТекст(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	Возврат View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).getText();
	
КонецФункции

// Получает текст из редактора.
// Функция-обёртка для совместимости после удаления инлайнера.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
// Возвращаемое значение:
//   Строка - текст из редактора
//
Функция ПолучитьИнлайнТекст(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	Возврат ПолучитьТекст(Форма, ИмяПоляHTML);
	
КонецФункции

// Устанавливает текст в редактор.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   Текст - Строка - текст для установки
//   Позиция - Число - позиция курсора (0 - в начало, -1 - в конец)
//   ИмяПоляHTML - Строка
//   УчитыватьОтступПервойСтроки - Булево
//
Процедура УстановитьТекст(Форма, Текст, Позиция = 0, ИмяПоляHTML = Неопределено, УчитыватьОтступПервойСтроки = Ложь) Экспорт
	
	View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).setText(Текст, Позиция, УчитыватьОтступПервойСтроки);
	
КонецПроцедуры

// Очищает текст в редакторе.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
Процедура ОчиститьТекст(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).eraseText();
	
КонецПроцедуры

// Вставляет текст в текущую позицию курсора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   Текст - Строка
//   ИмяПоляHTML - Строка
//
Процедура ВставитьТекст(Форма, Текст, ИмяПоляHTML = Неопределено) Экспорт
	
	View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).insertText(Текст);
	
КонецПроцедуры

// Получает выделенный текст.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
// Возвращаемое значение:
//   Строка - выделенный текст
//
Функция ПолучитьВыделенныйТекст(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	Возврат View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).getSelectedText();
	
КонецФункции

#КонецОбласти

#Область ПользовательскиеОбъектыИМетоды

// Загружает пользовательские переменные и функции в редактор.
// Вызывать после готовности редактора (в обработчике ДокументСформирован).
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
// Пример:
//   // В ПриСозданииНаСервере:
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(ЭтотОбъект, "_Товар", "Справочник.Номенклатура");
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(ЭтотОбъект, "_Клиент", СсылкаНаКонтрагента);
//   конс_ПодключаемаяКонсольСервер.ДобавитьФункциюВКонтекст(ЭтотОбъект, 
//       "ВычислитьСкидку", "Вычисляет скидку", "(Сумма: Число): Число");
//
//   // В HTMLДокументСформирован:
//   конс_ПодключаемаяКонсольКлиент.ЗагрузитьПользовательскийКонтекст(ЭтаФорма);
//
Процедура ЗагрузитьПользовательскийКонтекст(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	ИмяПоля = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	
	// Загружаем переменные
	Попытка
		JSONПеременных = Параметры.JSONПеременных;
		Если ЗначениеЗаполнено(JSONПеременных) Тогда
			JSONПеременных = "{""customObjects"":" + JSONПеременных + "}";
		Иначе
			JSONПеременных = "{""customObjects"":{}}";
		КонецЕсли;
		View(Форма, ИмяПоля).updateMetadata(JSONПеременных);
	Исключение
		// Ошибка загрузки
	КонецПопытки;
	
	// Загружаем функции
	Попытка
		JSONФункций = Параметры.JSONФункций;
		Если ЗначениеЗаполнено(JSONФункций) Тогда
			JSONФункций = "{""customFunctions"":" + JSONФункций + "}";
			View(Форма, ИмяПоля).updateCustomFunctions(JSONФункций);
		КонецЕсли;
	Исключение
		// Ошибка загрузки
	КонецПопытки;
	
	// Загружаем сниппеты
	Попытка
		JSONСниппетов = Параметры.JSONСниппетов;
		Если ЗначениеЗаполнено(JSONСниппетов) Тогда
			JSONСниппетов = "{""snippets"":" + JSONСниппетов + "}";
			View(Форма, ИмяПоля).updateSnippets(JSONСниппетов);
		КонецЕсли;
	Исключение
		// Ошибка загрузки
	КонецПопытки;
	
КонецПроцедуры

// Загружает пользовательские объекты в редактор для автодополнения.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   JSONОбъектов - Строка - JSON строка из СериализоватьОбъекты()
//   ИмяПоляHTML - Строка
//
// Возвращаемое значение:
//   Булево - успешность загрузки
//
// Пример:
//   // На сервере:
//   Объекты = конс_ПодключаемаяКонсольСервер.НоваяКоллекцияОбъектов();
//   конс_ПодключаемаяКонсольСервер.ДобавитьОбъект(Объекты, "_Заказ");
//   конс_ПодключаемаяКонсольСервер.ДобавитьСвойство(Построитель, "Номер", "Номер заказа");
//   JSON = конс_ПодключаемаяКонсольСервер.СериализоватьОбъекты(Объекты);
//
//   // На клиенте:
//   конс_ПодключаемаяКонсольКлиент.ЗагрузитьПользовательскиеОбъекты(ЭтаФорма, JSON);
//
Функция ЗагрузитьПользовательскиеОбъекты(Форма, JSONОбъектов, ИмяПоляHTML = Неопределено) Экспорт
	
	Попытка
		Результат = View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).updateMetadata(JSONОбъектов);
		Возврат (ТипЗнч(Результат) = Тип("Булево") И Результат);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Загружает пользовательские функции в редактор для автодополнения.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   JSONФункций - Строка - JSON строка из СериализоватьФункции()
//   ИмяПоляHTML - Строка
//
// Возвращаемое значение:
//   Булево - успешность загрузки
//
// Пример:
//   // На сервере:
//   Функции = конс_ПодключаемаяКонсольСервер.НоваяКоллекцияФункций();
//   Построитель = конс_ПодключаемаяКонсольСервер.ДобавитьФункцию(Функции, "ВычислитьСумму");
//   конс_ПодключаемаяКонсольСервер.ОписаниеФункции(Построитель, "Вычисляет сумму двух чисел");
//   конс_ПодключаемаяКонсольСервер.ВозвращаемоеЗначение(Построитель, "Число");
//   конс_ПодключаемаяКонсольСервер.ДобавитьСигнатуру(Построитель, "default", "(А: Число, Б: Число): Число");
//   конс_ПодключаемаяКонсольСервер.ОписаниеПараметра(Построитель, "А", "Первое слагаемое");
//   конс_ПодключаемаяКонсольСервер.ОписаниеПараметра(Построитель, "Б", "Второе слагаемое");
//   JSON = конс_ПодключаемаяКонсольСервер.СериализоватьФункции(Функции);
//
//   // На клиенте:
//   конс_ПодключаемаяКонсольКлиент.ЗагрузитьПользовательскиеФункции(ЭтаФорма, JSON);
//
Функция ЗагрузитьПользовательскиеФункции(Форма, JSONФункций, ИмяПоляHTML = Неопределено) Экспорт
	
	Попытка
		Результат = View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).updateCustomFunctions(JSONФункций);
		Возврат (ТипЗнч(Результат) = Тип("Булево") И Результат);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область СхемыПеременных

// Загружает OpenAPI / Swagger / JSON Schema файл и регистрирует все найденные типы
// как переменные редактора с автодополнением свойств.
//
// Для OpenAPI 3.x  — создаёт переменные для каждого типа из components.schemas
// Для Swagger 2.x  — создаёт переменные для каждого типа из definitions
// Для простой JSON Schema — создаёт одну переменную по schema.title
//
// Параметры:
//   Форма       - ФормаКлиентскогоПриложения
//   JSONСхемы   - Строка - JSON-содержимое файла схемы
//   ИмяПоляHTML - Строка - имя элемента формы (необязательно)
//
// Возвращаемое значение:
//   Строка - имена зарегистрированных типов через запятую, или пустая строка при ошибке
//
// Пример:
//   // Загрузка Petstore OpenAPI — создаст переменные Pet, Order, User, Category, Tag, ApiResponse
//   Типы = конс_ПодключаемаяКонсольКлиент.ЗагрузитьФайлСхемы(ЭтаФорма, JSONОткрытогоФайла);
//   // После этого в редакторе при вводе Pet[" появятся свойства id, name, category, ...
//
Функция ЗагрузитьФайлСхемы(Форма, JSONСхемы, ИмяПоляHTML = Неопределено) Экспорт
	
	Попытка
		Возврат View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).loadSchemaFile(JSONСхемы);
	Исключение
		Возврат "";
	КонецПопытки;
	
КонецФункции

// Привязывает JSON-схему (OpenAPI / JSON Schema) к ОДНОЙ переменной редактора.
// После привязки при вводе ИмяПеременной["  или ИмяПеременной.  будут предложены
// свойства, описанные в схеме.
//
// Для массовой загрузки всех типов из файла используйте ЗагрузитьФайлСхемы().
//
// Параметры:
//   Форма            - ФормаКлиентскогоПриложения
//   ИмяПеременной    - Строка - имя переменной в коде (например "Pet")
//   JSONСхемы        - Строка - JSON-строка с OpenAPI / JSON Schema
//   ИмяТипа          - Строка - имя типа в схеме (для OpenAPI — имя из components.schemas,
//                      например "Pet", "Order"; для простой JSON Schema не используется)
//   ИмяПоляHTML      - Строка - имя элемента формы (необязательно)
//
Процедура ЗагрузитьСхемуПеременной(Форма, ИмяПеременной, JSONСхемы, ИмяТипа = "Соответствие", ИмяПоляHTML = Неопределено) Экспорт
	
	Попытка
		View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).setVariableSchema(ИмяПеременной, JSONСхемы, ИмяТипа);
	Исключение
		// Ошибка загрузки схемы
	КонецПопытки;
	
КонецПроцедуры

// Удаляет привязку схемы к переменной.
//
// Параметры:
//   Форма            - ФормаКлиентскогоПриложения
//   ИмяПеременной    - Строка - имя переменной
//   ИмяПоляHTML      - Строка
//
Процедура УдалитьСхемуПеременной(Форма, ИмяПеременной, ИмяПоляHTML = Неопределено) Экспорт
	
	Попытка
		View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).removeVariableSchema(ИмяПеременной);
	Исключение
		// Ошибка удаления схемы
	КонецПопытки;
	
КонецПроцедуры

// Очищает все привязки схем к переменным.
//
// Параметры:
//   Форма       - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
Процедура ОчиститьСхемыПеременных(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	Попытка
		View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).clearVariableSchemas();
	Исключение
		// Ошибка очистки схем
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область ВыполнениеКода

// Выполняет код из редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   НаСервере - Булево - выполнять на сервере (Истина) или на клиенте (Ложь)
//   ИмяПоляHTML - Строка - имя элемента HTML
//   РежимПоказаПеременных - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим отображения переменных
//
Процедура ВыполнитьКод(Форма, НаСервере = Истина, ИмяПоляHTML = Неопределено, РежимПоказаПеременных = Неопределено) Экспорт

	Если РежимПоказаПеременных = Неопределено Тогда
		РежимПоказаПеременных = ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.НеОтображать");
	КонецЕсли;
	
	ИмяПоля = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	Код = ПолучитьТекстСКодомПросмотраПеременных(Форма, ИмяПоля, РежимПоказаПеременных);
	
	Если НаСервере Тогда
		Результат = конс_ПодключаемаяКонсольВызовСервера.ВыполнитьКодНаСервере(Код, РежимПоказаПеременных);
	Иначе
		Результат = ВыполнитьКодНаКлиенте(Код, РежимПоказаПеременных);
	КонецЕсли;
	
	ОбработатьРезультат(Форма, Результат, ИмяПоля);
	
КонецПроцедуры

// Подготавливает код для выполнения, добавляя сбор значений переменных.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ФильтрПеременных - Массив, Неопределено - имена переменных для сбора.
//                      Если Неопределено - собираются все переменные из редактора.
//                      Если пустой массив - переменные не собираются.
//   ИмяПоляHTML - Строка
//
// Возвращаемое значение:
//   Строка - код с добавленным сбором переменных
//
// Пример:
//   // Собрать все переменные:
//   Код = конс_ПодключаемаяКонсольКлиент.ПодготовитьКодСПеременными(ЭтаФорма);
//   
//   // Собрать только указанные:
//   Код = конс_ПодключаемаяКонсольКлиент.ПодготовитьКодСПеременными(ЭтаФорма, Новый Массив({"а", "б", "Результат"}));
//   
//   // Без сбора переменных:
//   Код = конс_ПодключаемаяКонсольКлиент.ПодготовитьКодСПеременными(ЭтаФорма, Новый Массив);
//
Функция ПодготовитьКодСПеременными(Форма, ФильтрПеременных = Неопределено, ИмяПоляHTML = Неопределено) Экспорт
	
	ИмяПоля = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	Код = ПолучитьИнлайнТекст(Форма, ИмяПоля);
	
	// Определяем какие переменные собирать
	Если ФильтрПеременных <> Неопределено Тогда
		Переменные = ФильтрПеременных;
	Иначе
		Переменные = ПолучитьИменаПеременных(Форма, ИмяПоля);
	КонецЕсли;
	
	Если Переменные = Неопределено Или Переменные.Количество() = 0 Тогда
		Возврат Код;
	КонецЕсли;
	
	ПС = Символы.ПС;
	
	Для Каждого Имя Из Переменные Цикл
		Код = Код + ПС + "Попытка ЗначенияПеременных.Вставить(""" + Имя + """,Вычислить(""" + Имя + """)); Исключение КонецПопытки;" + ПС;
	КонецЦикла;
	
	Возврат Код;
	
КонецФункции

// Обрабатывает результат выполнения кода.
// Показывает ошибку или значения переменных в зависимости от результата.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   Результат - Структура - результат от ВыполнитьКодНаСервере/ВыполнитьКодНаКлиенте
//   ИмяПоляHTML - Строка
//
// Пример:
//   Результат = конс_ПодключаемаяКонсольВызовСервера.ВыполнитьКодНаСервере(Код, 1);
//   конс_ПодключаемаяКонсольКлиент.ОбработатьРезультат(ЭтаФорма, Результат);
//
Процедура ОбработатьРезультат(Форма, Результат, ИмяПоляHTML = Неопределено) Экспорт
	
	ИмяПоля = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	
	// Очищаем предыдущие маркеры
	ОчиститьМаркерыОшибок(Форма, ИмяПоля);
	
	Если Результат.Успешно Тогда
		ОбработатьУспешноеВыполнениеПубличный(Форма, Результат, ИмяПоля);
	Иначе
		ОбработатьОшибкуВыполненияПубличный(Форма, Результат, ИмяПоля);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ВнешнееВыполнениеКода

// Получает список переменных из кода в редакторе.
// 
// Используйте этот метод для получения имён переменных, объявленных в коде,
// например, для отображения селектора переменных перед выполнением.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//   ИмяПоляHTML - Строка - имя элемента HTML (необязательный, по умолчанию ищется автоматически)
//   ФильтрПеременных - Массив, Неопределено - массив имён переменных для фильтрации.
//                      Если не указано или пустой - возвращаются все переменные.
//                      Если указан - возвращаются только переменные с указанными именами.
//
// Возвращаемое значение:
//   Массив из Строка - имена переменных, найденных в коде
//
// Пример:
//   // Получить все переменные:
//   МассивПеременных = конс_ПодключаемаяКонсольКлиент.ПолучитьПеременныеИзКода(ЭтаФорма);
//
//   // Получить только определённые переменные:
//   Фильтр = Новый Массив;
//   Фильтр.Добавить("Результат");  
//   Фильтр.Добавить("Сумма");
//   МассивПеременных = конс_ПодключаемаяКонсольКлиент.ПолучитьПеременныеИзКода(ЭтаФорма, , Фильтр);
//
Функция ПолучитьПеременныеИзКода(Форма, ИмяПоляHTML = Неопределено, ФильтрПеременных = Неопределено) Экспорт
	
	ИмяПоля = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	
	Если ФильтрПеременных = Неопределено Тогда
		ФильтрПеременных = Новый Массив;
	КонецЕсли;
	
	// Преобразуем фильтр к верхнему регистру для сравнения без учёта регистра
	ВрегМассив = Новый Массив;
	Для Каждого ЭлементМассива Из ФильтрПеременных Цикл
		ВрегМассив.Добавить(Врег(ЭлементМассива));
	КонецЦикла;
	
	// Получаем имена переменных из редактора
	Переменные = View(Форма, ИмяПоля).getVarsNames();
	
	МассивИмен = Новый Массив;
	Если Переменные.length > 0 Тогда
		Для Индекс = 0 По Переменные.length - 1 Цикл
			ИмяПеременной = Переменные["" + Индекс + ""];
			// Если фильтр задан, проверяем вхождение
			Если ВрегМассив.Количество() > 0 И ВрегМассив.Найти(Врег(ИмяПеременной)) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			МассивИмен.Добавить(ИмяПеременной);
		КонецЦикла;
	КонецЕсли;
	
	Возврат МассивИмен;
	
КонецФункции

// Получает код для внешнего выполнения с объявлением ЗначенияПеременных и сбором переменных.
// 
// Используйте этот метод, когда хотите выполнить код через свой собственный оператор Выполнить,
// а не через ВыполнитьКод. Код автоматически объявляет ЗначенияПеременных, собирает переменные
// и помещает их во временное хранилище.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   РежимПоказаПеременных - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим отображения переменных
//   ИмяПоляHTML - Строка - имя элемента HTML (необязательный)
//   ФильтрПеременных - Массив, Неопределено - массив имён переменных для анализа.
//                      Если не указано или пустой - анализируются все переменные.
//                      Если указан - анализируются только переменные с указанными именами.
//
// Возвращаемое значение:
//   Структура - данные для выполнения:
//     * Код - Строка - полный код для выполнения (с инициализацией и сохранением переменных)
//     * ИсходныйКод - Строка - оригинальный код без модификаций
//     * АдресХраненияПеременных - Строка - адрес временного хранилища для получения переменных
//     * ИменаПеременных - Массив - имена переменных для сбора
//     * СмещениеСтрок - Число - количество служебных строк в начале кода (для коррекции номеров строк в ошибках)
//     * РежимПоказаПеременных - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим показа
//
// Пример:
//   // Анализ всех переменных:
//   ДанныеКода = конс_ПодключаемаяКонсольКлиент.ПолучитьКодДляВнешнегоВыполнения(
//       ЭтаФорма, ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.ВТабло"));
//
//   // Анализ только указанных переменных:
//   ФильтрПеременных = Новый Массив;
//   ФильтрПеременных.Добавить("Результат");
//   ФильтрПеременных.Добавить("Сумма");
//   ДанныеКода = конс_ПодключаемаяКонсольКлиент.ПолучитьКодДляВнешнегоВыполнения(
//       ЭтаФорма, ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.ВТабло"), , ФильтрПеременных);
//   
//   ИнфоОшибки = Неопределено;
//   Попытка
//       Выполнить(ДанныеКода.Код);
//   Исключение
//       ИнфоОшибки = ИнформацияОбОшибке();
//   КонецПопытки;
//   
//   конс_ПодключаемаяКонсольКлиент.ОбработатьРезультатВнешнегоВыполнения(
//       ЭтаФорма, ДанныеКода, ИнфоОшибки);
//
Функция ПолучитьКодДляВнешнегоВыполнения(Форма, РежимПоказаПеременных, ИмяПоляHTML = Неопределено, ФильтрПеременных = Неопределено) Экспорт
	
	ИмяПоля = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	ИсходныйКод = ПолучитьИнлайнТекст(Форма, ИмяПоля);
	
	// Создаём временное хранилище для результата на сервере
	АдресХраненияПеременных = конс_ПодключаемаяКонсольВызовСервера.СоздатьВременноеХранилищеПеременных(Форма.УникальныйИдентификатор);
	
	Результат = Новый Структура;
	Результат.Вставить("ИсходныйКод", ИсходныйКод);
	Результат.Вставить("АдресХраненияПеременных", АдресХраненияПеременных);
	Результат.Вставить("ИменаПеременных", Новый Массив);
	Результат.Вставить("Код", ИсходныйКод);
	Результат.Вставить("СмещениеСтрок", 0); // Количество служебных строк в начале кода
	Результат.Вставить("РежимПоказаПеременных", РежимПоказаПеременных);
	
	Если Не РежимПоказаПеременных = ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.НеОтображать") Тогда
		
		// Получаем имена переменных из редактора с учётом фильтра
		МассивИмен = ПолучитьПеременныеИзКода(Форма, ИмяПоля, ФильтрПеременных);
		Результат.ИменаПеременных = МассивИмен;
		
		ПС = Символы.ПС;
		
		// Код инициализации - добавляется ПОСЛЕ пользовательского кода
		// чтобы номера строк в редакторе совпадали с номерами при выполнении
		КодИнициализации = ПС + "ЗначенияПеременных = Новый Структура;";
		КодИнициализации = КодИнициализации + ПС + "__конс_АдресХраненияПеременных__ = """ + АдресХраненияПеременных + """;";
		// СмещениеСтрок = 0, служебные строки теперь в конце!
		
		// Код сбора переменных
		КодСбора = "";
		Для Каждого Имя Из МассивИмен Цикл
			КодСбора = КодСбора + ПС + "Попытка ЗначенияПеременных.Вставить(""" + Имя + """, Вычислить(""" + Имя + """)); Исключение КонецПопытки;";
		КонецЦикла;
		
		// Код сохранения результата в хранилище
		КодСохранения = ПС + "ПоместитьВоВременноеХранилище(ЗначенияПеременных, __конс_АдресХраненияПеременных__);";
		
		// Собираем полный код: сначала пользовательский, потом служебный
		Результат.Код = ИсходныйКод + КодИнициализации + КодСбора + КодСохранения;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Обрабатывает результат внешнего выполнения кода.
// 
// Вызывайте этот метод после выполнения кода, полученного через ПолучитьКодДляВнешнегоВыполнения.
// Метод получит переменные из хранилища и отобразит их в табло/подсказках или покажет ошибку.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ДанныеКода - Структура - структура, полученная от ПолучитьКодДляВнешнегоВыполнения
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Неопределено - ошибка выполнения
//   ИмяПоляHTML - Строка
//
// Пример:
//   ДанныеКода = конс_ПодключаемаяКонсольКлиент.ПолучитьКодДляВнешнегоВыполнения(ЭтаФорма);
//   ИнфоОшибки = Неопределено;
//   
//   Попытка
//       Выполнить(ДанныеКода.Код);
//   Исключение
//       ИнфоОшибки = ИнформацияОбОшибке();
//   КонецПопытки;
//   
//   конс_ПодключаемаяКонсольКлиент.ОбработатьРезультатВнешнегоВыполнения(
//       ЭтаФорма, ДанныеКода, ИнфоОшибки);
//
Процедура ОбработатьРезультатВнешнегоВыполнения(Форма, ДанныеКода, ИнформацияОбОшибке, ИмяПоляHTML = Неопределено) Экспорт
	
	// Разбираем информацию об ошибке для передачи на сервер
	РазобраннаяИнформацияОбОшибке = РазобратьИнформациюОбОшибкеКлиент(ИнформацияОбОшибке);
	
	// Получаем переменные из хранилища и формируем результат на сервере
	Результат = конс_ПодключаемаяКонсольВызовСервера.ОбработатьРезультатВнешнегоВыполнения(
		ДанныеКода.АдресХраненияПеременных,
		РазобраннаяИнформацияОбОшибке,
		ДанныеКода.РежимПоказаПеременных);
	
	// Используем стандартный обработчик
	ОбработатьРезультат(Форма, Результат, ИмяПоляHTML);
	
КонецПроцедуры

// Разбирает информацию об ошибке в структуру для передачи на сервер.
// Парсит ПодробноеПредставлениеОшибки с конца к началу, чтобы найти строку выполняемого кода.
// 
// Параметры:
//   ИнфоОшибки - ИнформацияОбОшибке
//
// Возвращаемое значение:
//   Структура, Неопределено - разобранная информация или Неопределено
//
Функция РазобратьИнформациюОбОшибкеКлиент(ИнфоОшибки) Экспорт
	
	Если ИнфоОшибки = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем полный стек ошибки
	ПолныйТекст = ПодробноеПредставлениеОшибки(ИнфоОшибки);
	
	// Парсим стек ошибки с конца к началу
	Возврат РазобратьСтекОшибки(ПолныйТекст, ИнфоОшибки.Описание);
	
КонецФункции

// Разбирает стек ошибки из ПодробноеПредставлениеОшибки.
// Делегирует в общий клиент-серверный модуль.
// 
// Параметры:
//   ПолныйТекст - Строка - результат ПодробноеПредставлениеОшибки
//   ОписаниеОшибки - Строка - текст ошибки (первопричина)
//
// Возвращаемое значение:
//   Структура - разобранная информация об ошибке
//
Функция РазобратьСтекОшибки(ПолныйТекст, ОписаниеОшибки)
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.РазобратьСтекОшибки(ПолныйТекст, ОписаниеОшибки);
	
КонецФункции

// Примечание: Функции ИзвлечьОписаниеОтНачалаДоИндекса и ИзвлечьОписаниеОшибкиИзСтрок
// перенесены в конс_ПодключаемаяКонсольКлиентСервер

#КонецОбласти

#Область НастройкиРедактора

// Применяет настройки к редактору.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   Настройки - Структура - настройки из хранилища
//   ИмяПоляHTML - Строка
//
Процедура ПрименитьНастройки(Форма, Настройки, ИмяПоляHTML = Неопределено) Экспорт
	
	ИмяПоляHTML = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	
	// Тема
	Если Настройки.Свойство("Тема") И ЗначениеЗаполнено(Настройки.Тема) Тогда
		ИмяТемы = СоответствиеТем().Получить(Настройки.Тема);
		Если ИмяТемы <> Неопределено Тогда
			View(Форма, ИмяПоляHTML).setTheme(ИмяТемы);
		КонецЕсли;
	КонецЕсли;
	
	// Быстрые подсказки
	Если Настройки.Свойство("БыстрыеПодсказки") Тогда
		View(Форма, ИмяПоляHTML).enableQuickSuggestions(Настройки.БыстрыеПодсказки);
	КонецЕсли;
	
	// Карта кода
	Если Настройки.Свойство("КартаКода") Тогда
		View(Форма, ИмяПоляHTML).minimap(Настройки.КартаКода);
	КонецЕсли;
	
	// Пробелы и табуляции
	Если Настройки.Свойство("ПробелыИТабуляции") Тогда
		View(Форма, ИмяПоляHTML).renderWhitespace(Настройки.ПробелыИТабуляции);
	КонецЕсли;
	
	// Строка состояния
	Если Настройки.Свойство("СтрокаСостояния") Тогда
		Если Настройки.СтрокаСостояния Тогда
			View(Форма, ИмяПоляHTML).showStatusBar();
		Иначе
			View(Форма, ИмяПоляHTML).hideStatusBar();
		КонецЕсли;
	КонецЕсли;
	
	// Язык подсказок
	Если Настройки.Свойство("ЯзыкПодсказок") И Настройки.ЯзыкПодсказок = "en" Тогда
		View(Форма, ИмяПоляHTML).switchLang();
	КонецЕсли;
	
	// Отключение встроенных сниппетов
	Если Настройки.Свойство("ОтключитьВстроенныеСниппеты") И Настройки.ОтключитьВстроенныеСниппеты Тогда
		View(Форма, ИмяПоляHTML).clearSnippets();
	КонецЕсли;
	
	// Загрузка сниппетов из файла шаблонов (.st)
	Если Настройки.Свойство("ПутьКШаблонамКода") И ЗначениеЗаполнено(Настройки.ПутьКШаблонамКода) Тогда
		ЗагрузитьСниппетыИзФайла(Форма, Настройки.ПутьКШаблонамКода, ИмяПоляHTML);
	КонецЕсли;
	
КонецПроцедуры

// Загружает сниппеты из файла шаблонов 1С (.st).
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ПутьКФайлу - Строка - полный путь к файлу .st
//   ИмяПоляHTML - Строка
//
// Пример:
//   конс_ПодключаемаяКонсольКлиент.ЗагрузитьСниппетыИзФайла(ЭтаФорма, "C:\Шаблоны\МоиШаблоны.st");
//
Процедура ЗагрузитьСниппетыИзФайла(Форма, ПутьКФайлу, ИмяПоляHTML = Неопределено) Экспорт
	
	ИмяПоляHTML = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	
	// Чтение файла выполняется на сервере, т.к. синхронные методы
	// (Файл.Существует, ЧтениеТекста) запрещены на клиенте
	РезультатЧтения = конс_ПодключаемаяКонсольВызовСервера.ПрочитатьТекстовыйФайл(ПутьКФайлу);
	
	Если Не РезультатЧтения.Успешно Тогда
		Если ЗначениеЗаполнено(РезультатЧтения.ОшибкаПодробно) Тогда
			Сообщить("Ошибка загрузки шаблонов """ + ПутьКФайлу + """: "
				+ РезультатЧтения.ОшибкаПодробно, СтатусСообщения.Важное);
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	// parseSnippets преобразует формат .st в сниппеты редактора
	// unionSnippets = true — добавляем к существующим, а не заменяем
	View(Форма, ИмяПоляHTML).parseSnippets(РезультатЧтения.Содержимое, Истина);
	
КонецПроцедуры

// Загружает сниппеты из JSON строки.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   JSONСниппетов - Строка - JSON в формате {"snippets": {...}}
//   ИмяПоляHTML - Строка
//
// Возвращаемое значение:
//   Булево - успешность загрузки
//
// Пример JSON:
//   {
//     "snippets": {
//       "МойШаблон": {
//         "prefix": "МойШаблон",
//         "body": "Сообщить(\"${0:текст}\");",
//         "description": "Вывод сообщения"
//       }
//     }
//   }
//
Функция ЗагрузитьСниппетыИзJSON(Форма, JSONСниппетов, ИмяПоляHTML = Неопределено) Экспорт
	
	Попытка
		Результат = View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).updateSnippets(JSONСниппетов);
		Возврат (ТипЗнч(Результат) = Тип("Булево") И Результат);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Устанавливает тему редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяТемы - Строка - "СветлаяТема", "ТёмнаяТема", и т.д.
//   ИмяПоляHTML - Строка
//
Процедура УстановитьТему(Форма, ИмяТемы, ИмяПоляHTML = Неопределено) Экспорт
	
	ТемаРедактора = СоответствиеТем().Получить(ИмяТемы);
	Если ТемаРедактора <> Неопределено Тогда
		View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).setTheme(ТемаРедактора);
	КонецЕсли;
	
КонецПроцедуры

// Включает/выключает режим "Только чтение".
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ТолькоЧтение - Булево
//   ИмяПоляHTML - Строка
//
Процедура УстановитьРежимТолькоЧтение(Форма, ТолькоЧтение, ИмяПоляHTML = Неопределено) Экспорт
	
	View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).setReadOnly(ТолькоЧтение);
	
КонецПроцедуры

// Устанавливает режим языка редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   РежимЯзыка - Строка - "bsl", "bsl_query", "dcs_query", "xml", "json", "yaml"
//   ИмяПоляHTML - Строка
//
// Пример:
//   конс_ПодключаемаяКонсольКлиент.УстановитьРежимЯзыка(ЭтаФорма, "json");
//
Процедура УстановитьРежимЯзыка(Форма, РежимЯзыка, ИмяПоляHTML = Неопределено) Экспорт
	
	View(Форма, ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML)).setLanguageMode(РежимЯзыка);
	
КонецПроцедуры

// Открывает форму настроек редактора.
//
Процедура ОткрытьНастройкиРедактора() Экспорт
	
	ОткрытьФорму("ОбщаяФорма.конс_НастройкиПодключаемойКонсолиКода");
	
КонецПроцедуры

#КонецОбласти

#Область ВыводВТабло

// Показывает результат выполнения в табло редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   JSONОписаниеПеременных - Строка - JSON с описанием переменных
//   ИмяПоляHTML - Строка
//
Процедура ПоказатьПеременныеВТабло(Форма, JSONОписаниеПеременных, ИмяПоляHTML = "HTML") Экспорт
	
	View(Форма, ИмяПоляHTML).showVariablesDescription(JSONОписаниеПеременных);
	
КонецПроцедуры

// Показывает переменные во всплывающих подсказках.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   JSONОписаниеПеременных - Строка - JSON с описанием переменных
//   ИмяПоляHTML - Строка
//
Процедура ПоказатьПеременныеВПодсказках(Форма, JSONОписаниеПеременных, ИмяПоляHTML = "HTML") Экспорт
	
	View(Форма, ИмяПоляHTML).setCustomHovers(JSONОписаниеПеременных);
	
	Если JSONОписаниеПеременных <> "{}" Тогда
		ПоказатьСообщениеВРедакторе(Форма, "Выполнено. Наведите курсор на переменную для просмотра значения", ИмяПоляHTML);
	КонецЕсли;
	
КонецПроцедуры

// Открывает форму вычисления/просмотра значения выражения.
// Работает только во время отладки, когда ВМ остановлена на точке останова.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   Выражение - Строка - текст выражения для вычисления. 
//       Если пустая строка - берётся выделенный текст из редактора.
//   ИмяПоляHTML - Строка
//
Процедура ВычислитьВыражение(Форма, Выражение = "", ИмяПоляHTML = Неопределено) Экспорт
	
	ИмяПоляHTML = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	
	Если Не ЗначениеЗаполнено(Параметры.АдресВМ) Тогда
		ПоказатьПредупреждение(, НСтр("ru = 'Вычисление выражения доступно только во время отладки (на точке останова)'; en = 'Expression evaluation is only available during debugging (at breakpoint)'"));
		Возврат;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Выражение) Тогда
		Выражение = ПолучитьВыделенныйТекст(Форма, ИмяПоляHTML);
	КонецЕсли;
	
	// Открываем JS-диалог вместо формы конс_Просмотрщик
	View(Форма, ИмяПоляHTML).showExpressionDialog(Выражение);
	
КонецПроцедуры

// Показывает сообщение в редакторе (через CodeLens).
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   Текст - Строка - текст сообщения
//   ИмяПоляHTML - Строка
//
Процедура ПоказатьСообщениеВРедакторе(Форма, Текст, ИмяПоляHTML = "HTML") Экспорт
	
	View(Форма, ИмяПоляHTML).setCustomCodeLenses("[{""lineNumber"": 1,""column"": 1,""text"": """ + Текст + """}]");
	
КонецПроцедуры

// Помечает строку с ошибкой в редакторе.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   НомерСтроки - Число - номер строки в инлайн-коде
//   НомерКолонки - Число
//   ИмяПоляHTML - Строка
//   НомерСтрокиОригинала - Число - номер строки в оригинальном коде (из маркера //@@N)
//
Процедура ПометитьОшибку(Форма, НомерСтроки, НомерКолонки = 1, ИмяПоляHTML = "HTML", НомерСтрокиОригинала = 0) Экспорт
	
	Если НомерСтрокиОригинала > 0 Тогда
		View(Форма, ИмяПоляHTML).markError(НомерСтрокиОригинала, НомерКолонки);
	ИначеЕсли НомерСтроки > 0 Тогда
		View(Форма, ИмяПоляHTML).markError(НомерСтроки, НомерКолонки);
	КонецЕсли;
	
КонецПроцедуры

// Получает имена переменных из кода в редакторе.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
// Возвращаемое значение:
//   Массив - массив имен переменных
//
Функция ПолучитьИменаПеременных(Форма, ИмяПоляHTML = "HTML") Экспорт
	
	Результат = Новый Массив;
	
	Попытка
		Переменные = View(Форма, ИмяПоляHTML).getVarsNames();
		
		Если Переменные <> Неопределено И Переменные.length > 0 Тогда
			Для Индекс = 0 По Переменные.length - 1 Цикл
				Результат.Добавить(Переменные["" + Индекс + ""]);
			КонецЦикла;
		КонецЕсли;
	Исключение
		// Игнорируем ошибку
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Показывает ошибку в редакторе.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ТекстОшибки - Строка
//   НомерСтроки - Число - номер строки с ошибкой в инлайн-коде (0 - не выделять)
//   НомерКолонки - Число
//   ИмяПоляHTML - Строка
//   НомерСтрокиОригинала - Число - номер строки в оригинальном коде (из маркера //@@N)
//
Процедура ПоказатьОшибку(Форма, ТекстОшибки, НомерСтроки = 0, НомерКолонки = 1, ИмяПоляHTML = "HTML", НомерСтрокиОригинала = 0) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстОшибки;
	Сообщение.Сообщить();
	
	// Если есть оригинальный номер строки (из маркера //@@N), используем его
	Если НомерСтрокиОригинала > 0 Тогда
		View(Форма, ИмяПоляHTML).markError(НомерСтрокиОригинала, НомерКолонки);
	ИначеЕсли НомерСтроки > 0 Тогда
		View(Форма, ИмяПоляHTML).markError(НомерСтроки, НомерКолонки);
	КонецЕсли;
	
КонецПроцедуры

// Очищает маркеры ошибок.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
Процедура ОчиститьМаркерыОшибок(Форма, ИмяПоляHTML = "HTML") Экспорт
	
	View(Форма, ИмяПоляHTML).setCustomCodeLenses("[]");
	
КонецПроцедуры

#КонецОбласти

#Область ПросмотрПеременныхДереваФормы

// Обновляет дерево отображения переменных формы (ДанныеФормыДерево).
// Используется формой конс_Просмотрщик для отображения результатов вычисления выражений.
//
// Параметры:
//  Переменные - ДанныеФормыДерево - дерево переменных для обновления
//  РежимРаботы - Строка - "Сервер"
//  ВычислениеВыражения - Булево - признак вычисления произвольных выражений
//  МассивВыражений - Массив - массив выражений для вычисления
//  Адрес - Строка - адрес временного хранилища (серверный режим)
//  ДанныеПеременных - Произвольный - не используется (совместимость)
//  АдресВМ - Строка - адрес виртуальной машины во временном хранилище
//  ВиртуальнаяМашина - Произвольный - не используется (совместимость)
//  ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы
//  УровеньСтекаВызовов - Число - текущий уровень стека вызовов
//  РазрешеноДобавление - Булево - разрешено ли добавление новых строк
//
Процедура ОбновитьОтображениеПеременных(Переменные,
										РежимРаботы,
										ВычислениеВыражения,
										МассивВыражений,
										Адрес,
										ДанныеПеременных,
										АдресВМ,
										ВиртуальнаяМашина,
										ИдентификаторФормы,
										УровеньСтекаВызовов,
										РазрешеноДобавление = Истина) Экспорт
	
	СоответствиеСтруктурПеременных = конс_ПодключаемаяКонсольВызовСервера.ПолучитьСоответствиеСтруктурПеременных(
		Адрес, ВычислениеВыражения, МассивВыражений, АдресВМ, ИдентификаторФормы, УровеньСтекаВызовов);
	
	Строки                = Переменные.ПолучитьЭлементы();
	СоответствиеВыражений = Новый Соответствие;
	
	Для Каждого СтрокаДерева Из Строки Цикл
		СоответствиеВыражений.Вставить(СтрокаДерева.Свойство, Истина);
		Если СоответствиеСтруктурПеременных[СтрокаДерева.Свойство] = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗаполнитьДанныеСтрокиДереваПеременныхФормы(СтрокаДерева.Свойство, СоответствиеСтруктурПеременных[СтрокаДерева.Свойство], СтрокаДерева,, РазрешеноДобавление);
	КонецЦикла;
	
	Для Каждого ЭлементСоответствия Из СоответствиеСтруктурПеременных Цикл
		Если СоответствиеВыражений[ЭлементСоответствия.Ключ] = Неопределено Тогда
			ЗаполнитьДанныеСтрокиДереваПеременныхФормы(ЭлементСоответствия.Ключ, ЭлементСоответствия.Значение,, Строки, РазрешеноДобавление);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Загружает подчинённые свойства переменной при раскрытии узла дерева.
//
// Параметры:
//  Переменные - ДанныеФормыДерево - дерево переменных
//  Адрес - Строка - адрес временного хранилища
//  ДанныеПеременных - Произвольный - не используется (совместимость)
//  РежимРаботы - Строка - "Сервер"
//  Элемент - ЭлементФормы - элемент формы
//  Строка - Число - идентификатор раскрываемой строки
//  Отказ - Булево - флаг отмены раскрытия
//
Процедура ПеременныеПередРазворачиванием(Переменные, Адрес, ДанныеПеременных, РежимРаботы, Элемент, Строка, Отказ) Экспорт
	
	ТекДанные         = Переменные.НайтиПоИдентификатору(Строка);
	ПодчиненныеСтроки = ТекДанные.ПолучитьЭлементы();
	
	Если ЗначениеЗаполнено(ПодчиненныеСтроки[0].ИмяПеременной) Тогда
		Возврат;
	КонецЕсли;
	
	стПеременная = ПолучитьСтруктуруПеременнойДерева(ТекДанные.ИмяПеременной, Адрес, ТекДанные.Путь, ТекДанные.ПутьПоИндексу);
	
	Если стПеременная = Неопределено Тогда
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	
	Сч             = 0;
	КолПодчиненных = стПеременная.Подчиненные.Количество();
	
	Пока Сч < КолПодчиненных Цикл
		Если Сч <> 0 Тогда
			Стр = ПодчиненныеСтроки.Добавить();
		Иначе
			Стр = ПодчиненныеСтроки[0];
		КонецЕсли;
		
		ЗаполнитьПодчиненнуюСтрокуДереваФормы(Стр, стПеременная.Подчиненные[Сч], ТекДанные, Сч, Адрес);
		
		Сч = Сч + 1;
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, является ли тип ссылочным для отображения через ПоказатьЗначение().
//
// Параметры:
//  ИмяТипа - Строка - строковое представление типа
//
// Возвращаемое значение:
//  Булево - Истина, если тип является ссылочным
//
Функция ЭтоТипДляПоказаЗначения(ИмяТипа) Экспорт
	
	Если СтрНайти(ИмяТипа, ".") <> 0 Тогда
		Подстроки            = СтрРазделить(ИмяТипа, ".");
		ПодстрокаБазовыйТип = Подстроки[0];
		
		ИсключаемыеСсылочныеТипы = Новый Соответствие;
		ИсключаемыеСсылочныеТипы.Вставить("ПеречислениеСсылка", Истина);
		ИсключаемыеСсылочныеТипы.Вставить("EnumRef", Истина);
		
		Если (СтрЗаканчиваетсяНа(ПодстрокаБазовыйТип, "Ссылка") ИЛИ СтрЗаканчиваетсяНа(ПодстрокаБазовыйТип, "Ref"))
			И ИсключаемыеСсылочныеТипы[ПодстрокаБазовыйТип] = Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Показывает значение переменной в отдельном окне.
//
// Параметры:
//  ЭтаФорма - УправляемаяФорма
//  РежимРаботы - Строка
//  Адрес - Строка - адрес временного хранилища
//  ДанныеПеременных - Произвольный
//  ДанныеДляПередачи - Произвольный
//  ТекущиеДанные - ДанныеФормыЭлементДерева
//
Процедура ПоказатьЗначениеПеременнойОтдельно(ЭтаФорма, РежимРаботы, Адрес, ДанныеПеременных, ДанныеДляПередачи, ТекущиеДанные) Экспорт
	
	Если ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТекущиеДанные.Тип = "Строка" ИЛИ ТекущиеДанные.Тип = "String" Тогда
		ПоказатьСтроковоеЗначениеОтдельноФорма(ТекущиеДанные);
	ИначеЕсли ТекущиеДанные.ЭтоКоллекция Тогда
		ПоказатьКоллекциюОтдельноФорма(ЭтаФорма, Адрес, ТекущиеДанные);
	ИначеЕсли ЭтоТипДляПоказаЗначения(ТекущиеДанные.Тип) Тогда
		ПоказатьСсылочноеЗначениеОтдельноФорма(Адрес, ТекущиеДанные);
	КонецЕсли;
	
КонецПроцедуры

// --- Служебные процедуры просмотра переменных ---

Процедура ЗаполнитьДанныеСтрокиДереваПеременныхФормы(ИмяПеременной, СтруктураПеременной, СтрокаДерева = Неопределено, ДеревоПеременных = Неопределено, РазрешеноДобавление = Истина)
	
	Если СтрокаДерева = Неопределено Тогда
		Если РазрешеноДобавление Тогда
			СтрокаДерева = ДеревоПеременных.Добавить();
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(СтрокаДерева, СтруктураПеременной);
	
	СтрокаДерева.ИмяПеременной = ИмяПеременной;
	
	Если СтруктураПеременной.ЭтоКоллекция И СтруктураПеременной.Количество <> Неопределено Тогда
		СтрокаДерева.Значение = СтрокаДерева.Значение + " (" + Формат(СтруктураПеременной.Количество, "ЧН=0; ЧГ=0;") + ")";
	КонецЕсли;
	
	Строки = СтрокаДерева.ПолучитьЭлементы();
	Строки.Очистить();
	
	Если СтруктураПеременной.Код = 3 ИЛИ СтруктураПеременной.Код = 2 И СтруктураПеременной.Подчиненные.Количество() > 0 Тогда
		Строки.Добавить();
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьСтруктуруПеременнойДерева(ИмяПеременной, Адрес, Путь, ПутьПоИндексу)
	
	Возврат конс_ПодключаемаяКонсольВызовСервера.ПолучитьСтруктуруПеременнойНаСервере(ИмяПеременной, Адрес, Путь, ПутьПоИндексу);
	
КонецФункции

Процедура ЗаполнитьПодчиненнуюСтрокуДереваФормы(Стр, ТекущееПодчиненноеСвойство, ТекДанные, Сч, Адрес)
	
	ЗаполнитьЗначенияСвойств(Стр, ТекущееПодчиненноеСвойство);
	
	Если ТекущееПодчиненноеСвойство.ЭтоКоллекция И ТекущееПодчиненноеСвойство.Количество <> Неопределено Тогда
		Стр.Значение = Стр.Значение + " (" + Формат(ТекущееПодчиненноеСвойство.Количество, "ЧН=0; ЧГ=0;") + ")";
	КонецЕсли;
	
	Стр.ИмяПеременной = ТекДанные.ИмяПеременной;
	Стр.Путь          = ТекДанные.Путь + "." + ТекущееПодчиненноеСвойство.Свойство;
	Стр.ПутьПоИндексу = ТекДанные.ПутьПоИндексу + ?(ТекДанные.ЭтоКоллекция, "[" + Формат(Сч, "ЧН=0; ЧГ=0") + "]", "." + ТекущееПодчиненноеСвойство.Свойство);
	
	// Добавляем узел раскрытия при необходимости
	Если ТекущееПодчиненноеСвойство.Код = 3 Тогда // Коллекция
		Стр.ПолучитьЭлементы().Добавить();
	ИначеЕсли ТекущееПодчиненноеСвойство.Код = 2 Тогда // Объект с подчинёнными
		ПутьПодчиненного          = ТекДанные.Путь + "." + ТекущееПодчиненноеСвойство.Свойство;
		ПутьПоИндексуПодчиненного = ТекДанные.ПутьПоИндексу + ?(ТекДанные.ЭтоКоллекция, "[" + Формат(Сч, "ЧН=0; ЧГ=0") + "]", "." + ТекущееПодчиненноеСвойство.Свойство);
		стПодчиненныйОбъект       = ПолучитьСтруктуруПеременнойДерева(ТекДанные.ИмяПеременной, Адрес, ПутьПодчиненного, ПутьПоИндексуПодчиненного);
		Если стПодчиненныйОбъект <> Неопределено И стПодчиненныйОбъект.Подчиненные.Количество() <> 0 Тогда
			Стр.ПолучитьЭлементы().Добавить();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ПоказатьСтроковоеЗначениеОтдельноФорма(ТекущиеДанные)
	
	// Показываем строковое значение в JS-диалоге
	// Для обратной совместимости: если нет доступа к View, используем ПоказатьПредупреждение
	ЗначениеСтроки = Сред(ТекущиеДанные.Значение, 2, СтрДлина(ТекущиеДанные.Значение) - 2);
	ПоказатьПредупреждение(, ЗначениеСтроки);
	
КонецПроцедуры

Процедура ПоказатьКоллекциюОтдельноФорма(ЭтаФорма, Адрес, ТекущиеДанные)
	
	// Показ коллекции через ПоказатьПредупреждение для обратной совместимости
	ПоказатьПредупреждение(, НСтр("ru = 'Просмотр коллекции доступен из панели отладки'; en = 'Collection view is available from the debug panel'"));
	
КонецПроцедуры

Процедура ПоказатьСсылочноеЗначениеОтдельноФорма(Адрес, ТекущиеДанные)
	
	ЗначениеСсылки = конс_ПодключаемаяКонсольВызовСервера.ПолучитьЗначениеПеременнойНаСервере(
		Адрес, ТекущиеДанные.ИмяПеременной, ТекущиеДанные.Путь, ТекущиеДанные.ПутьПоИндексу);
	
	ПоказатьЗначение(, ЗначениеСсылки);
	
КонецПроцедуры

#КонецОбласти

#Область РаботаСОшибками

// Создает структуру описания ошибки выполнения из ИнформацияОбОшибке.
// 
// Параметры:
//   ИнфоОшибки - ИнформацияОбОшибке - объект ошибки из блока Исключение
//
// Возвращаемое значение:
//   Структура - Описание ошибки:
//     * Описание - Строка - текст ошибки
//     * НомерСтроки - Число - номер строки (0 если неизвестно)
//     * НомерКолонки - Число - номер колонки (1 по умолчанию)
//     * ИмяМодуля - Строка - имя модуля где произошла ошибка
//     * ИсходнаяСтрока - Строка - исходный код строки с ошибкой
//     * Причина - Структура, Неопределено - вложенная ошибка (причина)
//
// Пример:
//   Попытка
//       Выполнить(Код);
//   Исключение
//       ОписаниеОшибки = конс_ПодключаемаяКонсольКлиент.РазобратьИнформациюОбОшибке(ИнформацияОбОшибке());
//       конс_ПодключаемаяКонсольКлиент.ПоказатьОшибкуВыполнения(ЭтаФорма, ОписаниеОшибки);
//   КонецПопытки;
//
Функция РазобратьИнформациюОбОшибке(ИнфоОшибки) Экспорт
	
	// Используем общую логику с РазобратьИнформациюОбОшибкеКлиент
	Возврат РазобратьИнформациюОбОшибкеКлиент(ИнфоОшибки);
	
КонецФункции

// Создает пустую структуру описания ошибки.
// Делегирует в общий клиент-серверный модуль.
// 
// Возвращаемое значение:
//   Структура - Пустое описание ошибки
//
Функция НовоеОписаниеОшибки() Экспорт
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.НовоеОписаниеОшибки();
	
КонецФункции

// Показывает ошибку выполнения в редакторе.
// Принимает структуру описания ошибки от РазобратьИнформациюОбОшибке().
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ОписаниеОшибки - Структура - описание ошибки (см. РазобратьИнформациюОбОшибке)
//   ПоказыватьПричину - Булево - показывать ли первопричину вместо верхнего уровня
//   ИмяПоляHTML - Строка
//
// Пример:
//   Попытка
//       Выполнить(Код);
//   Исключение
//       ОписаниеОшибки = конс_ПодключаемаяКонсольКлиент.РазобратьИнформациюОбОшибке(ИнформацияОбОшибке());
//       конс_ПодключаемаяКонсольКлиент.ПоказатьОшибкуВыполнения(ЭтаФорма, ОписаниеОшибки, Истина);
//   КонецПопытки;
//
Процедура ПоказатьОшибкуВыполнения(Форма, ОписаниеОшибки, ПоказыватьПричину = Истина, ИмяПоляHTML = Неопределено) Экспорт
	
	ИмяПоля = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	
	// Очищаем предыдущие маркеры
	ОчиститьМаркерыОшибок(Форма, ИмяПоля);
	
	// Формируем полное описание ошибки со стеком
	ТекстОшибки = СформироватьТекстОшибкиСоСтеком(ОписаниеОшибки);
	
	// Показываем сообщение
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстОшибки;
	Сообщение.Сообщить();
	
	// Помечаем строку в редакторе - используем НомерСтрокиОригинала из маркера если есть
	НомерСтроки = ОписаниеОшибки.НомерСтроки;
	НомерКолонки = ОписаниеОшибки.НомерКолонки;
	
	// Если в описании ошибки уже есть оригинальный номер строки (из маркера //@@N), используем его
	Если ОписаниеОшибки.Свойство("НомерСтрокиОригинала") И ОписаниеОшибки.НомерСтрокиОригинала > 0 Тогда
		View(Форма, ИмяПоля).markError(ОписаниеОшибки.НомерСтрокиОригинала, НомерКолонки);
	ИначеЕсли НомерСтроки > 0 Тогда
		View(Форма, ИмяПоля).markError(НомерСтроки, НомерКолонки);
	КонецЕсли;
	
КонецПроцедуры

// Формирует текст ошибки со стеком вызовов.
// 
// Параметры:
//   ОписаниеОшибки - Структура - описание ошибки
//
// Возвращаемое значение:
//   Строка - текст ошибки со стеком
//
Функция СформироватьТекстОшибкиСоСтеком(ОписаниеОшибки) Экспорт
	
	// Извлекаем чистый текст ошибки (без позиции)
	ТекстОшибки = ИзвлечьЧистыйТекстОшибки(ОписаниеОшибки.Описание);
	
	// Стек вызовов уже собран при парсинге
	Если ОписаниеОшибки.Свойство("СтекВызовов") И ОписаниеОшибки.СтекВызовов.Количество() > 0 Тогда
		ТекстОшибки = ТекстОшибки + Символы.ПС + Символы.ПС + "Стек вызовов:";
		Для Каждого ЭлементСтека Из ОписаниеОшибки.СтекВызовов Цикл
			ТекстОшибки = ТекстОшибки + Символы.ПС + "  " + ЭлементСтека;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Извлекает чистый текст ошибки без позиции {Модуль(строка,колонка)}:
//
Функция ИзвлечьЧистыйТекстОшибки(ОписаниеОшибки)
	
	Текст = ОписаниеОшибки;
	
	// Убираем префикс вида {Модуль(строка,колонка)}:
	ПозицияДвоеточия = СтрНайти(Текст, "}:");
	Если ПозицияДвоеточия > 0 И Лев(Текст, 1) = "{" Тогда
		Текст = СокрЛ(Сред(Текст, ПозицияДвоеточия + 2));
	КонецЕсли;
	
	Возврат Текст;
	
КонецФункции

// Получает корневую (первоначальную) причину ошибки.
// 
// Параметры:
//   ОписаниеОшибки - Структура - описание ошибки
//
// Возвращаемое значение:
//   Структура - Корневая причина ошибки
//
Функция ПолучитьКорневуюПричину(ОписаниеОшибки) Экспорт
	
	Если ОписаниеОшибки = Неопределено Или ОписаниеОшибки.Причина = Неопределено Тогда
		Возврат ОписаниеОшибки;
	КонецЕсли;
	
	Возврат ПолучитьКорневуюПричину(ОписаниеОшибки.Причина);
	
КонецФункции

#КонецОбласти

#Область Отладка

// Начинает отладку кода из редактора.
// Компилирует код и запускает виртуальную машину.
// Выполнение останавливается на первой точке останова.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
Процедура НачатьОтладку(Форма, ИмяПоляHTML = Неопределено, ПредварительныеЛексемыJSON = "") Экспорт
	
	Имя = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	
	// Если уже в отладке — завершаем предыдущий сеанс
	Если ЗначениеЗаполнено(Параметры.АдресВМ) Тогда
		ЗавершитьОтладку(Форма, ИмяПоляHTML);
	КонецЕсли;
	
	ИсходныйКод = ПолучитьТекст(Форма, ИмяПоляHTML);
	
	Если Не ЗначениеЗаполнено(ИсходныйКод) Тогда
		ПоказатьПредупреждение(, "Нет кода для выполнения!");
		Возврат;
	КонецЕсли;
	
	// Компилируем и инициализируем ВМ на сервере
	// Передаём адрес значений переменных для контекста отладчика (если были добавлены через ДобавитьПеременную)
	АдресЗначенийПеременных = "";
	Если Параметры.Свойство("АдресЗначенийПеременных") Тогда
		АдресЗначенийПеременных = Параметры.АдресЗначенийПеременных;
	КонецЕсли;
	
	РезультатКомпиляции = конс_ПодключаемаяКонсольВызовСервера.СкомпилироватьИЗапуститьОтладку(
		ИсходныйКод, Форма.УникальныйИдентификатор, АдресЗначенийПеременных, ПредварительныеЛексемыJSON);
	
	Если Не РезультатКомпиляции.Успех Тогда
		Если РезультатКомпиляции.Ошибки.Количество() > 0 Тогда
			ПерваяОшибка = РезультатКомпиляции.Ошибки[0];
			View(Форма, Имя).markError(ПерваяОшибка.Строка, 1);
			ПоказатьПредупреждение(, "Ошибка компиляции: " + ПерваяОшибка.Название);
		Иначе
			ПоказатьПредупреждение(, "Ошибка компиляции");
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Параметры.АдресВМ = РезультатКомпиляции.АдресВМ;
	Параметры.АдресПеременных = РезультатКомпиляции.АдресПеременных;
	
	// Заполняем соответствие всех номеров строк (для пошагового выполнения)
	ЗаполнитьСоответствиеВсехСтрок(Форма, Имя);
	
	// Включаем режим отладки в Monaco
	View(Форма, Имя).setDebugMode(1);
	
	// Запускаем до первой точки останова
	ВыполнитьШагОтладки(Форма, ПолучитьСоответствиеТочекОстанова(Форма, Имя), Имя);
	
КонецПроцедуры

// Продолжает выполнение до следующей точки останова.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
Процедура ПродолжитьОтладку(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	Имя = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	ВыполнитьШагОтладки(Форма, ПолучитьСоответствиеТочекОстанова(Форма, Имя), Имя);
	
КонецПроцедуры

// Выполняет один шаг отладки (шагнуть в).
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
Процедура ШагнутьВ(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	Имя = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	ВыполнитьШагОтладки(Форма, Форма.конс_СтруктураПараметровРедактораКода.СоответствиеНомеровСтрок, Имя);
	
КонецПроцедуры

// Выполняет шаг отладки "шагнуть через" (F10).
// Переходит на следующую строку без захода в процедуры/функции.
// Если в вызываемой процедуре есть точка останова — остановится на ней.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
Процедура ШагнутьЧерез(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	Имя = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	
	// Получаем текущую глубину стека вызовов
	СостояниеВМ = конс_ПодключаемаяКонсольВызовСервера.ПолучитьСостояниеОтладки(Параметры.АдресВМ);
	Глубина = СостояниеВМ.ГлубинаСтекаВызовов;
	
	// Передаём точки останова + ограничение глубины
	ВыполнитьШагОтладки(Форма, ПолучитьСоответствиеТочекОстанова(Форма, Имя), Имя, Глубина);
	
КонецПроцедуры

// Завершает сеанс отладки.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка
//
Процедура ЗавершитьОтладку(Форма, ИмяПоляHTML = Неопределено) Экспорт
	
	Имя = ПолучитьИмяПоляHTML(Форма, ИмяПоляHTML);
	Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	
	View(Форма, Имя).deleteCurrentDebugLine();
	View(Форма, Имя).setDebugMode(0);
	
	Если ЗначениеЗаполнено(Параметры.АдресВМ) Тогда
		Попытка
			конс_ПодключаемаяКонсольВызовСервера.ЗавершитьОтладку(Параметры.АдресВМ);
		Исключение
			// Игнорируем ошибки при завершении
		КонецПопытки;
	КонецЕсли;
	
	Параметры.АдресВМ = "";
	Параметры.АдресПеременных = "";
	
	ПоказатьОповещениеПользователя("Отладка", , "Отладка прервана");
	
КонецПроцедуры

// Переключает режим остановки по ошибке.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ЗначениеФлага - Строка - "1" или "0"
//
Процедура ПереключитьОстановкуПоОшибке(Форма, ЗначениеФлага)
	
	Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	Параметры.ОстановкаПоОшибке = (ЗначениеФлага = "1");
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ОбратнаяСовместимость

// Устаревшая. Использовать ПодключитьРедактор.
Процедура НачатьИнициализациюРедактора(Форма, ИмяПоляHTML = "HTML", ОписаниеОповещенияОЗавершении = Неопределено) Экспорт
	
	КонтекстИнициализации = Новый Структура;
	КонтекстИнициализации.Вставить("Форма", Форма);
	КонтекстИнициализации.Вставить("ИмяПоляHTML", ИмяПоляHTML);
	КонтекстИнициализации.Вставить("ОписаниеОповещенияОЗавершении", ОписаниеОповещенияОЗавершении);
	
	Оповещение = Новый ОписаниеОповещения("ПослеПодключенияРасширенияФайлов", ЭтотОбъект, КонтекстИнициализации);
	НачатьПодключениеРасширенияРаботыСФайлами(Оповещение);
	
КонецПроцедуры

// Устаревшая. Использовать ОбработчикДокументСформирован.
Процедура ОбработчикOnReady(Форма, ИмяПоляHTML = "HTML") Экспорт
	
	Если Форма.конс_СтруктураПараметровРедактораКода.ИсходникиЗагружены Тогда
		#Если ВебКлиент Тогда
			Если ВебДокументДоступен(Форма, ИмяПоляHTML) Тогда
				ИнициализироватьРедакторКлиент(Форма, ИмяПоляHTML);
			КонецЕсли;
		#Иначе
			ИнициализироватьРедакторКлиент(Форма, ИмяПоляHTML);
		#КонецЕсли
	КонецЕсли;
	
КонецПроцедуры

// Устаревшая. Использовать ОбработчикПриНажатии.
Процедура ОбработчикOnClick(Форма, ДанныеСобытия, ИмяПоляHTML = "HTML") Экспорт
	
	Если ДанныеСобытия <> Неопределено И ДанныеСобытия.Event <> Неопределено Тогда
		Событие = ДанныеСобытия.Event.eventData1C;
		Если Событие <> Неопределено Тогда
			ОбработатьСобытиеРедактора(Форма, Событие, ИмяПоляHTML);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиОповещений

Процедура ПослеПодключенияРасширенияФайлов(Подключено, КонтекстИнициализации) Экспорт
	
	Если Подключено Тогда
		НачатьИзвлечениеИсходников(КонтекстИнициализации);
	Иначе
		#Если ВебКлиент Тогда
			// Для веб-клиента попробуем использовать внешний URL
			ИспользоватьВнешнийURL(КонтекстИнициализации);
		#Иначе
			ПоказатьПредупреждение(, "Не удалось подключить расширение работы с файлами");
		#КонецЕсли
	КонецЕсли;
	
КонецПроцедуры

Процедура ПослеПолученияКаталогаВременныхФайлов(ИмяКаталога, КонтекстИнициализации) Экспорт
	
	КонтекстИнициализации.Вставить("КаталогИсходников", ИмяКаталога + "bsl_console\");
	Оповещение = Новый ОписаниеОповещения("ПослеСозданияКаталога", ЭтотОбъект, КонтекстИнициализации);
	НачатьСозданиеКаталога(Оповещение, КонтекстИнициализации.КаталогИсходников);
	
КонецПроцедуры

Процедура ПослеСозданияКаталога(ИмяКаталога, КонтекстИнициализации) Экспорт
	
	Оповещение = Новый ОписаниеОповещения("ПослеПроверкиСуществованияКаталога", ЭтотОбъект, КонтекстИнициализации);
	ФайлНаДиске = Новый Файл(КонтекстИнициализации.КаталогИсходников);
	ФайлНаДиске.НачатьПроверкуСуществования(Оповещение);
	
КонецПроцедуры

Процедура ПослеПроверкиСуществованияКаталога(Существует, КонтекстИнициализации) Экспорт
	
	Если Существует Тогда
		Оповещение = Новый ОписаниеОповещения("ПослеПроверкиСуществованияФайлаВерсии", ЭтотОбъект, КонтекстИнициализации);
		ВерсияОбработки = КонтекстИнициализации.Форма.конс_СтруктураПараметровРедактораКода.ВерсияОбработки;
		ФайлНаДиске = Новый Файл(КонтекстИнициализации.КаталогИсходников + ВерсияОбработки + ".ver");
		ФайлНаДиске.НачатьПроверкуСуществования(Оповещение);
	Иначе
		ПоказатьПредупреждение(, "Не удалось создать каталог для исходников");
	КонецЕсли;
	
КонецПроцедуры

Процедура ПослеПроверкиСуществованияФайлаВерсии(Существует, КонтекстИнициализации) Экспорт
	
	Если Существует Тогда
		Оповещение = Новый ОписаниеОповещения("ПослеПроверкиСуществованияИндексногоФайла", ЭтотОбъект, КонтекстИнициализации);
		ФайлНаДиске = Новый Файл(КонтекстИнициализации.КаталогИсходников + "index.html");
		ФайлНаДиске.НачатьПроверкуСуществования(Оповещение);
	Иначе
		ИзвлечьИсходникиНаКлиенте(КонтекстИнициализации);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПослеПроверкиСуществованияИндексногоФайла(Существует, КонтекстИнициализации) Экспорт
	
	Если Существует Тогда
		ИндексныйФайл = ИндексныйФайл(КонтекстИнициализации);
		Оповещение = Новый ОписаниеОповещения("ПослеКопированияИндексногоФайла", ЭтотОбъект, КонтекстИнициализации);
		НачатьКопированиеФайла(Оповещение, КонтекстИнициализации.КаталогИсходников + "index.html", ИндексныйФайл);
	Иначе
		ИзвлечьИсходникиНаКлиенте(КонтекстИнициализации);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПослеКопированияИндексногоФайла(СкопированныйФайл, КонтекстИнициализации) Экспорт
	
	Форма = КонтекстИнициализации.Форма;
	
	// Получаем путь к данным (имя реквизита) из элемента формы
	КонтекстПоля = ПолучитьКонтекстПоля(Форма, КонтекстИнициализации.ИмяПоляHTML);
	Если ЗначениеЗаполнено(КонтекстПоля.ПутьКДанным) Тогда
		Форма[КонтекстПоля.ПутьКДанным] = СкопированныйФайл;
	КонецЕсли;
	Форма.конс_СтруктураПараметровРедактораКода.ИсходникиЗагружены = Истина;
	
КонецПроцедуры

Процедура ПослеЗаписиФайлаМакета(КонтекстИнициализации) Экспорт
	
	Попытка
		Файл = Новый ЧтениеZipФайла(КонтекстИнициализации.КаталогИсходников + "bsl_console.zip");
		Файл.ИзвлечьВсе(КонтекстИнициализации.КаталогИсходников);
		
		ВерсияОбработки = КонтекстИнициализации.Форма.конс_СтруктураПараметровРедактораКода.ВерсияОбработки;
		ФайлВерсии = Новый ЗаписьТекста(КонтекстИнициализации.КаталогИсходников + ВерсияОбработки + ".ver");
		ФайлВерсии.ЗаписатьСтроку(XMLСтрока(конс_ПодключаемаяКонсольВызовСервера.ПолучитьТекущуюДатуСеанса()));
		ФайлВерсии.Закрыть();
		
		ИндексныйФайл = ИндексныйФайл(КонтекстИнициализации);
		Оповещение = Новый ОписаниеОповещения("ПослеКопированияИндексногоФайла", ЭтотОбъект, КонтекстИнициализации);
		НачатьКопированиеФайла(Оповещение, КонтекстИнициализации.КаталогИсходников + "index.html", ИндексныйФайл);
	Исключение
		ПоказатьПредупреждение(, "Не удалось извлечь исходники: " + ОписаниеОшибки());
	КонецПопытки;
	
КонецПроцедуры

Процедура ПослеУдаленияВременныхФайлов(КонтекстИнициализации) Экспорт
	
	Оповещение = Новый ОписаниеОповещения("ПослеЗаписиФайлаМакета", ЭтотОбъект, КонтекстИнициализации);
	ИмяФайла = КонтекстИнициализации.КаталогИсходников + "bsl_console.zip";
	ДанныеМакета = ПолучитьИзВременногоХранилища(КонтекстИнициализации.Форма.конс_СтруктураПараметровРедактораКода.АдресМакета);
	ДанныеМакета.НачатьЗапись(Оповещение, ИмяФайла);
	
КонецПроцедуры

#КонецОбласти

#Область ВспомогательныеФункции

// Получает объект defaultView документа HTML-редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с полем HTML
//   ЭлементИлиИмя - Строка, ЭлементФормы - элемент формы или его имя
//
// Возвращаемое значение:
//   Произвольный - объект defaultView документа
//
Функция View(Форма, ЭлементИлиИмя)
	
	Контекст = ПолучитьКонтекстПоля(Форма, ЭлементИлиИмя);
	
	Возврат Контекст.Элемент.Документ.defaultView;
	
КонецФункции

Функция ИндексныйФайл(КонтекстИнициализации)
	
	Возврат КонтекстИнициализации.КаталогИсходников + Формат(ТекущаяУниверсальнаяДатаВМиллисекундах(), "ЧГ=0") + ".html";
	
КонецФункции

Процедура НачатьИзвлечениеИсходников(КонтекстИнициализации)
	
	#Если ВебКлиент Тогда
		ИспользоватьВнешнийURL(КонтекстИнициализации);
	#Иначе
		Оповещение = Новый ОписаниеОповещения("ПослеПолученияКаталогаВременныхФайлов", ЭтотОбъект, КонтекстИнициализации);
		НачатьПолучениеКаталогаВременныхФайлов(Оповещение);
	#КонецЕсли
	
КонецПроцедуры

Процедура ИспользоватьВнешнийURL(КонтекстИнициализации)
	
	Форма = КонтекстИнициализации.Форма;
	
	// Получаем путь к данным (имя реквизита) из элемента формы
	КонтекстПоля = ПолучитьКонтекстПоля(Форма, КонтекстИнициализации.ИмяПоляHTML);
	Если ЗначениеЗаполнено(КонтекстПоля.ПутьКДанным) Тогда
		Форма[КонтекстПоля.ПутьКДанным] = "https://salexdv.github.io/bsl_console/src/index.html";
	КонецЕсли;
	Форма.конс_СтруктураПараметровРедактораКода.ИсходникиЗагружены = Истина;
	
КонецПроцедуры

Процедура ИзвлечьИсходникиНаКлиенте(КонтекстИнициализации)
	
	Оповещение = Новый ОписаниеОповещения("ПослеУдаленияВременныхФайлов", ЭтотОбъект, КонтекстИнициализации);
	НачатьУдалениеФайлов(Оповещение, КонтекстИнициализации.КаталогИсходников, "*.*");
	
КонецПроцедуры

Функция ВебДокументДоступен(Форма, ЭлементИлиИмя)
	
	Попытка
		Контекст = ПолучитьКонтекстПоля(Форма, ЭлементИлиИмя);
		Если Контекст.Элемент = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		Возврат Контекст.Элемент.Документ.defaultView <> Неопределено;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

Процедура ИнициализироватьРедакторКлиент(Форма, ИмяПоляHTML)
	
	Инфо = Новый СистемнаяИнформация;
	
	View(Форма, ИмяПоляHTML).init(Инфо.ВерсияПриложения);
	View(Форма, ИмяПоляHTML).setLanguageMode("bsl");
	View(Форма, ИмяПоляHTML).setOption("autoResizeEditorLayout", Истина);
	View(Форма, ИмяПоляHTML).setOption("renderQueryDelimiters", Истина);
	View(Форма, ИмяПоляHTML).setOption("generateModificationEvent", Истина);
	View(Форма, ИмяПоляHTML).hideScrollX();
	View(Форма, ИмяПоляHTML).hideScrollY();
	
	// Применяем настройки пользователя (из формы, если есть, или загружаем с сервера)
	Настройки = Неопределено;
	Попытка
		АдресНастроек = Форма.конс_СтруктураПараметровРедактораКода.АдресНастроек;
		Если ЗначениеЗаполнено(АдресНастроек) Тогда
			Настройки = ПолучитьИзВременногоХранилища(АдресНастроек);
		КонецЕсли;
	Исключение
		// Ошибка получения настроек
	КонецПопытки;
	
	Если Настройки = Неопределено Тогда
		Настройки = конс_ПодключаемаяКонсольВызовСервера.ПолучитьНастройкиИзХранилища();
	КонецЕсли;
	
	ПрименитьНастройки(Форма, Настройки, ИмяПоляHTML);
	
	// Обновляем список общих модулей
	ОбновитьСписокОбщихМодулей(Форма, ИмяПоляHTML);
	
	// Включаем поддержку отладки в редакторе
	View(Форма, ИмяПоляHTML).setUsingDebugger(Истина);
	
	// Предзагрузка таблиц переходов лексера и парсера в кэш сессии.
	// Таблицы строятся заранее (в фоне), чтобы к моменту запуска отладки
	// не тратить 7–10 секунд на десериализацию JSON и построение соответствий.
	конс_ПодключаемаяКонсольВызовСервера.ПредзагрузитьТаблицыПерехода();
	
КонецПроцедуры

Процедура ОбновитьСписокОбщихМодулей(Форма, ИмяПоляHTML)
	
	Попытка
		View(Форма, ИмяПоляHTML).clearMetadata();
		
		АдресОбщихМодулей = Форма.конс_СтруктураПараметровРедактораКода.АдресОбщихМодулей;
		Если ЗначениеЗаполнено(АдресОбщихМодулей) Тогда
			// Получаем JSON строку из хранилища
			ОбщиеМодулиJSON = ПолучитьИзВременногоХранилища(АдресОбщихМодулей);
			// Передаём JSON строку напрямую - updateMetadata ожидает JSON
			View(Форма, ИмяПоляHTML).updateMetadata(ОбщиеМодулиJSON, "commonModules.items");
		КонецЕсли;
	Исключение
		// Игнорируем ошибку - метаданные не критичны
		Возврат;
	КонецПопытки;
	
КонецПроцедуры

Функция СоответствиеТем()
	
	Темы = Новый Соответствие;
	Темы.Вставить("СветлаяТема", "bsl-white");
	Темы.Вставить("ТемнаяТема", "bsl-dark");
	Темы.Вставить("ТемнаяТемаПлюс", "hc-dark");
	Темы.Вставить("СветлаяТемаПлюс", "hc-light");
	
	Возврат Темы;
	
КонецФункции

#КонецОбласти

#Область ОбработкаСобытийРедактора

Процедура ОбработатьСобытиеРедактора(Форма, Событие, ИмяПоляHTML)
	
	Если Событие = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ИмяСобытия = Событие.event;
	
	Если ИмяСобытия = "EVENT_CONTENT_CHANGED" Тогда
		Форма.Модифицированность = Истина;
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_ON_LINK_CLICK" Тогда
		Если СтрНайти(Событие.params.href, "e1cib") > 0 Тогда
			ПерейтиПоНавигационнойСсылке(Событие.params.href);
		КонецЕсли;
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_GET_VARIABLE_DATA" Тогда
		ОбработатьСобытиеРаскрытияПеременной(Форма, Событие.params, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_GET_METADATA" Тогда
		ОбработатьСобытиеПолученияМетаданных(Форма, Событие.params, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_QUERY_CONSTRUCT" Тогда
		ОбработатьСобытиеКонструктораЗапроса(Форма, Событие.params, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_FORMAT_CONSTRUCT" Тогда
		ОбработатьСобытиеКонструктораФорматнойСтроки(Форма, Событие.params, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_START_DEBUGGING" Тогда
		ЛексемыJSON = Событие.params;
		НачатьОтладку(Форма, ИмяПоляHTML, ЛексемыJSON);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_CONTINUE_DEBUGGING" Тогда
		ПродолжитьОтладку(Форма, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_STEP_INTO" Тогда
		ШагнутьВ(Форма, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_STEP_OVER" Тогда
		ШагнутьЧерез(Форма, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_STOP_DEBUGGING" Тогда
		ЗавершитьОтладку(Форма, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_TOGGLE_STOP_ON_ERROR" Тогда
		ПереключитьОстановкуПоОшибке(Форма, Событие.params);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_EVALUATE_EXPRESSION" Тогда
		ВычислитьВыражение(Форма, Строка(Событие.params), ИмяПоляHTML);
	КонецЕсли;
	
	// --- События JS-диалогов отладки ---
	
	Если ИмяСобытия = "EVENT_DIALOG_EVALUATE" Тогда
		ОбработатьСобытиеДиалогаВычисления(Форма, Событие.params, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_DIALOG_GET_VARIABLE_DATA" Тогда
		ОбработатьСобытиеРаскрытияПеременнойВДиалоге(Форма, Событие.params, ИмяПоляHTML);
	КонецЕсли;
	
	Если ИмяСобытия = "EVENT_DIALOG_GET_COLLECTION_PAGE" Тогда
		ОбработатьСобытиеСтраницыКоллекции(Форма, Событие.params, ИмяПоляHTML);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьСобытиеПолученияМетаданных(Форма, Параметры, ИмяПоляHTML)
	
	ПараметрыЗапроса = НРег(Параметры.metadata);
	Триггер = Параметры.trigger;
	ДанныеОбновлены = Ложь;
	
	// Проверяем, не запрос ли это модуля (общего или объекта/менеджера)
	Если СтрНачинаетсяС(ПараметрыЗапроса, "module.") Тогда
		// Попытка загрузки модуля из исходников
		ДанныеОбновлены = ЗагрузитьМодульИзИсходников(Форма, ПараметрыЗапроса, ИмяПоляHTML);
		
		// Если модуль загружен, завершаем обработку
		Если ДанныеОбновлены Тогда
			Если Триггер = "suggestion" Тогда
				View(Форма, ИмяПоляHTML).triggerSuggestions();
			КонецЕсли;
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	// Получаем данные метаданных с сервера
	РезультатЗапроса = конс_ПодключаемаяКонсольВызовСервера.ПолучитьДанныеМетаданныхПоЗапросу(ПараметрыЗапроса);
	
	Если РезультатЗапроса <> Неопределено И ЗначениеЗаполнено(РезультатЗапроса.Данные) Тогда
		
		Результат = View(Форма, ИмяПоляHTML).updateMetadata(
			РезультатЗапроса.Данные,
			РезультатЗапроса.АдресОбновления
		);
		
		ДанныеОбновлены = (ТипЗнч(Результат) = Тип("Булево") И Результат);
		
	КонецЕсли;
	
	// Вызываем автодополнение, если это был триггер suggestion
	Если Триггер = "suggestion" И ДанныеОбновлены Тогда
		View(Форма, ИмяПоляHTML).triggerSuggestions();
	КонецЕсли;
	
	// Обновляем сниппет, если это был триггер snippet
	Если Триггер = "snippet" Тогда
		Попытка
			View(Форма, ИмяПоляHTML).updateSnippetByGUID(Параметры.snippet_guid);
		Исключение
			// Метод может отсутствовать
		КонецПопытки;
	КонецЕсли;
	
КонецПроцедуры

// Загружает модуль из файлов исходного кода конфигурации.
// Поддерживает форматы:
//   - module.ИмяОбщегоМодуля (2 части) - общий модуль
//   - module.manager.КоллекцияМетаданных.ИмяОбъекта (4 части) - модуль менеджера
//   - module.object.КоллекцияМетаданных.ИмяОбъекта (4 части) - модуль объекта
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ПараметрыЗапроса - Строка - строка запроса модуля
//   ИмяПоляHTML - Строка
//
// Возвращаемое значение:
//   Булево - Истина, если модуль успешно загружен
//
Функция ЗагрузитьМодульИзИсходников(Форма, ПараметрыЗапроса, ИмяПоляHTML)
	
	// Получаем путь к исходникам из настроек
	КаталогИсходногоКода = ПолучитьПутьКИсходникамКонфигурации(Форма);
	
	Если Не ЗначениеЗаполнено(КаталогИсходногоКода) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Разбираем запрос на части
	ЧастиЗапроса = СтрРазделить(ПараметрыЗапроса, ".");
	КоличествоЧастей = ЧастиЗапроса.Количество();
	
	Если КоличествоЧастей < 2 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Определяем тип модуля по количеству частей и второму элементу
	Если КоличествоЧастей = 2 Тогда
		// Общий модуль: module.ИмяМодуля
		Возврат ЗагрузитьОбщийМодульИзИсходников(Форма, КаталогИсходногоКода, ЧастиЗапроса[1], ИмяПоляHTML);
		
	ИначеЕсли КоличествоЧастей = 4 Тогда
		// Модуль менеджера или объекта: module.manager|object.КоллекцияМетаданных.ИмяОбъекта
		ТипМодуля = НРег(ЧастиЗапроса[1]);
		
		Если ТипМодуля = "manager" Или ТипМодуля = "object" Тогда
			Возврат ЗагрузитьМодульМенеджераИлиОбъектаИзИсходников(
				Форма, КаталогИсходногоКода, ТипМодуля, ЧастиЗапроса[2], ЧастиЗапроса[3], ИмяПоляHTML);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Загружает общий модуль из исходников.
Функция ЗагрузитьОбщийМодульИзИсходников(Форма, КаталогИсходногоКода, ИмяМодуля, ИмяПоляHTML)
	
	// Получаем текст модуля с сервера (сервер читает файл)
	РезультатЗагрузки = конс_ПодключаемаяКонсольВызовСервера.ПрочитатьТекстОбщегоМодуля(КаталогИсходногоКода, ИмяМодуля);
	
	Если РезультатЗагрузки = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	// Парсим модуль редактором
	Попытка
		РезультатПарсинга = View(Форма, ИмяПоляHTML).parseCommonModule(РезультатЗагрузки.ИмяМодуля, РезультатЗагрузки.ТекстМодуля, РезультатЗагрузки.Глобальный);
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Загружает модуль менеджера или объекта из исходников.
Функция ЗагрузитьМодульМенеджераИлиОбъектаИзИсходников(Форма, КаталогИсходногоКода, ТипМодуля, КоллекцияМетаданных, ИмяОбъекта, ИмяПоляHTML)
	
	// Получаем текст модуля с сервера (сервер читает файл)
	РезультатЗагрузки = конс_ПодключаемаяКонсольВызовСервера.ПрочитатьТекстМодуляОбъекта(
		КаталогИсходногоКода, ТипМодуля, КоллекцияМетаданных, ИмяОбъекта);
	
	Если РезультатЗагрузки = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Парсим модуль редактором
	Попытка
		РезультатПарсинга = View(Форма, ИмяПоляHTML).parseMetadataModule(РезультатЗагрузки.ТекстМодуля, РезультатЗагрузки.АдресЗагрузки);
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Получает путь к исходникам конфигурации из настроек.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//
// Возвращаемое значение:
//   Строка - путь к каталогу с исходниками или пустая строка
//
Функция ПолучитьПутьКИсходникамКонфигурации(Форма)
	
	Попытка
		АдресНастроек = Форма.конс_СтруктураПараметровРедактораКода.АдресНастроек;
		Если Не ЗначениеЗаполнено(АдресНастроек) Тогда
			Возврат "";
		КонецЕсли;
		
		Настройки = ПолучитьИзВременногоХранилища(АдресНастроек);
		Если Настройки = Неопределено Тогда
			Возврат "";
		КонецЕсли;
		
		ПутьКИсходникам = "";
		Если Настройки.Свойство("ПутьКИсходникамКонфигурации") Тогда
			ПутьКИсходникам = Настройки.ПутьКИсходникамКонфигурации;
		КонецЕсли;
		
		// Нормализуем путь
		Если ЗначениеЗаполнено(ПутьКИсходникам) Тогда
			РазделительПути = ПолучитьРазделительПути();
			ПутьКИсходникам = СокрЛП(ПутьКИсходникам);
			Если Прав(ПутьКИсходникам, 1) <> РазделительПути Тогда
				ПутьКИсходникам = ПутьКИсходникам + РазделительПути;
			КонецЕсли;
		КонецЕсли;
		
		Возврат ПутьКИсходникам;
		
	Исключение
		Возврат "";
	КонецПопытки;
	
КонецФункции

Процедура ОбработатьСобытиеРаскрытияПеременной(Форма, Параметры, ИмяПоляHTML)
	
	ИмяПеременной = Параметры.variableName;
	ИдентификаторПеременной = Параметры.variableId;
	ПутьКДанным = Параметры.variablePath;
	
	// Очищаем путь от undefined
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "undefined", "");
	
	// Получаем адрес хранения переменных из структуры параметров
	АдресХраненияПеременных = "";
	Попытка
		// Сначала проверяем адрес табло отладки, затем общий адрес
		СтруктураПараметров = Форма.конс_СтруктураПараметровРедактораКода;
		Если СтруктураПараметров.Свойство("АдресХраненияТабло")
			И ЗначениеЗаполнено(СтруктураПараметров.АдресХраненияТабло) Тогда
			АдресХраненияПеременных = СтруктураПараметров.АдресХраненияТабло;
		Иначе
			АдресХраненияПеременных = СтруктураПараметров.АдресХраненияПеременных;
		КонецЕсли;
	Исключение
		Возврат;
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(АдресХраненияПеременных) Тогда
		Возврат;
	КонецЕсли;
	
	// Раскрываем переменную на сервере
	Описание = конс_ПодключаемаяКонсольВызовСервера.РаскрытьПеременнуюВТабло(
		АдресХраненияПеременных,
		ИдентификаторПеременной,
		ИмяПеременной,
		ПутьКДанным
	);
	
	Если ЗначениеЗаполнено(Описание) И Описание <> "{}" Тогда
		View(Форма, ИмяПоляHTML).updateVariableDescription(ИдентификаторПеременной, Описание);
	КонецЕсли;
	
КонецПроцедуры

// Обрабатывает событие вычисления выражения из JS-диалога (EVENT_DIALOG_EVALUATE).
// Вычисляет выражение на сервере и возвращает результат в JS.
Процедура ОбработатьСобытиеДиалогаВычисления(Форма, Параметры, ИмяПоляHTML)
	
	Выражение = Параметры.expression;
	Если Не ЗначениеЗаполнено(Выражение) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПараметров = Форма.конс_СтруктураПараметровРедактораКода;
	АдресВМ = СтруктураПараметров.АдресВМ;
	
	Если Не ЗначениеЗаполнено(АдресВМ) Тогда
		View(Форма, ИмяПоляHTML).updateExpressionResult("{}", "Вычисление невозможно: нет активного контекста отладки");
		Возврат;
	КонецЕсли;
	
	Результат = конс_ПодключаемаяКонсольВызовСервера.ВычислитьВыражениеВJSON(АдресВМ, Выражение);
	
	// Сохраняем адрес хранилища для раскрытия подчинённых
	Если ЗначениеЗаполнено(Результат.АдресХраненияТабло) Тогда
		СтруктураПараметров.Вставить("АдресХраненияДиалога", Результат.АдресХраненияТабло);
	КонецЕсли;
	
	View(Форма, ИмяПоляHTML).updateExpressionResult(Результат.JSON);
	
КонецПроцедуры

// Обрабатывает событие раскрытия переменной в JS-диалоге (EVENT_DIALOG_GET_VARIABLE_DATA).
// Раскрывает подчинённый узел дерева в диалоге выражений.
Процедура ОбработатьСобытиеРаскрытияПеременнойВДиалоге(Форма, Параметры, ИмяПоляHTML)
	
	ИмяПеременной = Параметры.variableName;
	ИдентификаторПеременной = Параметры.variableId;
	ПутьКДанным = Параметры.variablePath;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "undefined", "");
	
	// Берём адрес хранилища диалога, если есть, иначе адрес табло
	СтруктураПараметров = Форма.конс_СтруктураПараметровРедактораКода;
	АдресХраненияПеременных = "";
	
	Попытка
		Если СтруктураПараметров.Свойство("АдресХраненияДиалога")
			И ЗначениеЗаполнено(СтруктураПараметров.АдресХраненияДиалога) Тогда
			АдресХраненияПеременных = СтруктураПараметров.АдресХраненияДиалога;
		ИначеЕсли СтруктураПараметров.Свойство("АдресХраненияТабло")
			И ЗначениеЗаполнено(СтруктураПараметров.АдресХраненияТабло) Тогда
			АдресХраненияПеременных = СтруктураПараметров.АдресХраненияТабло;
		Иначе
			АдресХраненияПеременных = СтруктураПараметров.АдресХраненияПеременных;
		КонецЕсли;
	Исключение
		Возврат;
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(АдресХраненияПеременных) Тогда
		Возврат;
	КонецЕсли;
	
	Описание = конс_ПодключаемаяКонсольВызовСервера.РаскрытьПеременнуюВТабло(
		АдресХраненияПеременных,
		ИдентификаторПеременной,
		ИмяПеременной,
		ПутьКДанным
	);
	
	Если ЗначениеЗаполнено(Описание) И Описание <> "{}" Тогда
		View(Форма, ИмяПоляHTML).updateDialogSubtree(ИдентификаторПеременной, Описание);
	КонецЕсли;
	
КонецПроцедуры

// Обрабатывает событие запроса страницы коллекции из JS-диалога (EVENT_DIALOG_GET_COLLECTION_PAGE).
Процедура ОбработатьСобытиеСтраницыКоллекции(Форма, Параметры, ИмяПоляHTML)
	
	Адрес = Параметры.address;
	НомерСтраницы = Параметры.page;
	РазмерСтраницы = Параметры.pageSize;
	
	Если Не ЗначениеЗаполнено(Адрес) Тогда
		Возврат;
	КонецЕсли;
	
	JSONДанных = конс_ПодключаемаяКонсольВызовСервера.ПолучитьСтраницуКоллекцииJSON(
		Адрес, НомерСтраницы, РазмерСтраницы);
	
	View(Форма, ИмяПоляHTML).updateCollectionPage(JSONДанных);
	
КонецПроцедуры

#Область КонструкторЗапроса

Процедура ОбработатьСобытиеКонструктораЗапроса(Форма, ПараметрыЗапроса, ИмяПоляHTML)
	
	КонтекстВызова = Новый Структура("Форма, ИмяПоляHTML", Форма, ИмяПоляHTML);
	
	Если ПараметрыЗапроса = Неопределено Тогда
		Оповещение = Новый ОписаниеОповещения("ВопросСоздатьНовыйЗапросЗавершение", ЭтотОбъект, КонтекстВызова);
		ТекстВопроса = "Не найден текст запроса." + Символы.ПС + "Создать новый запрос?";
		ПоказатьВопрос(Оповещение, ТекстВопроса, РежимДиалогаВопрос.ДаНет);
	Иначе
		КонтекстВызова.Вставить("Range", ПараметрыЗапроса.range);
		ТекстЗапроса = ПодготовитьТекстЗапроса(ПараметрыЗапроса.text);
		ОткрытьКонструкторЗапросаВнутренний(ТекстЗапроса, КонтекстВызова);
	КонецЕсли;
	
КонецПроцедуры

Процедура ВопросСоздатьНовыйЗапросЗавершение(Ответ, КонтекстВызова) Экспорт
	
	Если Ответ = КодВозвратаДиалога.Да Тогда
		ОткрытьКонструкторЗапросаВнутренний("", КонтекстВызова);
	КонецЕсли;
	
КонецПроцедуры

Функция ПодготовитьТекстЗапроса(Текст)
	
	ТекстЗапроса = СтрЗаменить(Текст, "|", "");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, """""", "$");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, """", "");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "$", """");
	
	Возврат ТекстЗапроса;
	
КонецФункции

Процедура ОткрытьКонструкторЗапросаВнутренний(ТекстЗапроса, КонтекстВызова)
	
	Конструктор = Новый КонструкторЗапроса();
	
	Если ЗначениеЗаполнено(ТекстЗапроса) Тогда
		Попытка
			Конструктор.Текст = ТекстЗапроса;
		Исключение
			Инфо = ИнформацияОбОшибке();
			ПоказатьПредупреждение(, "Ошибка в тексте запроса:" + Символы.ПС + Инфо.Причина.Описание);
			Возврат;
		КонецПопытки;
	КонецЕсли;
	
	Оповещение = Новый ОписаниеОповещения("ПриЗакрытииКонструктораЗапросаЗавершение", ЭтотОбъект, КонтекстВызова);
	Конструктор.Показать(Оповещение);
	
КонецПроцедуры

Процедура ПриЗакрытииКонструктораЗапросаЗавершение(Текст, КонтекстВызова) Экспорт
	
	Если Текст <> Неопределено Тогда
		
		// Проверяем режим запроса
		Попытка
			РежимЗапроса = View(КонтекстВызова.Форма, КонтекстВызова.ИмяПоляHTML).queryMode;
		Исключение
			РежимЗапроса = Ложь;
		КонецПопытки;
		
		Если Не РежимЗапроса Тогда
			Текст = СтрЗаменить(Текст, Символы.ПС, Символы.ПС + "|");
			Текст = СтрЗаменить(Текст, """", """""");
			Текст = """" + Текст + """";
		КонецЕсли;
		
		Range = Неопределено;
		Если КонтекстВызова.Свойство("Range") Тогда
			Range = КонтекстВызова.Range;
		КонецЕсли;
		
		// Используем setText с позицией (range) для вставки в нужное место
		View(КонтекстВызова.Форма, КонтекстВызова.ИмяПоляHTML).setText(Текст, Range, Истина);
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область КонструкторФорматнойСтроки

Процедура ОбработатьСобытиеКонструктораФорматнойСтроки(Форма, ПараметрыСтроки, ИмяПоляHTML)
	
	КонтекстВызова = Новый Структура("Форма, ИмяПоляHTML", Форма, ИмяПоляHTML);
	
	Если ПараметрыСтроки = Неопределено Тогда
		Оповещение = Новый ОписаниеОповещения("ВопросСоздатьНовуюФорматнуюСтрокуЗавершение", ЭтотОбъект, КонтекстВызова);
		ТекстВопроса = "Форматная строка не найдена." + Символы.ПС + "Создать новую форматную строку?";
		ПоказатьВопрос(Оповещение, ТекстВопроса, РежимДиалогаВопрос.ДаНет);
	Иначе
		КонтекстВызова.Вставить("Range", ПараметрыСтроки.range);
		ФорматнаяСтрока = СтрЗаменить(СтрЗаменить(ПараметрыСтроки.text, "|", ""), """", "");
		ОткрытьКонструкторФорматнойСтрокиВнутренний(ФорматнаяСтрока, КонтекстВызова);
	КонецЕсли;
	
КонецПроцедуры

Процедура ВопросСоздатьНовуюФорматнуюСтрокуЗавершение(Ответ, КонтекстВызова) Экспорт
	
	Если Ответ = КодВозвратаДиалога.Да Тогда
		ОткрытьКонструкторФорматнойСтрокиВнутренний("", КонтекстВызова);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОткрытьКонструкторФорматнойСтрокиВнутренний(ФорматнаяСтрока, КонтекстВызова)
	
	Конструктор = Новый КонструкторФорматнойСтроки();
	
	Если ЗначениеЗаполнено(ФорматнаяСтрока) Тогда
		Попытка
			Конструктор.Текст = ФорматнаяСтрока;
		Исключение
			Инфо = ИнформацияОбОшибке();
			ПоказатьПредупреждение(, "Ошибка в тексте форматной строки:" + Символы.ПС + Инфо.Причина.Описание);
			Возврат;
		КонецПопытки;
	КонецЕсли;
	
	Оповещение = Новый ОписаниеОповещения("ПриЗакрытииКонструктораФорматнойСтрокиЗавершение", ЭтотОбъект, КонтекстВызова);
	Конструктор.Показать(Оповещение);
	
КонецПроцедуры

Процедура ПриЗакрытииКонструктораФорматнойСтрокиЗавершение(ФорматнаяСтрока, КонтекстВызова) Экспорт
	
	Если ФорматнаяСтрока <> Неопределено Тогда
		ФорматнаяСтрока = СтрЗаменить(ФорматнаяСтрока, "'", "");
		ФорматнаяСтрока = """" + ФорматнаяСтрока + """";
		
		Range = Неопределено;
		Если КонтекстВызова.Свойство("Range") Тогда
			Range = КонтекстВызова.Range;
		КонецЕсли;
		
		// Используем setText с позицией (range) для вставки в нужное место
		View(КонтекстВызова.Форма, КонтекстВызова.ИмяПоляHTML).setText(ФорматнаяСтрока, Range, Ложь);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ОтладкаСлужебные

Процедура ВыполнитьШагОтладки(Форма, ТочкиОстанова, ИмяПоляHTML, МаксимальнаяГлубинаОстановки = Неопределено)
	
	Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	
	// Снимаем подсветку текущей строки
	View(Форма, ИмяПоляHTML).deleteCurrentDebugLine();
	
	// Продолжаем выполнение ВМ на сервере
	Попытка
		конс_ПодключаемаяКонсольВызовСервера.ПродолжитьОтладку(
			Параметры.АдресВМ, Параметры.АдресПеременных, ТочкиОстанова, МаксимальнаяГлубинаОстановки, Параметры.ОстановкаПоОшибке);
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		
		// Пробуем получить состояние ВМ для отображения в панели
		СостояниеВМ = Неопределено;
		Если ЗначениеЗаполнено(Параметры.АдресВМ) Тогда
			Попытка
			СостояниеВМ = конс_ПодключаемаяКонсольВызовСервера.ПолучитьСостояниеОтладки(Параметры.АдресВМ);
			Исключение
			КонецПопытки;
		КонецЕсли;
		
		Если СостояниеВМ = Неопределено Тогда
			СостояниеВМ = Новый Структура;
			СостояниеВМ.Вставить("Ошибки", Новый Массив);
			СостояниеВМ.Вставить("Сообщения", Новый Массив);
		КонецЕсли;
		
		// Исключение = отладка завершена
		СостояниеВМ.Вставить("ОтладкаЗавершена", Истина);
		СостояниеВМ.Вставить("СтрокаТочкиОстанова", 0);
		
		// Добавляем текст ошибки если его нет в списке
		Если СостояниеВМ.Ошибки.Количество() = 0 Тогда
			СостояниеВМ.Ошибки.Добавить(Новый Структура("Тип,Название,Строка", 2, ТекстОшибки, 0));
		КонецЕсли;
		
		// Показываем панель с ошибкой и завершаем отладку
		ОбновитьИнтерфейсОтладки(Форма, СостояниеВМ, ИмяПоляHTML);
		Возврат;
	КонецПопытки;
	
	// Получаем состояние ВМ и обновляем интерфейс
	СостояниеВМ = конс_ПодключаемаяКонсольВызовСервера.ПолучитьСостояниеОтладки(Параметры.АдресВМ);
	ОбновитьИнтерфейсОтладки(Форма, СостояниеВМ, ИмяПоляHTML);
	
КонецПроцедуры

Процедура ОбновитьИнтерфейсОтладки(Форма, СостояниеВМ, ИмяПоляHTML)
	
	Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	СтрокаОстанова = СостояниеВМ.СтрокаТочкиОстанова;
	
	Если СтрокаОстанова <> 0 И Не СостояниеВМ.ОтладкаЗавершена Тогда
		// Остановились в точке останова или на шаге
		View(Форма, ИмяПоляHTML).setCurrentDebugLine(СтрокаОстанова);
		View(Форма, ИмяПоляHTML).revealLineInCenter(СтрокаОстанова);
		
		// Показываем панель отладки с переменными, сообщениями, ошибками и стеком вызовов
		ПоказатьПанельОтладки(Форма, СостояниеВМ, ИмяПоляHTML);
	Иначе
		// Выполнение завершено
		View(Форма, ИмяПоляHTML).deleteCurrentDebugLine();
		View(Форма, ИмяПоляHTML).setDebugMode(0);
		
		// Показываем панель ДО очистки адресов, чтобы переменные были доступны
		ПоказатьПанельОтладки(Форма, СостояниеВМ, ИмяПоляHTML);
		
		Параметры.АдресВМ = "";
		Параметры.АдресПеременных = "";
	КонецЕсли;
	
КонецПроцедуры

Процедура ПоказатьПанельОтладки(Форма, СостояниеВМ, ИмяПоляHTML)
	
	Параметры = Форма.конс_СтруктураПараметровРедактораКода;
	
	// Получаем переменные отладки
	ОписаниеПеременных = "{}";
	Если ЗначениеЗаполнено(Параметры.АдресПеременных) Тогда
		Попытка
			АдресХраненияТабло = "";
			ОписаниеПеременных = конс_ПодключаемаяКонсольВызовСервера.ПолучитьОписаниеПеременныхОтладки(
				Параметры.АдресПеременных, АдресХраненияТабло);
			Параметры.Вставить("АдресХраненияТабло", АдресХраненияТабло);
		Исключение
			ОписаниеПеременных = "{}";
		КонецПопытки;
	КонецЕсли;
	
	// Формируем массив сообщений
	МассивСообщений = Новый Массив;
	Для Каждого Сообщение Из СостояниеВМ.Сообщения Цикл
		Если ТипЗнч(Сообщение) = Тип("Структура") И Сообщение.Свойство("Текст") Тогда
			МассивСообщений.Добавить(Строка(Сообщение.Текст));
		Иначе
			МассивСообщений.Добавить(Строка(Сообщение));
		КонецЕсли;
	КонецЦикла;
	
	// Формируем массив ошибок
	МассивОшибок = Новый Массив;
	Для Каждого Ошибка Из СостояниеВМ.Ошибки Цикл
		Если ТипЗнч(Ошибка) = Тип("Структура") Тогда
			ОписаниеОшибки = Новый Структура;
			Если Ошибка.Свойство("Название") Тогда
				ОписаниеОшибки.Вставить("text", Строка(Ошибка.Название));
			КонецЕсли;
			Если Ошибка.Свойство("Строка") Тогда
				ОписаниеОшибки.Вставить("line", Ошибка.Строка);
			КонецЕсли;
			МассивОшибок.Добавить(ОписаниеОшибки);
		Иначе
			МассивОшибок.Добавить(Строка(Ошибка));
		КонецЕсли;
	КонецЦикла;
	
	// Формируем стек вызовов
	МассивСтека = Новый Массив;
	Если СостояниеВМ.Свойство("ПредставлениеСтекаВызовов") Тогда
		Для Каждого ФреймСтека Из СостояниеВМ.ПредставлениеСтекаВызовов Цикл
			Если ТипЗнч(ФреймСтека) = Тип("Структура") Тогда
				ОписаниеФрейма = Новый Структура;
				Если ФреймСтека.Свойство("Название") Тогда
					ОписаниеФрейма.Вставить("name", Строка(ФреймСтека.Название));
				КонецЕсли;
				Если ФреймСтека.Свойство("Строка") Тогда
					ОписаниеФрейма.Вставить("line", ФреймСтека.Строка);
				КонецЕсли;
				МассивСтека.Добавить(ОписаниеФрейма);
			Иначе
				МассивСтека.Добавить(Строка(ФреймСтека));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Собираем данные для панели
	ДанныеПанели = Новый Структура;
	ДанныеПанели.Вставить("variables", ОписаниеПеременных);
	ДанныеПанели.Вставить("messages", МассивСообщений);
	ДанныеПанели.Вставить("errors", МассивОшибок);
	ДанныеПанели.Вставить("callStack", МассивСтека);
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	ЗаписатьJSON(Запись, ДанныеПанели);
	
	View(Форма, ИмяПоляHTML).showDebugPanel(Запись.Закрыть());
	
КонецПроцедуры

Функция ПолучитьСоответствиеТочекОстанова(Форма, ИмяПоляHTML)
	
	Результат = Новый Соответствие;
	
	Попытка
		JSONСтрока = View(Форма, ИмяПоляHTML).getBreakpoints();
		МассивНомеров = РазобратьМассивЧиселИзJSON(JSONСтрока);
		Для Каждого НомерСтроки Из МассивНомеров Цикл
			Результат.Вставить(НомерСтроки, Истина);
		КонецЦикла;
	Исключение
		// Нет точек останова
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьСоответствиеВсехСтрок(Форма, ИмяПоляHTML)
	
	СоответствиеНомеровСтрок = Новый Соответствие;
	КоличествоСтрок = View(Форма, ИмяПоляHTML).getLineCount();
	
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		СоответствиеНомеровСтрок.Вставить(НомерСтроки, Истина);
	КонецЦикла;
	
	Форма.конс_СтруктураПараметровРедактораКода.СоответствиеНомеровСтрок = СоответствиеНомеровСтрок;
	
КонецПроцедуры

Функция РазобратьМассивЧиселИзJSON(СтрокаJSON)
	
	Результат = Новый Массив;
	
	Если Не ЗначениеЗаполнено(СтрокаJSON) Тогда
		Возврат Результат;
	КонецЕсли;
	
	// "[1,3,5]" → массив чисел
	Очищенная = СтрЗаменить(СтрЗаменить(СтрокаJSON, "[", ""), "]", "");
	Если Не ЗначениеЗаполнено(СокрЛП(Очищенная)) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Части = СтрРазделить(Очищенная, ",", Ложь);
	Для Каждого Часть Из Части Цикл
		Попытка
			Результат.Добавить(Число(СокрЛП(Часть)));
		Исключение
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область ВыполнениеКода

Функция ПолучитьТекстСКодомПросмотраПеременных(Форма, ИмяПоляHTML, РежимПоказаПеременных)
	
	Код = ПолучитьИнлайнТекст(Форма, ИмяПоляHTML);
	
	Если Не РежимПоказаПеременных = ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.НеОтображать") Тогда
		
		Переменные = View(Форма, ИмяПоляHTML).getVarsNames();
		
		Если Переменные.length > 0 Тогда
			
			ПС = Символы.ПС;
			
			Для Индекс = 0 По Переменные.length - 1 Цикл
				Имя = Переменные["" + Индекс + ""];
				Код = Код + ПС + "Попытка ЗначенияПеременных.Вставить(""" + Имя + """,Вычислить(""" + Имя + """)); Исключение КонецПопытки;" + ПС;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Код;
	
КонецФункции

Функция ВыполнитьКодНаКлиенте(Код, РежимПоказаПеременных)
	
	Результат = конс_ПодключаемаяКонсольВызовСервера.НовыйРезультатВыполнения();
	Результат.РежимПоказаПеременных = РежимПоказаПеременных;
	ЗначенияПеременных = Новый Структура;
	
	Попытка
		Выполнить(Код);
		Результат.Успешно = Истина;
		
		Попытка
			Если РежимПоказаПеременных = ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.ВТабло") Тогда
				АдресПеременных = "";
				Результат.ОписаниеПеременных = конс_ПодключаемаяКонсольВызовСервера.ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, АдресПеременных);
				Результат.АдресХраненияПеременных = АдресПеременных;
			ИначеЕсли РежимПоказаПеременных = ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.ВПодсказках") Тогда
				Результат.ОписаниеПеременных = конс_ПодключаемаяКонсольВызовСервера.ПолучитьОписаниеПеременныхДляПодсказок(ЗначенияПеременных);
			Иначе
				Результат.ОписаниеПеременных = "";
			КонецЕсли;
		Исключение
			Результат.ОписаниеПеременных = "";
		КонецПопытки;
		
	Исключение
		ИнфоОшибки = ИнформацияОбОшибке();
		Результат.ИсходнаяСтрока = ИнфоОшибки.ИсходнаяСтрока;
		Если ИнфоОшибки.Причина <> Неопределено Тогда
			Результат.ОписаниеОшибки = ИнфоОшибки.Причина.Описание;
		Иначе
			Результат.ОписаниеОшибки = ИнфоОшибки.Описание;
		КонецЕсли;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Процедура ОбработатьРезультатВыполнения(Форма, Результат, ИмяПоляHTML)
	
	// Устаревшая - для обратной совместимости
	ОбработатьРезультат(Форма, Результат, ИмяПоляHTML);
	
КонецПроцедуры

// Обрабатывает ошибку выполнения с использованием нового API
Процедура ОбработатьОшибкуВыполненияПубличный(Форма, Результат, ИмяПоляHTML)
	
	// Используем новую структурированную информацию об ошибке, если есть
	Если Результат.Свойство("ИнформацияОбОшибке") И Результат.ИнформацияОбОшибке <> Неопределено Тогда
		ПоказатьОшибкуВыполнения(Форма, Результат.ИнформацияОбОшибке, Истина, ИмяПоляHTML);
	Иначе
		// Старый способ через строку
		ОбработатьОшибкуВыполнения(Форма, Результат, ИмяПоляHTML);
	КонецЕсли;
	
КонецПроцедуры

// Старый метод обработки ошибок (для обратной совместимости)
Процедура ОбработатьОшибкуВыполнения(Форма, Результат, ИмяПоляHTML)
	
	Ошибка = РазобратьОшибку(Результат.ОписаниеОшибки);
	
	НомерСтроки = Ошибка.НомерСтроки;
	НомерКолонки = Ошибка.НомерКолонки;
	
	Если НомерСтроки = 0 Тогда
		НомерСтроки = ИзвлечьНомерСтрокиИзОписания(Результат.ОписаниеОшибки);
	КонецЕсли;
	
	// Извлекаем оригинальный номер строки из маркера //@@N в тексте ошибки
	НомерСтрокиОригинала = конс_ПодключаемаяКонсольКлиентСервер.ИзвлечьНомерСтрокиИзМаркера(Результат.ОписаниеОшибки);
	
	ПоказатьОшибку(Форма, Ошибка.ТекстОшибки, НомерСтроки, НомерКолонки, ИмяПоляHTML, НомерСтрокиОригинала);
	
КонецПроцедуры

// Обрабатывает успешное выполнение с показом переменных
Процедура ОбработатьУспешноеВыполнениеПубличный(Форма, Результат, ИмяПоляHTML)
	
	// Сохраняем адрес хранения переменных для последующего раскрытия
	Попытка
		Если Результат.Свойство("АдресХраненияПеременных") Тогда
			Форма.конс_СтруктураПараметровРедактораКода.АдресХраненияПеременных = Результат.АдресХраненияПеременных;
		КонецЕсли;
	Исключение
		// Ошибка сохранения
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(Результат.ОписаниеПеременных) Тогда
		ПоказатьСообщениеВРедакторе(Форма, "Код успешно выполнен", ИмяПоляHTML);
		Возврат;
	КонецЕсли;
	
	РежимПоказа = Результат.РежимПоказаПеременных;
	
	Если РежимПоказа = ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.ВТабло") Тогда
		ПоказатьПеременныеВТабло(Форма, Результат.ОписаниеПеременных, ИмяПоляHTML);
	ИначеЕсли РежимПоказа = ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.ВПодсказках") Тогда
		ПоказатьПеременныеВПодсказках(Форма, Результат.ОписаниеПеременных, ИмяПоляHTML);
	Иначе
		// Не отображать
	КонецЕсли;
	
КонецПроцедуры

// Старый метод (для обратной совместимости)
Процедура ОбработатьУспешноеВыполнение(Форма, Результат, ИмяПоляHTML)
	
	Если Не ЗначениеЗаполнено(Результат.ОписаниеПеременных) Тогда
		Возврат;
	КонецЕсли;
	
	Если Результат.РежимПоказаПеременных = ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.ВТабло") Тогда
		ПоказатьПеременныеВТабло(Форма, Результат.ОписаниеПеременных, ИмяПоляHTML);
		Возврат;
	КонецЕсли;
	
	Если Результат.РежимПоказаПеременных = ПредопределенноеЗначение("Перечисление.конс_РежимПоказаПеременных.ВПодсказках") Тогда
		View(Форма, ИмяПоляHTML).setCustomHovers(Результат.ОписаниеПеременных);
		Если Результат.ОписаниеПеременных <> "{}" Тогда
			View(Форма, ИмяПоляHTML).setCustomCodeLenses("[{""lineNumber"": 1,""column"": 1,""text"": ""Для просмотра значений наведите курсор на переменную""}]");
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция РазобратьОшибку(ОписаниеОшибки)
	
	Ошибка = Новый Структура("ТекстОшибки, НомерСтроки, НомерКолонки", ОписаниеОшибки, 0, 1);
	
	ПозицияРазделителя = СтрНайти(ОписаниеОшибки, ":");
	
	Если ПозицияРазделителя > 0 Тогда
		
		Ошибка.ТекстОшибки = СокрЛП(Сред(ОписаниеОшибки, ПозицияРазделителя + 1));
		
		СтрокаОшибки = Лев(ОписаниеОшибки, ПозицияРазделителя - 1);
		СтрокаОшибки = СтрЗаменить(СтрокаОшибки, "{", "");
		СтрокаОшибки = СтрЗаменить(СтрокаОшибки, "(", "");
		СтрокаОшибки = СтрЗаменить(СтрокаОшибки, ")", "");
		СтрокаОшибки = СтрЗаменить(СтрокаОшибки, "}", "");
		
		Подстроки = СтрЗаменить(СтрокаОшибки, ",", Символы.ПС);
		
		Ошибка.НомерСтроки = БезопасноеПреобразованиеВЧисло(СтрПолучитьСтроку(Подстроки, 1), 0);
		Ошибка.НомерКолонки = БезопасноеПреобразованиеВЧисло(СтрПолучитьСтроку(Подстроки, 2), 1);
		
	КонецЕсли;
	
	Возврат Ошибка;
	
КонецФункции

// Безопасно преобразует строку в число.
// Делегирует в общий клиент-серверный модуль.
//
Функция БезопасноеПреобразованиеВЧисло(Знач Строка, ЗначениеПоУмолчанию)
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.БезопасноеПреобразованиеВЧисло(Строка, ЗначениеПоУмолчанию);
	
КонецФункции

Функция ИзвлечьНомерСтрокиИзОписания(ОписаниеОшибки)
	
	НомерСтроки = 0;
	ОткрывающаяСкобка = СтрНайти(ОписаниеОшибки, "(");
	
	Если ОткрывающаяСкобка > 0 Тогда
		
		ЗакрывающаяСкобка = СтрНайти(ОписаниеОшибки, ")", , ОткрывающаяСкобка);
		
		Если ЗакрывающаяСкобка > 0 Тогда
			
			Позиция = Сред(ОписаниеОшибки, ОткрывающаяСкобка + 1, ЗакрывающаяСкобка - ОткрывающаяСкобка - 1);
			Подстроки = СтрРазделить(Позиция, ",");
			
			Если Подстроки.Количество() > 0 Тогда
				НомерСтроки = БезопасноеПреобразованиеВЧисло(Подстроки[0], 0);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат НомерСтроки;
	
КонецФункции

// Получает контекст элемента формы HTML-редактора.
// Принимает либо имя элемента (строку), либо сам элемент формы.
// Возвращает структуру с элементом, его именем и путём к данным.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с полем HTML
//   ЭлементИлиИмя - Строка, ЭлементФормы, Неопределено - элемент формы или его имя.
//                   Если Неопределено - берётся из реквизита конс_ИмяПоляHTML или "HTML"
//
// Возвращаемое значение:
//   Структура - контекст элемента:
//     * Элемент - ЭлементФормы - элемент формы типа ПолеHTML
//     * ИмяЭлемента - Строка - имя элемента на форме
//     * ПутьКДанным - Строка - путь к данным (имя реквизита формы)
//
Функция ПолучитьКонтекстПоля(Форма, ЭлементИлиИмя)
	
	Результат = Новый Структура("Элемент, ИмяЭлемента, ПутьКДанным", Неопределено, "", "");
	
	// Определяем элемент формы
	Если ТипЗнч(ЭлементИлиИмя) = Тип("Строка") Тогда
		// Передано имя элемента
		Результат.ИмяЭлемента = ЭлементИлиИмя;
		Результат.Элемент = Форма.Элементы.Найти(ЭлементИлиИмя);
	ИначеЕсли ЭлементИлиИмя = Неопределено Тогда
		// Не передано - берём из реквизита формы
		Результат.ИмяЭлемента = ПолучитьИмяПоляHTML(Форма, Неопределено);
		Результат.Элемент = Форма.Элементы.Найти(Результат.ИмяЭлемента);
	Иначе
		// Передан сам элемент формы
		Результат.Элемент = ЭлементИлиИмя;
		Результат.ИмяЭлемента = ЭлементИлиИмя.Имя;
	КонецЕсли;
	
	// Получаем путь к данным из структуры параметров (на клиенте свойство элемента недоступно)
	Попытка
		Результат.ПутьКДанным = Форма.конс_СтруктураПараметровРедактораКода.ПутьКДаннымПоляHTML;
	Исключение
		// Структура параметров не инициализирована
		Результат.ПутьКДанным = "";
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает имя поля HTML для формы.
// Принимает строку, элемент формы или Неопределено.
// Если передан элемент формы - возвращает его имя.
// Если передана строка - возвращает её.
// Если Неопределено - берёт из структуры параметров или возвращает "HTML".
//
Функция ПолучитьИмяПоляHTML(Форма, ЭлементИлиИмя)
	
	// Если передан элемент формы - вернём его имя
	Если ЭлементИлиИмя <> Неопределено И ТипЗнч(ЭлементИлиИмя) <> Тип("Строка") Тогда
		Возврат ЭлементИлиИмя.Имя;
	КонецЕсли;
	
	// Если передана строка - вернём её
	Если ЭлементИлиИмя <> Неопределено Тогда
		Возврат ЭлементИлиИмя;
	КонецЕсли;
	
	// Берём из структуры параметров формы
	Попытка
		РеквизитИмя = Форма.конс_СтруктураПараметровРедактораКода.ИмяПоляHTML;
		Если ЗначениеЗаполнено(РеквизитИмя) Тогда
			Возврат РеквизитИмя;
		КонецЕсли;
	Исключение
		// Реквизит отсутствует - это нормально
	КонецПопытки;
	
	Возврат "HTML";
	
КонецФункции

// Извлекает позицию из описания ошибки выполняемого кода.
// Делегирует в общий клиент-серверный модуль.
// Формат: {(строка,колонка)}:...
//
Функция ИзвлечьПозициюВыполняемогоКода(ОписаниеОшибки)
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.ИзвлечьПозициюВыполняемогоКода(ОписаниеОшибки);
	
КонецФункции

// Извлекает позицию из описания ошибки с именем модуля.
// Делегирует в общий клиент-серверный модуль.
// Формат: {<ИмяМодуля>(строка,колонка)}:...
// Например: {<Неизвестный модуль>(1,11)}:
//
Функция ИзвлечьПозициюИзМодульнойОшибки(ОписаниеОшибки)
	
	Возврат конс_ПодключаемаяКонсольКлиентСервер.ИзвлечьПозициюИзМодульнойОшибки(ОписаниеОшибки);
	
КонецФункции

#КонецОбласти

#КонецОбласти

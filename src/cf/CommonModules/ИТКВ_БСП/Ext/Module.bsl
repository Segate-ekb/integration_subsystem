#Область ПрограммныйИнтерфейс

Функция ЗапрешенныеКРедактированиюРеквизитыОбъекта(ИмяОбъекта) Экспорт
	
	Результат = Новый Массив;
	
	Если НЕ ИТКВ_БСППовтИсп.СуществуетПодсистема("СтандартныеПодсистемы.ЗапретРедактированияРеквизитовОбъектов") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если Поддерживается("3.1") Тогда
		
		ПараметрыФункции = Новый Массив;
		ПараметрыФункции.Добавить(ИмяОбъекта);
		
		Результат = ИТКВ_БСПКлиентСервер.ВыполнитьФункцию("ЗапретРедактированияРеквизитовОбъектов.БлокируемыеРеквизитыОбъекта", ПараметрыФункции);
		
	Иначе
		
		Модуль = ИТКВ_БСПКлиентСерверПовтИсп.ОбщийМодуль("ЗапретРедактированияРеквизитовОбъектовСлужебный");
		Если Модуль.ЗапретРедактированияПредусмотрен(ИмяОбъекта) Тогда
			
			МенеджерОбъекта = ИТКВ_Метаданные.МенеджерОбъектаПоПолномуИмени(ИмяОбъекта);
			Результат = МенеджерОбъекта.ПолучитьБлокируемыеРеквизитыОбъекта();
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ИспользуютсяДополнительныеРеквизиты(Ссылка) Экспорт
	
	Если НЕ ИТКВ_БСППовтИсп.СуществуетПодсистема("СтандартныеПодсистемы.Свойства") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПараметрыФункции = Новый Массив;
	ПараметрыФункции.Добавить(Ссылка);
	
	Возврат ИТКВ_БСПКлиентСервер.ВыполнитьФункцию("УправлениеСвойствами.ИспользоватьДопРеквизиты", ПараметрыФункции);
	
КонецФункции

Функция ИспользуютсяДополнительныеСведения(Ссылка) Экспорт
	
	Если Не ИТКВ_БСППовтИсп.СуществуетПодсистема("СтандартныеПодсистемы.Свойства") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПараметрыФункции = Новый Массив;
	ПараметрыФункции.Добавить(Ссылка);
	
	Возврат ИТКВ_БСПКлиентСервер.ВыполнитьФункцию("УправлениеСвойствами.ИспользоватьДопСведения", ПараметрыФункции);
	
КонецФункции

Функция СтруктураЗначенияСвойства() Экспорт
	
	Если АнглийскаяБСП() Тогда
		
		ПолеЗаголовок = "Title";
		ПолеТипЗначения = "ValueType";
		ПолеЭтоДополнительноеСведение = "IsAdditionalInfo";
		
		ПолеСвойство = "Property";
		ПолеЗначение = "Value";
		
	Иначе
		
		ПолеЗаголовок = "Заголовок";
		ПолеТипЗначения = "ТипЗначения";
		ПолеЭтоДополнительноеСведение = "ЭтоДополнительноеСведение";
		
		ПолеСвойство = "Свойство";
		ПолеЗначение = "Значение";
		
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("ПолеСвойство", ПолеСвойство);
	Результат.Вставить("ПолеЗначение", ПолеЗначение);
	
	Результат.Вставить("ПолеЗаголовок", ПолеЗаголовок);
	Результат.Вставить("ПолеТипЗначения", ПолеТипЗначения);
	Результат.Вставить("ПолеЭтоДополнительноеСведение", ПолеЭтоДополнительноеСведение);
	
	СписокСвойств = Новый Массив;
	СписокСвойств.Добавить(ПолеЗаголовок);
	СписокСвойств.Добавить(ПолеТипЗначения);
	СписокСвойств.Добавить(ПолеЭтоДополнительноеСведение);
	Результат.Вставить("Список", СтрСоединить(СписокСвойств, ","));
	
	Возврат Результат;
	
КонецФункции

Функция РаботаСВнешнимиРесурсамиЗаблокирована() Экспорт
	
	Если НЕ ИТКВ_БСППовтИсп.СуществуетПодсистема("СтандартныеПодсистемы.РегламентныеЗадания") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Поддерживается("3.0") Тогда
		ИмяМодуля = "РегламентныеЗаданияСервер";
	Иначе
		ИмяМодуля = "РегламентныеЗаданияСлужебный";
	КонецЕсли;
	
	Возврат ИТКВ_БСПКлиентСервер.ВыполнитьФункцию(ИмяМодуля + ".РаботаСВнешнимиРесурсамиЗаблокирована");
	
КонецФункции

Процедура РазблокироватьРаботуСВнешнимиРесурсами() Экспорт
	
	Если НЕ ИТКВ_БСППовтИсп.СуществуетПодсистема("СтандартныеПодсистемы.РегламентныеЗадания") Тогда
		Возврат;
	КонецЕсли;
	
	Если Поддерживается("3.0") Тогда
		ИмяМодуля = "РегламентныеЗаданияСервер";
	Иначе
		ИмяМодуля = "РегламентныеЗаданияСлужебный";
	КонецЕсли;
	
	ИТКВ_БСПКлиентСервер.ВыполнитьПроцедуру(ИмяМодуля + ".РазрешитьРаботуСВнешнимиРесурсами");
	
КонецПроцедуры

Функция РегламентноеЗаданиеДоступноПоФункциональнымОпциям(Задание, ЗависимостиЗаданий = Неопределено) Экспорт
	
	Если НЕ ИТКВ_БСППовтИсп.СуществуетПодсистема("СтандартныеПодсистемы.РегламентныеЗадания") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПараметрыФункции = Новый Массив;
	ПараметрыФункции.Добавить(Задание);
	ПараметрыФункции.Добавить(ЗависимостиЗаданий);
	
	Возврат ИТКВ_БСПКлиентСервер.ВыполнитьФункцию("РегламентныеЗаданияСлужебный.РегламентноеЗаданиеДоступноПоФункциональнымОпциям", ПараметрыФункции);
	
КонецФункции

Функция ДополнительнаяИнформацияПоРегламентномуЗаданию(ОбъектМетаданных) Экспорт
	
	ЗависимыеРегламентныеЗадания = ИТКВ_БСППовтИсп.РегламентныеЗаданияЗависимыеОтФункциональныхОпций();
	
	РаботаетСВнешнимиРесурсами = Ложь;
	ФункциональнаяОпция = "";
	ДоступноПоФункциональнымОпциям = Истина;
	ЗаданиеВМоделиСервиса = Ложь;
	
	ОписаниеРегламентногоЗадания = Неопределено;
	Если ЗависимыеРегламентныеЗадания <> Неопределено Тогда
		ОписаниеРегламентногоЗадания = ЗависимыеРегламентныеЗадания.Найти(ОбъектМетаданных, "РегламентноеЗадание");
	КонецЕсли;
	
	Если ОписаниеРегламентногоЗадания <> Неопределено Тогда
		
		ФункциональнаяОпция = ОписаниеРегламентногоЗадания.ФункциональнаяОпция;
		Если ТипЗнч(ФункциональнаяОпция) = Тип("ОбъектМетаданных") Тогда
			ФункциональнаяОпция = ФункциональнаяОпция.Имя;
		КонецЕсли;
		РаботаетСВнешнимиРесурсами = ОписаниеРегламентногоЗадания.РаботаетСВнешнимиРесурсами;
		
		ДоступноПоФункциональнымОпциям = РегламентноеЗаданиеДоступноПоФункциональнымОпциям(ОбъектМетаданных, ЗависимыеРегламентныеЗадания);
		
		РегламентныеЗаданияВМоделиСервиса = ИТКВ_БСППовтИсп.РегламентныеЗаданияВМоделиСервиса();
		ЗаданиеВМоделиСервиса = (РегламентныеЗаданияВМоделиСервиса.Получить(ОбъектМетаданных) <> Неопределено);
		
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("РаботаетСВнешнимиРесурсами", РаботаетСВнешнимиРесурсами);
	Результат.Вставить("ФункциональнаяОпция", ФункциональнаяОпция);
	Результат.Вставить("ДоступноПоФункциональнымОпциям", ДоступноПоФункциональнымОпциям);
	Результат.Вставить("ЗаданиеВМоделиСервиса", ЗаданиеВМоделиСервиса);
	
	Возврат Результат;
	
КонецФункции

Функция Поддерживается(Версия = Неопределено) Экспорт
	
	ВерсияБСП = ИТКВ_БСПВызовСервера.Версия();
	Если ВерсияБСП = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Версия = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат (ИТКВ_ОбщийКлиентСервер.СравнитьВерсии(ВерсияБСП, Версия) >= 0);
	
КонецФункции

Функция АнглийскаяБСП() Экспорт
	
	Возврат НЕ ИТКВ_Общий.ВариантВстроенногоЯзыкаРусский();
	
КонецФункции

#Область БезопасноеХранилище

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с хранилищем паролей.

// Записывает конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец - ПланОбменаСсылка
//           - СправочникСсылка
//           - Строка - ссылка на объект информационной базы,
//             представляющий объект-владелец сохраняемого пароля или строка до 128 символов.
//             Для объектов других типов в качестве владельца рекомендуется использовать ссылку на
//             элемент метаданных этого типа в справочнике ИдентификаторыОбъектовМетаданных
//             или ключ в виде строки с учетом имен подсистем.
//             Например, для БСП:
//               Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("РегистрСведений.АдресныеОбъекты");
//             если нужно 1 хранилище на подсистему БСП:
//               Владелец = "СтандартныеПодсистемы.УправлениеДоступом";
//             если нужно более 1 хранилища на подсистему БСП:
//               Владелец = "СтандартныеПодсистемы.УправлениеДоступом.<Уточнение>";
//  Данные  - Произвольный - данные помещаемые в безопасное хранилище. Неопределенно - удаляет все данные.
//            Для удаления данных по ключу следует использовать процедуру УдалитьДанныеИзБезопасногоХранилища.
//          - Структура - если параметр Ключ содержит Неопределено. Подробнее см. описание параметра Ключ
//  Ключ    - Строка       - ключ сохраняемых настроек, по умолчанию "Пароль".
//                           Ключ должен соответствовать правилам имен идентификаторов:
//                           1. Первым символом ключа должна быть буква или символ подчеркивания (_).
//                           2. Каждый из последующих символов может быть буквой, цифрой или символом подчеркивания (_). 
//            Неопределено - для добавления набора данных структурой, где ключ структуры - это имя ключа данных,
//            а значение - сохраняемые данные. Пример использования см. ниже.
//
// Пример:
//
//  Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
//      Если ТекущийПользовательМожетИзменятьПароль Тогда
//          УстановитьПривилегированныйРежим(Истина);
//          ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект.Ссылка, Логин, "Логин");
//          ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект.Ссылка, Пароль);
//          УстановитьПривилегированныйРежим(Ложь);
//      КонецЕсли;
//  КонецПроцедуры
// 
//  Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
//      Если ТекущийПользовательМожетИзменятьПароль Тогда
//          ЛогинИПароль = Новый Структура;
//          ЛогинИПароль.Вставить("Логин", Логин);
//          ЛогинИПароль.Вставить("Пароль", Пароль);
//          УстановитьПривилегированныйРежим(Истина);
//          ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект.Ссылка, ЛогинИПароль, Неопределено);
//          УстановитьПривилегированныйРежим(Ложь);
//      КонецЕсли;
//  КонецПроцедуры
//
Процедура ЗаписатьДанныеВБезопасноеХранилище(Владелец, Данные, Ключ = "Пароль") Экспорт
	
	ИТКВ_БСПКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец),
		СтрШаблон(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			           |параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Владелец, ТипЗнч(Владелец)));
			
	Если ЗначениеЗаполнено(Ключ) Тогда
		
		ИТКВ_БСПКлиентСервер.Проверить(ТипЗнч(Ключ) = Тип("Строка"),
			СтрШаблон(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			|параметр должен содержать строку; передано значение: %3 (тип %4).'"),
			"Ключ", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Ключ, ТипЗнч(Ключ)));
			
	Иначе
		
		ИТКВ_БСПКлиентСервер.Проверить(ТипЗнч(Данные) = Тип("Структура"),
			СтрШаблон(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			|Если Ключ = Неопределено, то параметр должен содержать структуру; передано значение: %3 (тип %4).'"),
			"Данные", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Данные, ТипЗнч(Данные)));
		
	КонецЕсли;
	
		БезопасноеХранилищеДанных = РегистрыСведений.ИТКВ_БезопасноеХранилищеДанных.СоздатьМенеджерЗаписи();

	БезопасноеХранилищеДанных.Владелец = Владелец;
	БезопасноеХранилищеДанных.Прочитать();
	
	Если Данные <> Неопределено Тогда
		
		Если БезопасноеХранилищеДанных.Выбран() Тогда
			
			ДанныеДляСохранения = БезопасноеХранилищеДанных.Данные.Получить();
			
			Если ТипЗнч(ДанныеДляСохранения) <> Тип("Структура") Тогда
				ДанныеДляСохранения = Новый Структура();
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Ключ) Тогда
				ДанныеДляСохранения.Вставить(Ключ, Данные);
			Иначе
				ИТКВ_БСПКлиентСервер.ДополнитьСтруктуру(ДанныеДляСохранения, Данные, Истина);
			КонецЕсли;
			
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Записать();
			
		Иначе
			
			ДанныеДляСохранения = ?(ЗначениеЗаполнено(Ключ), Новый Структура(Ключ, Данные), Данные);
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Владелец = Владелец;
			БезопасноеХранилищеДанных.Записать();
			
		КонецЕсли;
	Иначе
		
		БезопасноеХранилищеДанных.Удалить();
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает данные из безопасного хранилища.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владельцы   - Массив из ПланОбменаСсылка
//              - Массив из СправочникСсылка
//              - Массив из Строка - ссылки на объекты информационной базы,
//                  представляющих объекты-владельцы или уникальные строки(до 128 символов) владельцев данных.
//  Ключи       - Строка - содержит имя ключа данных или список имен ключей, указанных через запятую.
//              - Неопределено - будут возвращены все сохраненные данные переданных владельцев. 
//  ОбщиеДанные - Булево - Истина, если требуется в модели сервиса получить данные из общих данных в разделенном режиме.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//    * Ключ - ПланОбменаСсылка
//           - СправочникСсылка
//           - Строка - ссылка на объект информационной базы 
//                      или строка до 128 символов идентифицирующая владельца данных.
//    * Значение - Произвольный - если в параметре Ключи указан один ключ, 
//                                то возвращается его значение произвольного типа.
//               - Структура    - если в параметре Ключи указано несколько ключей или Неопределено, 
//                                где ключ структуры - это имя ключа сохраненных данных, 
//                                а значение - данные произвольного типа. Когда для ключа отсутствуют данные, 
//                                то значение содержит Неопределено.
//               - Неопределено - если данные по ключу отсутствуют.
//
// Пример:
//	Процедура РассылкаПриглашений(Пользователи)
//		
//			УстановитьПривилегированныйРежим(Истина);
//			ДанныеАвторизации  = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(Пользователи, "Логин, Пароль");
//			УстановитьПривилегированныйРежим(Ложь);
//			
//			Для каждого Пользователь Из Пользователи Цикл
//				ОтправитьПриглашение(Пользователь, ДанныеАвторизации[Пользователь]);
//			КонецЦикла;
//		
//	КонецПроцедуры
//
Функция ПрочитатьДанныеВладельцевИзБезопасногоХранилища(Владельцы, Ключи = "Пароль", ОбщиеДанные = Неопределено) Экспорт
	
	ИТКВ_БСПКлиентСервер.Проверить(ТипЗнч(Владельцы) = Тип("Массив"),
		СтрШаблон(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			           |параметр должен содержать массив; передано значение: %3 (тип %4).'"),
			"Владельцы", "ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища", Владельцы, ТипЗнч(Владельцы)));
	
	Результат = ДанныеИзБезопасногоХранилища(Владельцы, Ключи, ОбщиеДанные);
	
	Возврат Результат;
	
КонецФункции

// Возвращает данные из безопасного хранилища.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец    - ПланОбменаСсылка
//              - СправочникСсылка
//              - Строка - ссылка на объект информационной базы,
//                  представляющий объект-владелец сохраняемого пароля или уникальная строка(до 128 символов).
//  Ключи       - Строка - содержит список имен сохраненных данных, указанных через запятую.
//              - Неопределено - будут возвращены все сохраненные данные владельца.
//  ОбщиеДанные - Булево - Истина, если требуется в модели сервиса получить данные из общих данных в разделенном режиме.
// 
// Возвращаемое значение:
//  Произвольный, Структура, Неопределено - данные из безопасного хранилища. Если указан один ключ,
//                            то возвращается его значение, иначе структура.
//                            Если данные отсутствуют - Неопределенно.
//
// Пример:
//	Если ТекущийПользовательМожетИзменятьПароль Тогда
//		УстановитьПривилегированныйРежим(Истина);
//		Логин  = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ТекущийОбъект.Ссылка, "Логин");
//		Пароль = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ТекущийОбъект.Ссылка);
//		УстановитьПривилегированныйРежим(Ложь);
//	Иначе
//		Элементы.ГруппаЛогинИПароль.Видимость = Ложь;
//	КонецЕсли;
//	
//	УстановитьПривилегированныйРежим(Истина);
//	ЛогинИПароль  = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ТекущийОбъект.Ссылка, Неопределено);
//
Функция ПрочитатьДанныеИзБезопасногоХранилища(Владелец, Ключи = "Пароль", ОбщиеДанные = Неопределено) Экспорт
	
	Владельцы = ИТКВ_БСПКлиентСервер.ЗначениеВМассиве(Владелец);
	ДанныеВладельца = ПрочитатьДанныеВладельцевИзБезопасногоХранилища(Владельцы, Ключи, ОбщиеДанные);
	
	Результат = ДанныеВладельца[Владелец];
	
	Возврат Результат;
	
КонецФункции

// Удаляет конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец - ПланОбменаСсылка
//           - СправочникСсылка
//           - Строка - ссылка на объект информационной базы,
//               представляющий объект-владелец сохраняемого пароля или уникальная строка(до 128 символов).
//           - Массив - ссылки на объекты информационной базы для удаления данным по нескольким владельцам.
//  Ключи    - Строка - содержит список имен удаляемых данных, указанных через запятую. 
//               Неопределено - удаляет все данные.
//
// Пример:
//	Процедура ПередУдалением(Отказ)
//		
//		// Проверка значения свойства ОбменДанными.Загрузка отсутствует, так как удалять данные
//		// из безопасного хранилища нужно даже при удалении объекта при обмене данными.
//		
//		УстановитьПривилегированныйРежим(Истина);
//		ОбщегоНазначения.УдалитьДанныеИзБезопасногоХранилища(Ссылка);
//		УстановитьПривилегированныйРежим(Ложь);
//		
//	КонецПроцедуры
//
Процедура УдалитьДанныеИзБезопасногоХранилища(Владелец, Ключи = Неопределено) Экспорт
	
	ИТКВ_БСПКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец),
		СтрШаблон(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			           |параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.УдалитьДанныеИзБезопасногоХранилища", Владелец, ТипЗнч(Владелец)));
	
		БезопасноеХранилищеДанных = РегистрыСведений.ИТКВ_БезопасноеХранилищеДанных.СоздатьМенеджерЗаписи();

	Владельцы = ?(ТипЗнч(Владелец) = Тип("Массив"), Владелец, ИТКВ_БСПКлиентСервер.ЗначениеВМассиве(Владелец));
	
	Для Каждого ВладелецДанных Из Владельцы Цикл
		
		БезопасноеХранилищеДанных.Владелец = ВладелецДанных;
		БезопасноеХранилищеДанных.Прочитать();
		Если ТипЗнч(БезопасноеХранилищеДанных.Данные) = Тип("ХранилищеЗначения") Тогда
			ДанныеДляСохранения = БезопасноеХранилищеДанных.Данные.Получить();
			Если Ключи <> Неопределено И ТипЗнч(ДанныеДляСохранения) = Тип("Структура") Тогда
				СписокКлючей = СтрРазделить(Ключи, ",", Ложь);
				Если БезопасноеХранилищеДанных.Выбран() И СписокКлючей.Количество() > 0 Тогда
					Для Каждого КлючДляУдаления Из СписокКлючей Цикл
						Если ДанныеДляСохранения.Свойство(КлючДляУдаления) Тогда
							ДанныеДляСохранения.Удалить(КлючДляУдаления);
						КонецЕсли;
					КонецЦикла;
					ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
					БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
					БезопасноеХранилищеДанных.Записать();
					Возврат;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		БезопасноеХранилищеДанных.Удалить();
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ХранилищеНастроек

////////////////////////////////////////////////////////////////////////////////
// Сохранение, чтение и удаление настроек из хранилищ.

// Сохраняет настройку в хранилище общих настроек, как метод платформы Сохранить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта       - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек      - Строка           - см. синтакс-помощник платформы.
//   Настройки         - Произвольный     - см. синтакс-помощник платформы.
//   ОписаниеНастроек  - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя   - Строка           - см. синтакс-помощник платформы.
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Настройки,
			ОписаниеНастроек = Неопределено,
			ИмяПользователя = Неопределено,
			ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Настройки,
		ОписаниеНастроек,
		ИмяПользователя,
		ОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Сохраняет несколько настроек в хранилище общих настроек, как метод платформы Сохранить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
// 
// Параметры:
//   НесколькоНастроек - Массив - со значениями:
//     * Значение - Структура:
//         * Объект    - Строка       - см. параметр КлючОбъекта  в синтакс-помощнике платформы.
//         * Настройка - Строка       - см. параметр КлючНастроек в синтакс-помощнике платформы.
//         * Значение  - Произвольный - см. параметр Настройки    в синтакс-помощнике платформы.
//
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(НесколькоНастроек,
			ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из НесколькоНастроек Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, КлючНастроек(Элемент.Настройка), Элемент.Значение);
	КонецЦикла;
	
	Если ОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек, как метод платформы Загрузить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Кроме того, возвращает указанное значение по умолчанию, если настройки не существуют.
// Если нет права СохранениеДанныхПользователя, возвращается значение по умолчанию без ошибки.
//
// В возвращаемом значении очищаются ссылки на несуществующий объект в базе данных, а именно
// - возвращаемая ссылка заменяется на указанное значение по умолчанию;
// - из данных типа Массив ссылки удаляются;
// - у данных типа Структура и Соответствие ключ не меняется, а значение устанавливается Неопределено;
// - анализ значений в данных типа Массив, Структура, Соответствие выполняется рекурсивно.
//
// Параметры:
//   КлючОбъекта          - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек         - Строка           - см. синтакс-помощник платформы.
//   ЗначениеПоУмолчанию  - Произвольный     - значение, которое возвращается, если настройки не существуют.
//                                             Если не указано, возвращается значение Неопределено.
//   ОписаниеНастроек     - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя      - Строка           - см. синтакс-помощник платформы.
//
// Возвращаемое значение: 
//   Произвольный - см. синтакс-помощник платформы.
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
			ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища общих настроек, как метод платформы Удалить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, удаление пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта     - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//   КлючНастроек    - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//   ИмяПользователя - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек, как метод платформы Сохранить
// объекта СтандартноеХранилищеНастроекМенеджер, но с поддержкой длины ключа настроек
// более 128 символов путем хеширования части, которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта       - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек      - Строка           - см. синтакс-помощник платформы.
//   Настройки         - Произвольный     - см. синтакс-помощник платформы.
//   ОписаниеНастроек  - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя   - Строка           - см. синтакс-помощник платформы.
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек, Настройки,
			ОписаниеНастроек = Неопределено,
			ИмяПользователя = Неопределено,
			ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(ХранилищеСистемныхНастроек, 
		КлючОбъекта,
		КлючНастроек,
		Настройки,
		ОписаниеНастроек,
		ИмяПользователя,
		ОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек, как метод платформы Загрузить,
// объекта СтандартноеХранилищеНастроекМенеджер, но с поддержкой длины ключа настроек
// более 128 символов путем хеширования части, которая превышает 96 символов.
// Кроме того, возвращает указанное значение по умолчанию, если настройки не существуют.
// Если нет права СохранениеДанныхПользователя, возвращается значение по умолчанию без ошибки.
//
// В возвращаемом значении очищаются ссылки на несуществующий объект в базе данных, а именно:
// - возвращаемая ссылка заменяется на указанное значение по умолчанию;
// - из данных типа Массив ссылки удаляются;
// - у данных типа Структура и Соответствие ключ не меняется, а значение устанавливается Неопределено;
// - анализ значений в данных типа Массив, Структура, Соответствие выполняется рекурсивно.
//
// Параметры:
//   КлючОбъекта          - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек         - Строка           - см. синтакс-помощник платформы.
//   ЗначениеПоУмолчанию  - Произвольный     - значение, которое возвращается, если настройки не существуют.
//                                             Если не указано, возвращается значение Неопределено.
//   ОписаниеНастроек     - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя      - Строка           - см. синтакс-помощник платформы.
//
// Возвращаемое значение: 
//   Произвольный - см. синтакс-помощник платформы.
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
			ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища системных настроек, как метод платформы Удалить,
// объекта СтандартноеХранилищеНастроекМенеджер, но с поддержкой длины ключа настроек
// более 128 символов путем хеширования части, которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, удаление пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта     - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//   КлючНастроек    - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//   ИмяПользователя - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм, как метод платформы Сохранить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта       - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек      - Строка           - см. синтакс-помощник платформы.
//   Настройки         - Произвольный     - см. синтакс-помощник платформы.
//   ОписаниеНастроек  - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя   - Строка           - см. синтакс-помощник платформы.
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек, Настройки,
			ОписаниеНастроек = Неопределено,
			ИмяПользователя = Неопределено, 
			ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		Настройки,
		ОписаниеНастроек,
		ИмяПользователя,
		ОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм, как метод платформы Загрузить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Кроме того, возвращает указанное значение по умолчанию, если настройки не существуют.
// Если нет права СохранениеДанныхПользователя, возвращается значение по умолчанию без ошибки.
//
// В возвращаемом значении очищаются ссылки на несуществующий объект в базе данных, а именно
// - возвращаемая ссылка заменяется на указанное значение по умолчанию;
// - из данных типа Массив ссылки удаляются;
// - у данных типа Структура и Соответствие ключ не меняется, а значение устанавливается Неопределено;
// - анализ значений в данных типа Массив, Структура, Соответствие выполняется рекурсивно.
//
// Параметры:
//   КлючОбъекта          - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек         - Строка           - см. синтакс-помощник платформы.
//   ЗначениеПоУмолчанию  - Произвольный     - значение, которое возвращается, если настройки не существуют.
//                                             Если не указано, возвращается значение Неопределено.
//   ОписаниеНастроек     - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя      - Строка           - см. синтакс-помощник платформы.
//
// Возвращаемое значение: 
//   Произвольный - см. синтакс-помощник платформы.
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
			ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища настроек данных форм, как метод платформы Удалить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, удаление пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта     - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//   КлючНастроек    - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//   ИмяПользователя - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Настройки,
			ОписаниеНастроек, ИмяПользователя, ОбновитьПовторноИспользуемыеЗначения)
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек(КлючНастроек), Настройки,
		ОписаниеНастроек, ИмяПользователя);
	
	Если ОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
			ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек(КлючНастроек),
			ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
	
	Если Результат = Неопределено Тогда
		Результат = ЗначениеПоУмолчанию;
	Иначе
		УстановитьПривилегированныйРежим(Истина);
		Если ОчиститьНесуществующиеСсылки(Результат) Тогда
			Результат = ЗначениеПоУмолчанию;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Удаляет из переданной коллекции ссылки, ссылающиеся на несуществующие данные в информационной базе.
// Не очищает переданное значение, если в нем передана несуществующая ссылка, а возвращает Ложь. 
//
// Параметры:
//   Значение - ЛюбаяСсылка
//            - Произвольный - проверяемое значение или коллекция.
//
// Возвращаемое значение: 
//   Булево - Истина, если Значение ссылочного типа и объект не существует в информационной базе.
//            Ложь, если Значение не ссылочного типа или объект существует.
//
Функция ОчиститьНесуществующиеСсылки(Значение)
	
	Тип = ТипЗнч(Значение);
	Если Тип = Тип("Неопределено")
		Или Тип = Тип("Булево")
		Или Тип = Тип("Строка")
		Или Тип = Тип("Число")
		Или Тип = Тип("Дата") Тогда // Оптимизация - часто используемые примитивные типы.
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Тип = Тип("Массив") Тогда
		
		Количество = Значение.Количество();
		Для Номер = 1 По Количество Цикл
			ОбратныйИндекс = Количество - Номер;
			// @skip-check query-in-loop - выборка ссылок из разных таблиц.
			Если ОчиститьНесуществующиеСсылки(Значение[ОбратныйИндекс]) Тогда
				Значение.Удалить(ОбратныйИндекс);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Тип = Тип("Структура")
		Или Тип = Тип("Соответствие") Тогда
		
		Для Каждого КлючИЗначение Из Значение Цикл
			// @skip-check query-in-loop - выборка ссылок из разных таблиц.
			Если ОчиститьНесуществующиеСсылки(КлючИЗначение.Значение) Тогда
				Значение.Вставить(КлючИЗначение.Ключ, Неопределено);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип)
		Или Справочники.ТипВсеСсылки().СодержитТип(Тип)
		Или Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип)
		Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		Или Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		// Ссылочный тип, исключая ТочкаМаршрутаБизнесПроцессаСсылка.
		
		Если Значение.Пустая() Тогда
			Возврат Ложь; // Ссылка пустая.
		КонецЕсли;
		Возврат ЗначениеРеквизитаОбъекта(Значение, "Ссылка") = Неопределено;
		
	Иначе
		Возврат Ложь; // Не ссылка.
	КонецЕсли;
	
КонецФункции

Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек(КлючНастроек), ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает строку ключа настроек, не превышающую допустимую длину 128 символов.
// Если указанная строка превышает 128, тогда вместо символов сверх 96 символов
// добавляется их хеш-сумма по алгоритму MD5 размером 32 символа.
//
// Параметры:
//  Строка - Строка - строка произвольной длины.
//
// Возвращаемое значение:
//  Строка - не более 128 символов.
//
Функция КлючНастроек(Знач Строка)
	Возврат СократитьСтрокуКонтрольнойСуммой(Строка, 128);
КонецФункции

// Сокращает строку до нужной длины, при этом обрезанная часть хешируется,
// обеспечивая уникальность строки. Проверяет длину строки на входе и, в случае
// превышения максимальной длины, преобразует ее конец по алгоритму MD5 в
// уникальную строку из 32 символов.
//
// Параметры:
//  Строка            - Строка - исходная строка произвольной длины.
//  МаксимальнаяДлина - Число  - требуемое максимальное количество символов в строке,
//                               минимальное значение: 32.
// 
// Возвращаемое значение:
//   Строка - строка, не превышающая максимальную длину.
//
Функция СократитьСтрокуКонтрольнойСуммой(Строка, МаксимальнаяДлина) Экспорт
	
	Если МаксимальнаяДлина < 32 Тогда
		Проверить(Ложь, ПодставитьПараметрыВСтроку(НСтр("ru = 'Параметр %1 не может быть меньше 32.'"),	"МаксимальнаяДлина"), "ОбщегоНазначения.СократитьСтрокуКонтрольнойСуммой");
	КонецЕсли;
	
	Результат = Строка;
	Если СтрДлина(Строка) > МаксимальнаяДлина Тогда
		Результат = Лев(Строка, МаксимальнаяДлина - 32);
		ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
		ХешированиеДанных.Добавить(Сред(Строка, МаксимальнаяДлина - 32 + 1));
		Результат = Результат + СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	КонецЕсли;
	Возврат Результат;
КонецФункции

#КонецОбласти

// Вызывает исключение с текстом Сообщение, если Условие не равно Истина.
// Применяется для самодиагностики кода.
//
// Параметры:
//   Условие - Булево - если не равно Истина, то вызывается исключение.
//   Сообщение - Строка - текст сообщения. Если не задан, то исключение вызывается с сообщением по умолчанию.
//   КонтекстПроверки - Строка - например, имя процедуры или функции, в которой выполняется проверка.
//
Процедура Проверить(Знач Условие, Знач Сообщение = "", Знач КонтекстПроверки = "") Экспорт
	
	Если Условие <> Истина Тогда
		
		Если ПустаяСтрока(Сообщение) Тогда
			ТекстИсключения = НСтр("ru = 'Недопустимая операция'"); // Assertion failed
		Иначе
			ТекстИсключения = Сообщение;
		КонецЕсли;
		
		Если Не ПустаяСтрока(КонтекстПроверки) Тогда
			ТекстИсключения = ПодставитьПараметрыВСтроку(НСтр("ru = '%1 в %2'"), ТекстИсключения, КонтекстПроверки);
		КонецЕсли;
		
		ВызватьИсключение ТекстИсключения;
		
	КонецЕсли;
	
КонецПроцедуры

// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров начинается с единицы.
//
// Параметры:
//  ШаблонСтроки  - Строка - шаблон строки с параметрами (вхождениями вида "%<номер параметра>", 
//                           например "%1 пошел в %2");
//  Параметр1   - Строка - значение подставляемого параметра.
//  Параметр2   - Строка
//  Параметр3   - Строка
//  Параметр4   - Строка
//  Параметр5   - Строка
//  Параметр6   - Строка
//  Параметр7   - Строка
//  Параметр8   - Строка
//  Параметр9   - Строка
//
// Возвращаемое значение:
//  Строка   - текстовая строка с подставленными параметрами.
//
// Пример:
//  ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), "Вася", "Зоопарк") = "Вася пошел
//  в Зоопарк".
//
Функция ПодставитьПараметрыВСтроку(Знач ШаблонСтроки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено) Экспорт
	
	ЕстьПараметрыСПроцентом = СтрНайти(Параметр1, "%")
		Или СтрНайти(Параметр2, "%")
		Или СтрНайти(Параметр3, "%")
		Или СтрНайти(Параметр4, "%")
		Или СтрНайти(Параметр5, "%")
		Или СтрНайти(Параметр6, "%")
		Или СтрНайти(Параметр7, "%")
		Или СтрНайти(Параметр8, "%")
		Или СтрНайти(Параметр9, "%");
		
	Если ЕстьПараметрыСПроцентом Тогда
		Возврат ПодставитьПараметрыСПроцентом(ШаблонСтроки, Параметр1,
			Параметр2, Параметр3, Параметр4, Параметр5, Параметр6, Параметр7, Параметр8, Параметр9);
	КонецЕсли;
	
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%1", Параметр1);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%2", Параметр2);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%3", Параметр3);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%4", Параметр4);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%5", Параметр5);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%6", Параметр6);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%7", Параметр7);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%8", Параметр8);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%9", Параметр9);
	Возврат ШаблонСтроки;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы по ссылке на объект.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
// 
// Если передано имя несуществующего реквизита, то вызывается исключение "Поле объекта не существует". 
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  ИмяРеквизита       - Строка - имя получаемого реквизита.
//                                Допускается указание имени реквизита через точку, но при этом параметр КодЯзыка для
//                                такого реквизита учитываться не будет.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя;
//                                если есть ограничение на уровне записей, то возвращается Неопределено;
//                                если нет прав для работы с таблицей, то возникнет исключение;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Произвольный - если в параметр Ссылка передана пустая ссылка, то возвращается Неопределено.
//                 Если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//                 то возвращается Неопределено.
//
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		ВызватьИсключение(ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Имя реквизита должно быть заполнено.'"), 
			"ИмяРеквизита", "ОбщегоНазначения.ЗначениеРеквизитаОбъекта"),
			КатегорияОшибки.ОшибкаКонфигурации);
	КонецЕсли;
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные, КодЯзыка);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы по ссылке на объект.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//                       требований к свойствам структуры.
//                       Например, "Код, Наименование, Родитель".
//            - Структура
//            - ФиксированнаяСтруктура - в качестве ключа передается
//                       псевдоним поля для возвращаемой структуры с результатом, а в качестве
//                       значения (опционально) фактическое имя поля в таблице.
//                       Если ключ задан, а значение не определено, то имя поля берется из ключа.
//                       Допускается указание имени поля через точку, но при этом параметр КодЯзыка для такого поля
//                       учитываться не будет.
//            - Массив из Строка
//            - ФиксированныйМассив из Строка - имена реквизитов в формате требований к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя;
//                                если есть ограничение на уровне записей, то все реквизиты вернутся со 
//                                значением Неопределено; если нет прав для работы с таблицей, то возникнет исключение;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу 
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если в параметр Реквизиты передана пустая строка, то возвращается пустая структура.
//              Если в параметр Ссылка передана пустая ссылка, то возвращается структура, 
//              соответствующая именам реквизитов со значениями Неопределено.
//              Если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//              то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	// Если передано имя предопределенного.
	Если ТипЗнч(Ссылка) = Тип("Строка") Тогда
		
		ПолноеИмяПредопределенногоЭлемента = Ссылка;
		
		// Вычисление ссылки по имени предопределенного.
		// - дополнительно выполняет проверку метаданных предопределенного, выполняется предварительно.
		Попытка
			Ссылка = ПредопределенныйЭлемент(ПолноеИмяПредопределенногоЭлемента);
		Исключение
			ТекстОшибки = ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный первый параметр %1 в функции %2:
				|%3'"), "Ссылка", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", 
				ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение(ТекстОшибки, КатегорияОшибки.ОшибкаКонфигурации);
		КонецПопытки;
		
		// Разбор полного имени предопределенного.
		ЧастиПолногоИмени = СтрРазделить(ПолноеИмяПредопределенногоЭлемента, ".");
		ПолноеИмяОбъектаМетаданных = ЧастиПолногоИмени[0] + "." + ЧастиПолногоИмени[1];
		
		// Если предопределенный не создан в ИБ, то требуется выполнить проверку доступа к объекту.
		// В других сценариях проверка доступа выполняется в момент исполнения запроса.
		Если Ссылка = Неопределено Тогда 
			МетаданныеОбъекта = ОбъектМетаданныхПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
			Если Не ПравоДоступа("Чтение", МетаданныеОбъекта) Тогда 
				ВызватьИсключение(ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Недостаточно прав для работы с таблицей ""%1""'"), ПолноеИмяОбъектаМетаданных),
					КатегорияОшибки.НарушениеПравДоступа);
			КонецЕсли;
		КонецЕсли;
		
	Иначе // Если передана ссылка.
		
		Попытка
			ПолноеИмяОбъектаМетаданных = Ссылка.Метаданные().ПолноеИмя(); 
		Исключение
			ВызватьИсключение (ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный первый параметр %1 в функции %2: 
					|Значение должно быть ссылкой или именем предопределенного элемента.'"), 
				"Ссылка", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта"),
				КатегорияОшибки.ОшибкаКонфигурации);
		КонецПопытки;
		
	КонецЕсли;
	
	// Разбор реквизитов, если второй параметр Строка.
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
		Для Индекс = 0 По Реквизиты.ВГраница() Цикл
			Реквизиты[Индекс] = СокрЛП(Реквизиты[Индекс]);
		КонецЦикла;
	КонецЕсли;
	
	МультиязычныеРеквизиты = Новый Соответствие;
	СуффиксЯзыка = "";
	Если ЗначениеЗаполнено(КодЯзыка) Тогда
		Если ПодсистемаСуществует("СтандартныеПодсистемы.Мультиязычность") Тогда
			МодульМультиязычностьСервер = ОбщийМодуль("МультиязычностьСервер");
			СуффиксЯзыка = МодульМультиязычностьСервер.СуффиксЯзыка(КодЯзыка);
			Если ЗначениеЗаполнено(СуффиксЯзыка) Тогда
				МультиязычныеРеквизиты = МодульМультиязычностьСервер.МультиязычныеРеквизитыОбъекта(Ссылка);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// Приведение реквизитов к единому формату.
	СтруктураПолей = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		Для Каждого КлючИЗначение Из Реквизиты Цикл
			СтруктураПолей.Вставить(КлючИЗначение.Ключ, СокрЛП(КлючИЗначение.Значение));
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		Для Каждого Реквизит Из Реквизиты Цикл
			Реквизит = СокрЛП(Реквизит);
			Попытка
				ПсевдонимПоля = СтрЗаменить(Реквизит, ".", "");
				СтруктураПолей.Вставить(ПсевдонимПоля, Реквизит);
			Исключение 
				// Если псевдоним не является ключом.
				
				// Поиск ошибки доступности полей.
				Результат = ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
				Если Результат.Ошибка Тогда 
					ВызватьИсключение(ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"),
						"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Результат.ОписаниеОшибки),
						КатегорияОшибки.ОшибкаКонфигурации);
				КонецЕсли;
				
				// Не удалось распознать ошибку, проброс первичной ошибки.
				ВызватьИсключение;
			
			КонецПопытки;
		КонецЦикла;
	Иначе
		ВызватьИсключение(ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра %1 в функции %2: %3.'"), 
			"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Строка(ТипЗнч(Реквизиты))),
			КатегорияОшибки.ОшибкаКонфигурации);
	КонецЕсли;
	
	// Подготовка результата (после выполнения запроса переопределится).
	Результат = Новый Структура;
	
	// Формирование текста запроса к выбираемым полям.
	ТекстЗапросаПолей = "";
	Для каждого КлючИЗначение Из СтруктураПолей Цикл
		
		ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
		ПсевдонимПоля = КлючИЗначение.Ключ;
		
		Если МультиязычныеРеквизиты[ИмяПоля] <> Неопределено Тогда
			ИмяПоля = ИмяПоля + СуффиксЯзыка;
		КонецЕсли;
		
		ТекстЗапросаПолей = 
			ТекстЗапросаПолей + ?(ПустаяСтрока(ТекстЗапросаПолей), "", ",") + "
			|	" + ИмяПоля + " КАК " + ПсевдонимПоля;
		
		// Предварительное добавление поля по псевдониму в возвращаемый результат.
		Результат.Вставить(ПсевдонимПоля);
		
	КонецЦикла;
	
	// Если предопределенного нет в ИБ.
	// - приведение результата к отсутствию объекта в ИБ или передаче пустой ссылки.
	Если Ссылка = Неопределено Тогда 
		Возврат Результат;
	КонецЕсли;
	
	Если Тип("Структура") = ТипЗнч(Реквизиты)
		Или Тип("ФиксированнаяСтруктура") = ТипЗнч(Реквизиты) Тогда
		Реквизиты = Новый Массив;
		Для Каждого КлючИЗначение Из СтруктураПолей Цикл
			ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
			Реквизиты.Добавить(ИмяПоля);
		КонецЦикла;
	КонецЕсли;
	
	РеквизитыЧерезТочку = Новый Массив;
	Для Индекс = -Реквизиты.ВГраница() По 0 Цикл
		ИмяПоля = Реквизиты[-Индекс];
		Если СтрНайти(ИмяПоля, ".") Тогда
			РеквизитыЧерезТочку.Добавить(ИмяПоля);
			Реквизиты.Удалить(-Индекс);
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(Реквизиты) Тогда
		ЗначенияРеквизитовОбъекта = ЗначенияРеквизитовОбъектов(ЗначениеВМассиве(Ссылка), Реквизиты, ВыбратьРазрешенные, КодЯзыка)[Ссылка];
		Если ЗначенияРеквизитовОбъекта <> Неопределено Тогда
			Для Каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Если СтрНайти(ИмяПоля, ".") = 0 И ЗначенияРеквизитовОбъекта.Свойство(ИмяПоля) Тогда
					Результат[КлючИЗначение.Ключ] = ЗначенияРеквизитовОбъекта[ИмяПоля];
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(РеквизитыЧерезТочку) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Реквизиты = РеквизитыЧерезТочку;
	
	ТекстЗапроса = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|&ТекстЗапросаПолей
		|ИЗ
		|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка";
	
	Если Не ВыбратьРазрешенные Тогда 
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", ""); // @Query-part-1
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекстЗапросаПолей", ТекстЗапросаПолей);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
	
	// Выполнение запроса.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Если реквизиты были переданы строкой, то они уже конвертированы в массив.
		// Если реквизиты - массив, оставляем без изменений.
		// Если реквизиты - структура - конвертируем в массив.
		// В остальных случаях уже было бы выброшено исключение.
		Если Тип("Структура") = ТипЗнч(Реквизиты)
			Или Тип("ФиксированнаяСтруктура") = ТипЗнч(Реквизиты) Тогда
			Реквизиты = Новый Массив;
			Для каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Реквизиты.Добавить(ИмяПоля);
			КонецЦикла;
		КонецЕсли;
		
		// Поиск ошибки доступности полей.
		Результат = ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда 
			ВызватьИсключение(ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"), 
				"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Результат.ОписаниеОшибки),
				КатегорияОшибки.ОшибкаКонфигурации);
		КонецЕсли;

		ВызватьИсключение;
		
	КонецПопытки;
	
	// Заполнение реквизитов.
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значения реквизитов, прочитанные из информационной базы для нескольких объектов.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Если передано имя несуществующего реквизита, то вызывается исключение "Поле объекта не существует". 
//
// Параметры:
//  Ссылки - Массив из ЛюбаяСсылка
//         - ФиксированныйМассив из ЛюбаяСсылка - ссылки на объекты.
//           Если массив пуст, то результатом будет пустое соответствие.
//  Реквизиты - Строка - имена реквизитов перечисленные через запятую, в формате требований к свойствам
//                       структуры. Например, "Код, Наименование, Родитель".
//            - Массив из Строка
//            - ФиксированныйМассив из Строка - имена реквизитов в формате требований к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя;
//                                если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                будет исключен и из результата;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - список объектов и значений их реквизитов:
//   * Ключ - ЛюбаяСсылка - ссылка на объект;
//   * Значение - Структура:
//    ** Ключ - Строка - имя реквизита;
//    ** Значение - Произвольный - значение реквизита.
// 
Функция ЗначенияРеквизитовОбъектов(Ссылки, Знач Реквизиты, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Реквизиты = СтрСоединить(Реквизиты, ",");
	КонецЕсли;
	
	Если ПустаяСтрока(Реквизиты) Тогда 
		ВызватьИсключение(ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Поле объекта должно быть указано.'"), 
			"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов"),
			КатегорияОшибки.ОшибкаКонфигурации);
	КонецЕсли;
	
	Если СтрНайти(Реквизиты, ".") <> 0 Тогда 
		ВызватьИсключение(ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Обращение через точку не поддерживается.'"), 
			"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов"),
			КатегорияОшибки.ОшибкаКонфигурации);
	КонецЕсли;
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если Ссылки.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(КодЯзыка) Тогда
		КодЯзыка = СтрРазделить(КодЯзыка, "_", Истина)[0];
	КонецЕсли;
	
	РеквизитыТекстЗапроса = Реквизиты;
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.Мультиязычность") Тогда
		МодульМультиязычностьСервер = ОбщийМодуль("МультиязычностьСервер");
		Если ЗначениеЗаполнено(КодЯзыка) Тогда
			СуффиксЯзыка = МодульМультиязычностьСервер.СуффиксЯзыка(КодЯзыка);
			Если ЗначениеЗаполнено(СуффиксЯзыка) Тогда
				МультиязычныеРеквизиты = МодульМультиязычностьСервер.МультиязычныеРеквизитыОбъекта(Ссылки[0]);
				НаборРеквизитов = СтрРазделить(Реквизиты, ",");
				Для Позиция = 0 По НаборРеквизитов.ВГраница() Цикл
					ИмяРеквизита = СокрЛП(НаборРеквизитов[Позиция]);
					Если МультиязычныеРеквизиты[ИмяРеквизита] <> Неопределено Тогда
						ИмяССуффиксом = ИмяРеквизита + СуффиксЯзыка;
						НаборРеквизитов[Позиция] = ИмяССуффиксом + " КАК " + ИмяРеквизита;
					КонецЕсли;
				КонецЦикла;
				РеквизитыТекстЗапроса = СтрСоединить(НаборРеквизитов, ",");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого Ссылка Из Ссылки Цикл
		Тип = ТипЗнч(Ссылка);
		Если СсылкиПоТипам[Тип] = Неопределено Тогда
			СсылкиПоТипам[Тип] = Новый Массив;
		КонецЕсли;
		ЭлементПоТипу = СсылкиПоТипам[Тип]; // Массив
		ЭлементПоТипу.Добавить(Ссылка);
	КонецЦикла;
	
	ТекстыЗапросов = Новый Массив;
	ПараметрыЗапроса = Новый Структура;
	
	ИменаОбъектовМетаданных = Новый Массив;
	
	Для Каждого СсылкиПоТипу Из СсылкиПоТипам Цикл
		Тип = СсылкиПоТипу.Ключ;
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных = Неопределено Тогда
			ВызватьИсключение(ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный первый параметр %1 в функции %2: 
					|Значения массива должны быть ссылками.'"), 
				"Ссылки", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов"),
				КатегорияОшибки.ОшибкаКонфигурации);
		КонецЕсли;
		
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
		ИменаОбъектовМетаданных.Добавить(ПолноеИмяОбъектаМетаданных);
		
		ТекстЗапроса =
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	Ссылка,
			|	&Реквизиты
			|ИЗ
			|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
			|ГДЕ
			|	ПсевдонимЗаданнойТаблицы.Ссылка В (&Ссылки)";
		Если Не ВыбратьРазрешенные Или ТекстыЗапросов.Количество() > 0 Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", ""); // @Query-part-1
		КонецЕсли;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Реквизиты", РеквизитыТекстЗапроса);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
		ИмяПараметра = "Ссылки" + СтрЗаменить(ПолноеИмяОбъектаМетаданных, ".", "");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Ссылки", "&" + ИмяПараметра); // @Query-part-1
		ПараметрыЗапроса.Вставить(ИмяПараметра, СсылкиПоТипу.Значение);
		
		Если ПодсистемаСуществует("СтандартныеПодсистемы.Мультиязычность") Тогда
			МодульМультиязычностьСервер  = ОбщийМодуль("МультиязычностьСервер");
			
			Если ЗначениеЗаполнено(КодЯзыка) И КодЯзыка <> КодОсновногоЯзыка()
				И МодульМультиязычностьСервер.ОбъектСодержитТЧПредставления(ПолноеИмяОбъектаМетаданных) Тогда
				
				МультиязычныеРеквизиты = МодульМультиязычностьСервер.МультиязычныеРеквизитыОбъекта(ОбъектМетаданных);
				ПоляТаблиц = Новый Массив;
				ПоляТаблиц.Добавить("ПсевдонимЗаданнойТаблицы.Ссылка");
				Для Каждого Реквизит Из СтрРазделить(Реквизиты, ",") Цикл
					Если МультиязычныеРеквизиты[Реквизит] <> Неопределено Тогда
						
						Если МультиязычныеРеквизиты[Реквизит] = Истина Тогда
							ПолеРеквизита = "ЕСТЬNULL(ТаблицаПредставления." + Реквизит + ", """")";
						Иначе
							СуффиксЯзыка = МодульМультиязычностьСервер.СуффиксЯзыка(КодЯзыка);
							ПолеРеквизита = ?(ЗначениеЗаполнено(СуффиксЯзыка), Реквизит + СуффиксЯзыка, Реквизит);
						КонецЕсли;
						
						ПоляТаблиц.Добавить(ПодставитьПараметрыВСтроку("%1 КАК %2",
							ПолеРеквизита, Реквизит));
					Иначе
						ПоляТаблиц.Добавить(Реквизит);
					КонецЕсли;
					
				КонецЦикла;
				
				ПоляТаблиц = СтрСоединить(ПоляТаблиц, "," + Символы.ПС);
				
				Таблицы = ПолноеИмяОбъектаМетаданных + " " + "КАК ПсевдонимЗаданнойТаблицы" + Символы.ПС
					+ "ЛЕВОЕ СОЕДИНЕНИЕ" + " " + ПолноеИмяОбъектаМетаданных + ".Представления КАК ТаблицаПредставления" + Символы.ПС
					+ "ПО ТаблицаПредставления.Ссылка = ПсевдонимЗаданнойТаблицы.Ссылка И ТаблицаПредставления.КодЯзыка = &КодЯзыка";
					
				ИмяПараметра = "Ссылки" + СтрЗаменить(ПолноеИмяОбъектаМетаданных, ".", "");
				Условия = "ПсевдонимЗаданнойТаблицы.Ссылка В (&" + ИмяПараметра + ")";
				
				СтрокиЗапроса = Новый Массив;
				СтрокиЗапроса.Добавить("ВЫБРАТЬ" + ?(ВыбратьРазрешенные И Не ЗначениеЗаполнено(ТекстыЗапросов), " " + "РАЗРЕШЕННЫЕ", "")); // @Query-part-1, @Query-part-3
				СтрокиЗапроса.Добавить(ПоляТаблиц);
				СтрокиЗапроса.Добавить("ИЗ"); // @Query-part-1
				СтрокиЗапроса.Добавить(Таблицы);
				СтрокиЗапроса.Добавить("ГДЕ"); // @Query-part-1
				СтрокиЗапроса.Добавить(Условия);
				
				ТекстЗапроса = СтрСоединить(СтрокиЗапроса, Символы.ПС);
			КонецЕсли;
		КонецЕсли;
		
		ТекстыЗапросов.Добавить(ТекстЗапроса);
	КонецЦикла;
	
	ТекстЗапроса = СтрСоединить(ТекстыЗапросов, Символы.ПС + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("КодЯзыка", КодЯзыка);
	Для Каждого Параметр Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");
		
		// Поиск ошибки доступности полей.
		СписокОшибок = Новый Массив;
		Для Каждого ПолноеИмяОбъектаМетаданных Из ИменаОбъектовМетаданных Цикл
			Результат = ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
			Если Результат.Ошибка Тогда 
				СписокОшибок.Добавить(Результат.ОписаниеОшибки);
			КонецЕсли;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(СписокОшибок) Тогда
			ВызватьИсключение(ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"), 
				"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов", 
				СтрСоединить(СписокОшибок, Символы.ПС)),
				КатегорияОшибки.ОшибкаКонфигурации);
		КонецЕсли;
		
		ВызватьИсключение;
		
	КонецПопытки;
	
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(Реквизиты);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
		
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает код основного языка информационной базы, например "ru".
// На котором программно записываются автогенерируемые строки в информационную базу.
// Например, при начальном заполнении информационной базы данными из макета, автогенерации комментария
// к проводке или определении значения параметра ИмяСобытия метода ЗаписьЖурналаРегистрации.
//
// Возвращаемое значение:
//  Строка
//
Функция КодОсновногоЯзыка() Экспорт
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.Мультиязычность") Тогда
		МодульМультиязычностьСервер = ОбщийМодуль("МультиязычностьСервер");
		Возврат МодульМультиязычностьСервер.КодОсновногоЯзыка();
	КонецЕсли;
	
	Возврат Метаданные.ОсновнойЯзык.КодЯзыка;
	
КонецФункции

// Создает массив и помещает в него переданное значение.
//
// Параметры:
//  Значение - Произвольный - любое значение.
//
// Возвращаемое значение:
//  Массив - массив из одного элемента.
//
Функция ЗначениеВМассиве(Знач Значение) Экспорт
	
	Результат = Новый Массив;
	Результат.Добавить(Значение);
	Возврат Результат;
	
КонецФункции

// Возвращает ссылку предопределенного элемента по его полному имени.
// Предопределенные элементы могут содержаться только в следующих объектах:
//   - справочники;
//   - планы видов характеристик;
//   - планы счетов;
//   - планы видов расчета.
// После изменения состава предопределенных следует выполнить метод
// ОбновитьПовторноИспользуемыеЗначения(), который сбросит кэш ПовтИсп в текущем сеансе.
//
// Параметры:
//   ПолноеИмяПредопределенного - Строка - полный путь к предопределенному элементу, включая его имя.
//     Формат аналогичен функции глобального контекста ПредопределенноеЗначение().
//     Например:
//       "Справочник.ВидыКонтактнойИнформации.EmailПользователя"
//       "ПланСчетов.Хозрасчетный.Материалы"
//       "ПланВидовРасчета.Начисления.ОплатаПоОкладу".
//
// Возвращаемое значение: 
//   ЛюбаяСсылка - ссылка на предопределенный элемент.
//   Неопределено - если предопределенный элемент есть в метаданных, но не создан в ИБ.
//
Функция ПредопределенныйЭлемент(ПолноеИмяПредопределенного) Экспорт
	
	СтандартнаяОбработка = ИспользоватьСтандартнуюФункциюПолученияПредопределенного(ПолноеИмяПредопределенного);
	
	Если СтандартнаяОбработка Тогда 
		Возврат ПредопределенноеЗначение(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	ПоляПредопределенного = ИмяПредопределенногоПоПолям(ПолноеИмяПредопределенного);
	
	ПредопределенныеЗначения = СсылкиПоИменамПредопределенных(ПоляПредопределенного.ПолноеИмяОбъектаМетаданных);
	
	Возврат ПредопределенныйЭлементСлужебная(ПолноеИмяПредопределенного, ПоляПредопределенного, ПредопределенныеЗначения);
	
КонецФункции

// Возвращает соответствие имен предопределенных значений ссылкам на них.
//
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - например, "Справочник.ВидыНоменклатуры",
//                               Поддерживаются только таблицы
//                               с предопределенными элементами:
//                               > Справочники,
//                               > Планы видов характеристик,
//                               > Планы счетов,
//                               > Планы видов расчета.
//
// Возвращаемое значение:
//  ФиксированноеСоответствие из КлючИЗначение:
//      * Ключ     - Строка - имя предопределенного,
//      * Значение - СправочникСсылка
//                 - ПланВидовХарактеристикСсылка
//                 - ПланСчетовСсылка
//                 - ПланВидовРасчетаСсылка
//                 - Null - ссылка предопределенного или Null, если объекта нет в ИБ.
//
//  Если ошибка в имени метаданных или неподходящий тип метаданного, то возвращается Неопределено.
//  Если предопределенных у метаданного нет, то возвращается пустое фиксированное соответствие.
//  Если предопределенный определен в метаданных, но не создан в ИБ, то для него в соответствии возвращается Null.
//
Функция СсылкиПоИменамПредопределенных(ПолноеИмяОбъектаМетаданных) Экспорт
	
	ПредопределенныеЗначения = Новый Соответствие;
	
	МетаданныеОбъекта = ОбъектМетаданныхПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	
	// Если метаданных не существует.
	Если МетаданныеОбъекта = Неопределено Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	// Если не подходящий тип метаданных.
	Если Не Метаданные.Справочники.Содержит(МетаданныеОбъекта)
		И Не Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеОбъекта)
		И Не Метаданные.ПланыСчетов.Содержит(МетаданныеОбъекта)
		И Не Метаданные.ПланыВидовРасчета.Содержит(МетаданныеОбъекта) Тогда 
		
		Возврат Неопределено;
	КонецЕсли;
	
	ИменаПредопределенных = МетаданныеОбъекта.ПолучитьИменаПредопределенных();
	
	// Если предопределенных у метаданного нет.
	Если ИменаПредопределенных.Количество() = 0 Тогда 
		Возврат Новый ФиксированноеСоответствие(ПредопределенныеЗначения);
	КонецЕсли;
	
	// Заполнение по умолчанию признаком отсутствия в ИБ (присутствующие переопределятся).
	Для каждого ИмяПредопределенного Из ИменаПредопределенных Цикл 
		ПредопределенныеЗначения.Вставить(ИмяПредопределенного, Null);
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТекущаяТаблица.Ссылка КАК Ссылка,
		|	ТекущаяТаблица.ИмяПредопределенныхДанных КАК ИмяПредопределенныхДанных
		|ИЗ
		|	&ТекущаяТаблица КАК ТекущаяТаблица
		|ГДЕ
		|	ТекущаяТаблица.Предопределенный";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", ПолноеИмяОбъектаМетаданных);
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
	// Заполнение присутствующих в ИБ.
	Пока Выборка.Следующий() Цикл
		ПредопределенныеЗначения.Вставить(Выборка.ИмяПредопределенныхДанных, Выборка.Ссылка);
	КонецЦикла;
	
	Возврат Новый ФиксированноеСоответствие(ПредопределенныеЗначения);
	
КонецФункции

Функция ИспользоватьСтандартнуюФункциюПолученияПредопределенного(ПолноеИмяПредопределенного) Экспорт
	
	// Используется стандартная функция платформы для получения:
	//  - пустых ссылок; 
	//  - значений перечислений;
	//  - точек маршрута бизнес-процессов.
	
	Возврат СтрЗаканчиваетсяНа(ВРег(ПолноеИмяПредопределенного), ".ПУСТАЯССЫЛКА")
		Или СтрНачинаетсяС(ВРег(ПолноеИмяПредопределенного), "ПЕРЕЧИСЛЕНИЕ.")
		Или СтрНачинаетсяС(ВРег(ПолноеИмяПредопределенного), "БИЗНЕСПРОЦЕСС.");
	
КонецФункции

Функция ИмяПредопределенногоПоПолям(ПолноеИмяПредопределенного) Экспорт
	
	ЧастиПолногоИмени = СтрРазделить(ПолноеИмяПредопределенного, ".");
	Если ЧастиПолногоИмени.Количество() <> 3 Тогда 
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	ПолноеИмяОбъектаМетаданных = ВРег(ЧастиПолногоИмени[0] + "." + ЧастиПолногоИмени[1]);
	ИмяПредопределенного = ЧастиПолногоИмени[2];
	
	Результат = Новый Структура;
	Результат.Вставить("ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
	Результат.Вставить("ИмяПредопределенного", ИмяПредопределенного);
	
	Возврат Результат;
	
КонецФункции

Функция ПредопределенныйЭлементСлужебная(ПолноеИмяПредопределенного, ПоляПредопределенного, ПредопределенныеЗначения) Экспорт
	
	// Если ошибка в имени метаданных.
	Если ПредопределенныеЗначения = Неопределено Тогда 
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	// Получение результата из кэша.
	Результат = ПредопределенныеЗначения.Получить(ПоляПредопределенного.ИмяПредопределенного);
	
	// Если предопределенного нет в метаданных.
	Если Результат = Неопределено Тогда 
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	// Если предопределенный есть в метаданных, но не создан в ИБ.
	Если Результат = Null Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного) Экспорт
	
	Возврат ПодставитьПараметрыВСтроку(НСтр("ru = 'Предопределенное значение ""%1"" не существует.'"), ПолноеИмяПредопределенного);
	
КонецФункции

// Возвращает ОбъектМетаданных, быстро найденный по полному имени.
// Более производительный аналог метода платформы Метаданные.НайтиПоПолномуИмени
// для корневых объектов метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, например, Справочник.Организации
//
// Возвращаемое значение:
//  ОбъектМетаданных - когда найден
//  Неопределено - когда не найден
//
Функция ОбъектМетаданныхПоПолномуИмени(ПолноеИмя) Экспорт
	
	ПозицияТочки = СтрНайти(ПолноеИмя, ".");
	ИмяБазовогоТипа = Лев(ПолноеИмя, ПозицияТочки - 1);
	
	ИменаКоллекций = ИменаКоллекцийПоИменамБазовыхТипов();
	Коллекция = ИменаКоллекций.Получить(ВРег(ИмяБазовогоТипа));
	
	Если Коллекция <> Неопределено Тогда
		Если Коллекция <> "Подсистемы" Тогда
			ИмяОбъекта = Сред(ПолноеИмя, ПозицияТочки + 1);
			ОбъектМетаданных = Метаданные[Коллекция].Найти(ИмяОбъекта);
		Иначе
			ИменаПодсистем = СтрРазделить(ВРег(ПолноеИмя), ".");
			Количество = ИменаПодсистем.Количество();
			Подсистема = Метаданные;
			ОбъектМетаданных = Неопределено;
			Индекс = 0;
			Пока Истина Цикл
				Индекс = Индекс + 1;
				Если Индекс >= Количество Тогда
					Прервать;
				КонецЕсли;
				ИмяПодсистемы = ИменаПодсистем[Индекс];
				Подсистема = Подсистема.Подсистемы.Найти(ИмяПодсистемы);
				Если Подсистема = Неопределено Тогда
					Прервать;
				КонецЕсли;
				Индекс = Индекс + 1;
				Если Индекс = Количество Тогда
					ОбъектМетаданных = Подсистема;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если ОбъектМетаданных = Неопределено Тогда
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
	КонецЕсли;
	
	Возврат ОбъектМетаданных;
	
КонецФункции

Функция ИменаКоллекцийПоИменамБазовыхТипов() Экспорт
	
	ИменаКоллекций = Новый Соответствие;
	ИменаКоллекций.Вставить(ВРег("Подсистема"), "Подсистемы");
	ИменаКоллекций.Вставить(ВРег("ОбщийМодуль"), "ОбщиеМодули");
	ИменаКоллекций.Вставить(ВРег("ПараметрСеанса"), "ПараметрыСеанса");
	ИменаКоллекций.Вставить(ВРег("Роль"), "Роли");
	ИменаКоллекций.Вставить(ВРег("ОбщийРеквизит"), "ОбщиеРеквизиты");
	ИменаКоллекций.Вставить(ВРег("ПланОбмена"), "ПланыОбмена");
	ИменаКоллекций.Вставить(ВРег("КритерийОтбора"), "КритерииОтбора");
	ИменаКоллекций.Вставить(ВРег("ПодпискаНаСобытие"), "ПодпискиНаСобытия");
	ИменаКоллекций.Вставить(ВРег("РегламентноеЗадание"), "РегламентныеЗадания");
	ИменаКоллекций.Вставить(ВРег("ФункциональнаяОпция"), "ФункциональныеОпции");
	ИменаКоллекций.Вставить(ВРег("ПараметрФункциональныхОпций"), "ПараметрыФункциональныхОпций");
	ИменаКоллекций.Вставить(ВРег("ОпределяемыйТип"), "ОпределяемыеТипы");
	ИменаКоллекций.Вставить(ВРег("ХранилищеНастроек"), "ХранилищаНастроек");
	ИменаКоллекций.Вставить(ВРег("ОбщаяФорма"), "ОбщиеФормы");
	ИменаКоллекций.Вставить(ВРег("ОбщаяКоманда"), "ОбщиеКоманды");
	ИменаКоллекций.Вставить(ВРег("ГруппаКоманд"), "ГруппыКоманд");
	ИменаКоллекций.Вставить(ВРег("ОбщийМакет"), "ОбщиеМакеты");
	ИменаКоллекций.Вставить(ВРег("ОбщаяКартинка"), "ОбщиеКартинки");
	ИменаКоллекций.Вставить(ВРег("ПакетXDTO"), "ПакетыXDTO");
	ИменаКоллекций.Вставить(ВРег("WebСервис"), "WebСервисы");
	ИменаКоллекций.Вставить(ВРег("HTTPСервис"), "HTTPСервисы");
	ИменаКоллекций.Вставить(ВРег("WSСсылка"), "WSСсылки");
	ИменаКоллекций.Вставить(ВРег("СервисИнтеграции"), "СервисыИнтеграции");
	ИменаКоллекций.Вставить(ВРег("ЭлементСтиля"), "ЭлементыСтиля");
	ИменаКоллекций.Вставить(ВРег("Стиль"), "Стили");
	ИменаКоллекций.Вставить(ВРег("Язык"), "Языки");
	ИменаКоллекций.Вставить(ВРег("Константа"), "Константы");
	ИменаКоллекций.Вставить(ВРег("Справочник"), "Справочники");
	ИменаКоллекций.Вставить(ВРег("Документ"), "Документы");
	ИменаКоллекций.Вставить(ВРег("Последовательность"), "Последовательности");
	ИменаКоллекций.Вставить(ВРег("ЖурналДокументов"), "ЖурналыДокументов");
	ИменаКоллекций.Вставить(ВРег("Перечисление"), "Перечисления");
	ИменаКоллекций.Вставить(ВРег("Отчет"), "Отчеты");
	ИменаКоллекций.Вставить(ВРег("Обработка"), "Обработки");
	ИменаКоллекций.Вставить(ВРег("ПланВидовХарактеристик"), "ПланыВидовХарактеристик");
	ИменаКоллекций.Вставить(ВРег("ПланСчетов"), "ПланыСчетов");
	ИменаКоллекций.Вставить(ВРег("ПланВидовРасчета"), "ПланыВидовРасчета");
	ИменаКоллекций.Вставить(ВРег("РегистрСведений"), "РегистрыСведений");
	ИменаКоллекций.Вставить(ВРег("РегистрНакопления"), "РегистрыНакопления");
	ИменаКоллекций.Вставить(ВРег("РегистрБухгалтерии"), "РегистрыБухгалтерии");
	ИменаКоллекций.Вставить(ВРег("РегистрРасчета"), "РегистрыРасчета");
	ИменаКоллекций.Вставить(ВРег("БизнесПроцесс"), "БизнесПроцессы");
	ИменаКоллекций.Вставить(ВРег("Задача"), "Задачи");
	ИменаКоллекций.Вставить(ВРег("ВнешниеИсточникиДанных"), "ВнешнийИсточникДанных");
	
	Возврат Новый ФиксированноеСоответствие(ИменаКоллекций);
	
КонецФункции

// Возвращает Истина, если функциональная подсистема существует в конфигурации.
// Предназначена для вызова необязательной подсистемы (условного вызова) совместно с ОбщегоНазначения.ОбщийМодуль.
//
// У функциональной подсистемы снят флажок "Включать в командный интерфейс".
// См. также ОбщегоНазначенияПереопределяемый.ПриОпределенииОтключенныхПодсистем
// и ОбщегоНазначенияКлиент.ПодсистемаСуществует для вызова из клиентского кода.
//
// Параметры:
//  ПолноеИмяПодсистемы - Строка - полное имя объекта метаданных подсистема
//                        без слов "Подсистема." и с учетом регистра символов.
//                        Например: "СтандартныеПодсистемы.ВариантыОтчетов".
//
// Пример:
//  Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВариантыОтчетов") Тогда
//  	МодульВариантыОтчетов = ОбщегоНазначения.ОбщийМодуль("ВариантыОтчетов");
//  	МодульВариантыОтчетов.<Имя процедуры>();
//  КонецЕсли;
//
// Возвращаемое значение:
//  Булево
//
Функция ПодсистемаСуществует(ПолноеИмяПодсистемы) Экспорт
	
	ИменаПодсистем = ИменаПодсистем();
	Возврат ИменаПодсистем.Получить(ПолноеИмяПодсистемы) <> Неопределено;
	
КонецФункции

// Возвращает соответствие имен "функциональных" подсистем и значения Истина.
// У "функциональной" подсистемы снят флажок "Включать в командный интерфейс".
//
// Возвращаемое значение:
//  ФиксированноеСоответствие из КлючИЗначение:
//   * Ключ - Строка
//   * Значение - Булево
//
Функция ИменаПодсистем() Экспорт
	
	ОтключенныеПодсистемы = Новый Соответствие;
	
	Имена = Новый Соответствие;
	ВставитьИменаПодчиненныхПодсистем(Имена, Метаданные, ОтключенныеПодсистемы);
	
	Возврат Новый ФиксированноеСоответствие(Имена);
	
КонецФункции

// Возвращает ссылку на общий модуль или модуль менеджера по имени.
// Применяется для условного вызова процедуры или функции совместно с ОбщегоНазначения.ПодсистемаСуществует.
// См. также ОбщегоНазначенияКлиент.ОбщийМодуль для вызова клиентского кода.
//
// Параметры:
//  Имя - Строка - имя общего модуля или модуля менеджера, например "ОбновлениеКонфигурации", 
//                 "Обработка.ПолнотекстовыйПоиск".
//
// Возвращаемое значение:
//   ОбщийМодуль
//   МодульМенеджераОбъекта
//
// Пример:
//	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОбновлениеКонфигурации") Тогда
//		МодульОбновлениеКонфигурации = ОбщегоНазначения.ОбщийМодуль("ОбновлениеКонфигурации");
//		МодульОбновлениеКонфигурации.<Имя процедуры>();
//	КонецЕсли;
//
//	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолнотекстовыйПоиск") Тогда
//		МодульОбработкаПолнотекстовыйПоиск = ОбщегоНазначения.ОбщийМодуль("Обработка.ПолнотекстовыйПоиск");
//		МодульОбработкаПолнотекстовыйПоиск.<Имя процедуры>();
//	КонецЕсли;
//
Функция ОбщийМодуль(Имя) Экспорт
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		// АПК:488-выкл ВычислитьВБезопасномРежиме не используется, чтобы избежать вызова ОбщийМодуль рекурсивно.
		УстановитьБезопасныйРежим(Истина);
		Модуль = Вычислить(Имя);
		// АПК:488-вкл
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение(ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверное значение параметра %1 в %2. Общий модуль ""%1"" не существует.'"), 
			"Имя", "ОбщегоНазначения.ОбщийМодуль", Имя), 
			КатегорияОшибки.ОшибкаКонфигурации);
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции
Функция ДанныеИзБезопасногоХранилища(Владельцы, Ключи, ОбщиеДанные)
	
	ИмяБезопасногоХранилищаДанных = "РегистрСведений.ИТКВ_БезопасноеХранилищеДанных";

	ТекстЗапроса =
		"ВЫБРАТЬ
		|	БезопасноеХранилищеДанных.Владелец КАК ВладелецДанных,
		|	БезопасноеХранилищеДанных.Данные КАК Данные
		|ИЗ
		|	#ИмяБезопасногоХранилищаДанных КАК БезопасноеХранилищеДанных
		|ГДЕ
		|	БезопасноеХранилищеДанных.Владелец В (&Владельцы)";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ИмяБезопасногоХранилищаДанных", ИмяБезопасногоХранилищаДанных);
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Владельцы", Владельцы);
	РезультатЗапроса = Запрос.Выполнить().Выбрать();
	
	Результат = Новый Соответствие();
	
	НаборДанныхКлюча = ?(ЗначениеЗаполнено(Ключи) И СтрНайти(Ключи, ","), Новый Структура(Ключи), Неопределено);
	Для Каждого ВладелецДанных Из Владельцы Цикл
		Результат.Вставить(ВладелецДанных, НаборДанныхКлюча);
	КонецЦикла;
	
	Пока РезультатЗапроса.Следующий() Цикл
		
		ДанныеВладельца = Новый Структура(Ключи);
		
		Если ЗначениеЗаполнено(РезультатЗапроса.Данные) Тогда
			
			СохраненныеДанные = РезультатЗапроса.Данные.Получить();
			Если ЗначениеЗаполнено(СохраненныеДанные) Тогда
				
				Если ЗначениеЗаполнено(Ключи) Тогда
					ВладелецДанных = Результат[РезультатЗапроса.ВладелецДанных];
					ЗаполнитьЗначенияСвойств(ДанныеВладельца, СохраненныеДанные);
				Иначе
					ДанныеВладельца = СохраненныеДанные;
				КонецЕсли;
				
				Если Ключи <> Неопределено
					И ДанныеВладельца <> Неопределено
					И ДанныеВладельца.Количество() = 1 Тогда
						ЗначениеПоКлючу = ?(ДанныеВладельца.Свойство(Ключи), ДанныеВладельца[Ключи], Неопределено);
						Результат.Вставить(РезультатЗапроса.ВладелецДанных, ЗначениеПоКлючу);
				Иначе
					Результат.Вставить(РезультатЗапроса.ВладелецДанных, ДанныеВладельца);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Вставляет параметры в строку, учитывая, что в параметрах могут использоваться подстановочные слова %1, %2 и т.д.
Функция ПодставитьПараметрыСПроцентом(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено)
	
	Результат = "";
	Позиция = СтрНайти(СтрокаПодстановки, "%");
	Пока Позиция > 0 Цикл 
		Результат = Результат + Лев(СтрокаПодстановки, Позиция - 1);
		СимволПослеПроцента = Сред(СтрокаПодстановки, Позиция + 1, 1);
		ПодставляемыйПараметр = Неопределено;
		Если СимволПослеПроцента = "1" Тогда
			ПодставляемыйПараметр = Параметр1;
		ИначеЕсли СимволПослеПроцента = "2" Тогда
			ПодставляемыйПараметр = Параметр2;
		ИначеЕсли СимволПослеПроцента = "3" Тогда
			ПодставляемыйПараметр = Параметр3;
		ИначеЕсли СимволПослеПроцента = "4" Тогда
			ПодставляемыйПараметр = Параметр4;
		ИначеЕсли СимволПослеПроцента = "5" Тогда
			ПодставляемыйПараметр = Параметр5;
		ИначеЕсли СимволПослеПроцента = "6" Тогда
			ПодставляемыйПараметр = Параметр6;
		ИначеЕсли СимволПослеПроцента = "7" Тогда
			ПодставляемыйПараметр = Параметр7
		ИначеЕсли СимволПослеПроцента = "8" Тогда
			ПодставляемыйПараметр = Параметр8;
		ИначеЕсли СимволПослеПроцента = "9" Тогда
			ПодставляемыйПараметр = Параметр9;
		КонецЕсли;
		Если ПодставляемыйПараметр = Неопределено Тогда
			Результат = Результат + "%";
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 1);
		Иначе
			Результат = Результат + ПодставляемыйПараметр;
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 2);
		КонецЕсли;
		Позиция = СтрНайти(СтрокаПодстановки, "%");
	КонецЦикла;
	Результат = Результат + СтрокаПодстановки;
	
	Возврат Результат;
КонецФункции

// Проверяет существование указанных реквизитов у объекта метаданных.
// 
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - полное имя проверяемого объекта.
//  ПроверяемыеВыражения       - Массив - имена полей или проверяемые выражения объекта метаданных.
// 
// Возвращаемое значение:
//  Структура:
//   * Ошибка         - Булево - найдена ошибка.
//   * ОписаниеОшибки - Строка - описание найденных ошибок.
//
// Пример:
//  
// Реквизиты = Новый Массив;
// Реквизиты.Добавить("Номер");
// Реквизиты.Добавить("Валюта.НаименованиеПолное");
//
// Результат = ОбщегоНазначения.ПроверитьСуществованиеРеквизитовОбъекта("Документ.ЗаказПокупателя", Реквизиты);
//
// Если Результат.Ошибка Тогда
//     ВызватьИсключение Результат.ОписаниеОшибки;
// КонецЕсли;
//
Функция ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, ПроверяемыеВыражения)
	
	МетаданныеОбъекта = ОбъектМетаданныхПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	Если МетаданныеОбъекта = Неопределено Тогда 
		Возврат Новый Структура("Ошибка, ОписаниеОшибки", Истина, 
			ПодставитьПараметрыВСтроку(НСтр("ru = 'Несуществующий объект метаданных ""%1"".'"), ПолноеИмяОбъектаМетаданных));
	КонецЕсли;

	// Разрешение вызова из безопасного режима внешней обработки или расширения.
	// Информация о доступности полей источника схемы при проверке метаданных не является секретной.
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Схема = Новый СхемаЗапроса;
	Пакет = Схема.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	Оператор = Пакет.Операторы.Получить(0);
	
	Источник = Оператор.Источники.Добавить(ПолноеИмяОбъектаМетаданных, "Таблица");
	ТекстОшибки = "";
	
	Для Каждого ТекущееВыражение Из ПроверяемыеВыражения Цикл
		
		Если Не ПолеИсточникаСхемыЗапросаДоступно(Источник, ТекущееВыражение) Тогда 
			ТекстОшибки = ТекстОшибки + Символы.ПС + ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Поле объекта ""%1"" не существует.'"), ТекущееВыражение);
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат Новый Структура("Ошибка, ОписаниеОшибки", Не ПустаяСтрока(ТекстОшибки), ТекстОшибки);
	
КонецФункции

// Используется в ПроверитьСуществованиеРеквизитовОбъекта.
// Выполняет проверку доступности поля проверяемого выражения в источнике оператора схемы запроса.
//
Функция ПолеИсточникаСхемыЗапросаДоступно(ИсточникОператора, ПроверяемоеВыражение)
	
	ЧастиИмениПоля = СтрРазделить(ПроверяемоеВыражение, ".");
	ДоступныеПоля = ИсточникОператора.Источник.ДоступныеПоля;
	
	ТекущаяЧастьИмениПоля = 0;
	Пока ТекущаяЧастьИмениПоля < ЧастиИмениПоля.Количество() Цикл 
		
		ТекущееПоле = ДоступныеПоля.Найти(ЧастиИмениПоля.Получить(ТекущаяЧастьИмениПоля)); 
		
		Если ТекущееПоле = Неопределено Тогда 
			Возврат Ложь;
		КонецЕсли;
		
		// Инкрементация следующей части имени поля и соответствующего списка доступности полей.
		ТекущаяЧастьИмениПоля = ТекущаяЧастьИмениПоля + 1;
		ДоступныеПоля = ТекущееПоле.Поля;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура ВставитьИменаПодчиненныхПодсистем(Имена, РодительскаяПодсистема, ОтключенныеПодсистемы, ИмяРодительскойПодсистемы = "")
	
	Для Каждого ТекущаяПодсистема Из РодительскаяПодсистема.Подсистемы Цикл
		
		Если ТекущаяПодсистема.ВключатьВКомандныйИнтерфейс Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяТекущейПодсистемы = ИмяРодительскойПодсистемы + ТекущаяПодсистема.Имя;
		Если ОтключенныеПодсистемы.Получить(ИмяТекущейПодсистемы) = Истина Тогда
			Продолжить;
		Иначе
			Имена.Вставить(ИмяТекущейПодсистемы, Истина);
		КонецЕсли;
		
		Если ТекущаяПодсистема.Подсистемы.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ВставитьИменаПодчиненныхПодсистем(Имена, ТекущаяПодсистема, ОтключенныеПодсистемы, ИмяТекущейПодсистемы + ".");
	КонецЦикла;
	
КонецПроцедуры

// Возвращает серверный модуль менеджера по имени объекта.
Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег("Константы") Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыСведений") Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыНакопления") Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыБухгалтерии") Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыРасчета") Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Справочники") Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Документы") Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Отчеты") Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Обработки") Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("БизнесПроцессы") Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ЖурналыДокументов") Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Задачи") Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыСчетов") Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыОбмена") Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовХарактеристик") Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовРасчета") Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение(ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверное значение параметра %1 в функции %2. Объект метаданных ""%3"" не существует.'"), 
			"Имя", "ОбщегоНазначения.СерверныйМодульМенеджера", Имя),
			КатегорияОшибки.ОшибкаКонфигурации);
	КонецЕсли;
	
	// АПК:488-выкл ВычислитьВБезопасномРежиме не используется, чтобы избежать вызова ОбщийМодуль рекурсивно.
	УстановитьБезопасныйРежим(Истина);
	Модуль = Вычислить(Имя);
	// АПК:488-вкл
	
	Возврат Модуль;
КонецФункции
#КонецОбласти
